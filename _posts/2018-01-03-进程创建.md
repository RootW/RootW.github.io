---
layout: post
title: 进程管理之一：进程创建
date: 2018-01-03 
tags: 自顶向下分析计算机系统
---

&emsp;&emsp;进程管理也是计算子系统(CPU&Memory)的核心功能，从本篇博文起，我们开始讨论进程管理。计算子系统相关内容目录[点此进入](https://rootw.github.io/2017/02/计算子系统/)。

### 什么是进程？什么是进程管理？为什么需要进程管理？

&emsp;&emsp;从物理视角说上，进程是CPU上的一段逻辑过程，它的控制(代码段)和数据(数据段)存放于内存；从功能视角说，进程是各种“功能”的实现实体，计算机为人们提供的诸如聊天、上网、看视频等各种功能都是通过进程实现的，因此进程有时也被叫作“任务“。

&emsp;&emsp;进程管理是指与进程相关的一系列动作，如创建、替换、终止、调度、通信等等。进程管理使得一个CPU可以执行若干进程，各进程分时复用CPU的物理资源；内存管理使得多个进程可以共享物理内存；基于上述两个核心功能，计算机系统可以实现多任务并行，大大提升系统运行效率，方使客户使用(想象一下，如果你的计算机一个时刻只能运行一个任务，那将是一种多么糟糕体验)。

### 如何创建进程？

&emsp;&emsp;进程创建就是新建一个进程，这是进程管理最基本的功能。下面我们就来看看进程创建在Linux内核中是如何实现的并深入理解进程要素。

#### **进程要素**

&emsp;&emsp;在深入分析进程创建过程之前，我们需要理解进程最基本的执行要素。回顾一下计算子系统开篇中描绘的系统结构图(如下图)，进程的执行要素包括CPU中的寄存器和内存段两个部分(虚拟内存段最终会映射到物理内存段)：寄存器代表进程的瞬时运行状态；代码段存储指令，控制进程执行逻辑；数据段存储进程的全局数据；堆栈段存储局部数据和动态数据。

<div align="center">
<img src="/images/posts/i440fx/cpu_low_level.jpg" height="550" width="400">  
</div> 

#### **fork、vfork和clone**

&emsp;&emsp;从应用程序开发的层次上，我们应该知道创建进程(或线程，即轻量级进程)有fork、vfork和clone三种方式：fork是创建进程标准做法，父子进程共享代码段，但拥有独立数据、堆栈段；vfork是轻量级进程创建方法，父子进程共享代码、数据和堆栈段，子进程运行期间父进程是睡眠的，当子进程结束后父进程才继续运行；clone则提供了更灵活的进程创建方式，可以通过clone_flags来控制创建过程，libpthread库提供的相关API即是通过clone系统调用实现的。大家可以在网上找一些这三种方式的示例代码，动手实验一下以加深理解。到了内核态，这三个系统调用最终都通过do_fork函数来实现其核心功能：

```
三段代码的简单实现
```



#### **零号进程与一号进程**

<br>
转载请注明：[吴斌的博客](https://rootw.github.io) » [进程管理之一：进程创建](https://rootw.github.io/2018/01/进程创建/) 
