---
layout: post
title: 内存管理之二：内存分配
date: 2017-09-02 
tags: 自顶向下分析计算机系统
---

&emsp;&emsp;本节将讨论内存分配，计算子系统相关内容目录[点此进入](https://rootw.github.io/2017/02/计算子系统/)。

### 什么是内存分配？为什么需要它？有何技术难点？

&emsp;&emsp;前文分析页异常处理时，我们看到内核会为应用程序分配内存页，而应用程序本身不直接申请内存页(只会通过malloc在堆中动态申请内存)。此外，内核在处理系统调用或中断时，也有可能需要动态申请页。Linux内核实现内存页申请的接口是alloc_pages(gfp_mask, order)，其中，gfp_mask代表申请内存的方式(隐含内存用途)，控制内存分配的行为。order代表需要的连续内存页个数的阶。接口返回的是连续内存首页对应的struct page指针。

&emsp;&emsp;通过动态分配内存页，可以提升系统对内存资源的利用率。然而，在内存不断的申请和释放过程中，可以想象的一个问题就是碎片化，即剩余内存分布在各段非连续空间内，使得较大连续内存的申请无法得到满足。因此内存分配算法的主要目标就是避免碎片化。

&emsp;&emsp;有的同学可能会问，为什么一定需要连续的物理内存呢？页表机制可以把非连续的物理页映射到连续的虚拟地址空间，这样应用程序看到的不就是连续内存了吗？的确，对于应用程序来说，对连续内存页的需求不是很强烈，但是对于某些外设(例如DMA设备)来说，它们只能看到物理页，而不存在页表转换过程，此时内核只能分配连续物理页来满足设备的内存访问需求。所以连续的物理内存在内核看来是一种稀缺资源，内存分配时需要尽可能保证剩余内存的连续性。下面我们就来看看Linux内核中内存的分配算法。

### 如何实现？- 优化型伙伴算法

&emsp;&emsp;说到内存分配算法，不得不提一提耳熟能详、在各类教科书中不断被说明的伙伴算法(buddy algorithm)。连续内存被划分成各阶大小(1,2,4,8,...)的内存段，阶数相同且左侧首页地址按阶对齐的相邻段被称为伙伴，如下图所示：

<div align="center">
<img src="/images/posts/i440fx/memory2_1.jpg" height="300" width="600">  
</div> 


&emsp;&emsp;图中所示为连续八页内存中被分配出去一页时的状态：剩余内存被分为三段，分别为一个页、两个页和四个页。

&emsp;&emsp;伙伴算法的原理为：初始时，所有连续内存按最大阶(Linux中为10，代表最大连续页为1024页)划分成段。内存分配时按阶数从小到大的顺序寻找最先能满足当前分配大小的连续段，如果找到的段的阶大于分配需要的阶，则将找到的段拆分成低阶段，例如上图表示将从一个3内存阶段中分配一个0阶内存段(即一页)的情况。内存释放时，如果发现被释放页的伙伴页段均空闲，则将两个伙伴合并从一个大的连续段并继续尝试合并新段和它的伙伴，直到无法合并为止。因此只要相邻伙伴均被释放，内存总是能被合并成更大的页段，这就是伙伴算法名称的由来。

&emsp;&emsp;伙伴算法真的完美吗？它在分配内存页时确实在努力保证剩余内存的连续，即在小段连续内存能满足当前分配的情况下绝对不会去动用大段连续内存，这就防止了因分配不当产生碎片。然而，它却无法避免因连续分配和释放而产生的碎片，因为只有当相邻两个伙伴均空闲时才能进行合并，这意味着一个伙伴的占用将阻止内存合并的发生。

&emsp;&emsp;因伙伴页被长期占用而导致的碎片问题的确比分配产生的碎片要难处理得多。这不由让人联想到磁盘的“碎片整理”功能，也就是通过移动正在使用的空间来保证剩余空间的连续。那么我们是否可以将类似思路应用到内存管理中呢？

&emsp;&emsp;通过观察我们可以发现使用中的内存页也具有一定的移动性：对于分配给应用程序使用的页是可以移动的(movable)，因为通过页表的重映射可以在应用不感知的前提下实现页变换；对于分配给内核自身使用的页是不可移动的(unmovable)，因为内核以直接映射的方式访问该页；对于未被映射给应用的缓存页是可回收的(reclaimable)，因为回刷缓存后缓存页可直接释放。如果我们将不可移动或回收的页限定在一定的范围内，就可以保证剩余范围内的页是可移动的，那么我们就可以在剩余范围内通过移动内存页来实现“碎片整理”。Linux内核就是基于上述思路，将伙伴算法中的各阶空闲内存细分成不可移动、可回收和可移动三大类，分配时通过gfp_mask标志来控制从哪类内存中分配空间。对于可移动内存页，内核在内存不足时会进行内存搬迁来尝试形成更大的连续内存。上述算法即是优化型伙伴算法。

&emsp;&emsp;下面我们结合代码来深入理解优化型伙伴算法。
xxx
numa数据结构

&emsp;&emsp;内存分配有一个快速分配流程和一个慢速分配流程，采用先快后慢的思路。快速分配根据zone内空闲内存量决定是否使用快速内存回收，如果空闲量足够的话，则直接采用优化型伙伴算法进行分配，否则先进行快速回收再尝试分配。快速分配一旦失败就会使用慢速分配的方式唤醒内存交换进程(kswapd)或触发内存压缩继续尝试分配。


<br>
转载请注明：[吴斌的博客](https://rootw.github.io) » [内存管理之二：内存分配](https://rootw.github.io/2017/09/内存分配/) 
