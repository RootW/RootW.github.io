---
layout: post
title: 内存管理之三：内存回收
date: 2017-10-01 
tags: 自顶向下分析计算机系统
---

&emsp;&emsp;本节将讨论内存回收，计算子系统相关内容目录[点此进入](https://rootw.github.io/2017/02/计算子系统/)。

### 什么是内存回收？为什么需要它？

&emsp;&emsp;内存分配过程中如果发现剩余内存量低于预定的水位线(代表内存使用紧张)，就会强制回收一部分使用频度不高的已分配内存，供后续分配使用。如此一来，好的方面是可最大限度满足系统内应用程序的内存分配请求，提升系统可用性。坏的方面是被回收页所属的应用可能再次访问该页，需要通过缺页处理再次分配映射页，从而带来应用性能的下降。一个优秀的内存回收算法需要在系统整体可用性和应用性能之间寻找合适的平衡点。

### 如何实现？

#### 1. 四大链表

&emsp;&emsp;内存回收需要思考的第一个问题是关于回收对象，即回收谁？Linux内核只能回收动态分配给应用程序的内存页，内核自身直接分配使用的页是不参与回收的(通过slab分配的内存可回收，这里我们不做深入讨论)。应用程序使用的内存页要么是通过文件映射的(如代码段)，要么是匿名映射的(如堆栈段)。因此内核将分配给应用程序的内存页分为两大类，即文件页和匿名页；同时根据内存页使用的频度又分为活跃页和不活跃
页。这样，内核将已分配页放到四个LRU链表中：非活跃匿名页链表、活跃匿名页链表、非活跃文件页链表、活跃文件页链表。触发内存回收后，内核会将活跃页链表中使用频度低的页淘汰到非活跃页链表中，再从非活跃页链表中取出频度低的页直接回收。四大链表结构定义如下：
xxx

&emsp;&emsp;了解四大链表结构后，可以思考内核是如何感知内存页的活跃程度的？内核是通过mark_page_accessed函数显式标记页的活跃程度。初始分配的匿名页被放置到活跃链表中，而文件页被放置到非活跃链表中，并由内核在后续操作过程中显式标记活跃程度：连续两次被访问后，该页将被移动到活跃页链表中。相关函数如下:
xxx

#### 2. 整体流程

&emsp;&emsp;以下调用流程以页分配为出发点来跟踪内存回收shrink_zone：get_scan_count计算各个链表的回收比例，然后再通过shrink_list依次回收。下面我们进一步展开。

```
alloc_pages
    ->get_page_from_freelist
        ->zone_reclaim
            ->shrink_zone
                ->shrink_lruvec
                    ->get_scan_count
                    ->shrink_list
```

#### 2.1 回收比例

&emsp;&emsp;内存回收时有四大链表供选择，每次回收时都需要扫描所有链表吗？不是这样的，内核通过get_scan_count计算每个链表的扫描比例，比例越高回收的页可能就越多。这个函数详细的代码就不分析了，有点复杂，我们只需要知道最终nr数组会记录每个链表的扫描页数。

#### 2.2 活跃链表回收

&emsp;&emsp;通过shrink_list的代码：
xxxx

&emsp;&emsp;我们可以清楚看到，针对活跃链表，如果非活跃页偏少则通过shrink_active_list将部分活跃页移动到非活跃页中，此时并不进行回收动作。代码分析如下：
xxxx
page_referenced用来测试当前页是否被访问，通过页表的Access位来实现，同时涉及反向映射(rmap)，后续专题讨论。

#### 2.3 非活跃链表回收

&emsp;&emsp;非活跃链表中的页是重点回收对象，核心功能在shrink_page_list函数中实现。该函数对非活跃链表尾部的若干页依次进行扫描：首先对当前扫描页加锁，避免扫描期间同时存在其它页操作；接着通过writeback标记判断当前扫描页是否正在被回写，如果是则跳过当前页去扫描下一页；接着判断当前页是否被访问过，如果页表的accessed位被置位则说明页被访问过，清除标记后任跳过当前页；页未被访问情况下，为匿名页添加交换分区映射(文件页必然有文件与之相应)，之后正式解除当前扫描页的页表映射；页表映射解除成功后，开始回刷脏页，待脏页回刷完成后最后将当前页从文件缓存映射或匿名映射中移除，之后便可释放当前页。
<br>
转载请注明：[吴斌的博客](https://rootw.github.io) » [内存管理之三：内存回收](https://rootw.github.io/2017/10/内存回收/) 
