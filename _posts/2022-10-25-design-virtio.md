---
layout: post
title: 自顶向下设计与实现Virtio
date: 2022-10-25
tags: virtio
---

### 什么是Virtio？为什么需要Virtio？

&emsp;&emsp;Virtio看字面是由Virt(Virtualization)和IO(Input/Output)两部分组成，含义是虚拟化环境下使用的IO协议/设备。早期在虚拟化技术的实现过程中，为了重用现有的设备驱动，虚拟化设备模拟软件一般都是模拟已有物理设备的行为(遵循物理IO协议)，比如通过模拟IDE硬盘可以在虚拟机中完全重用IDE驱动。但是这里引发一个问题，模拟已有的物理设备行为往往导致虚拟化软件性能较低，比如IDE硬件是通过端口(Port)进行数据输入输出的，一段连续的数据需要大量端口操作才能完成。那么有没有可能引入一种新的协议标准，这种协议标准虽然在物理设备中是不存在的，但是可以提升虚拟化场景下设备对数据的输入/输出性能，并且具备一定的通用性，也就是说磁盘、网卡、显卡、键盘、鼠标等等设备都可以使用。

&emsp;&emsp;因此Virtio是在虚拟化场景中引入的一种高性能、通用IO协议，它可以让CPU批量地向设备发送请求(Request)和输出数据(Output)，当设备处理完成请求后，也可以让设备批量地向CPU通知结果(Response)和输入数据(Input)。

<div align="center">                                                             
    <img src="/images/posts/virtio/top.png" height="247" width="180">  
</div>

### 如何逐步实现Virtio？

&emsp;&emsp;从逻辑视角上分析，Virtio顶层所定义的CPU和设备之间批量请求、结果和数据的传输功能是非常基础的能力，无须进一步展开。我们可以在生活中找到非常多类似的例子，比如项目经理通过电话或邮件向项目成员发送了一系列任务，项目成员完成任务后，又通过电话或邮件向项目经理知会完成情况。那么实现Virtio重点就是从物理视角进行展开。

&emsp;&emsp;从物理视角展开分析之前，我们先要了解CPU与设备之间的通信是建立的总线协议之上的，其作用这就好比上面例子中的电话或邮件。以PCI标准总线为例，通过PCI桥可以将设备中的寄存器或存储器映射到CPU可见的内存地址空间中，CPU通过执行对这些地址空间的内存读/写指令就可以完成对设备中寄存器的读/写操作(内存读/写指令会由PCI桥完成，PCI桥根据访存地址决定是发送给物理内存，还是通过PCI总线发送给设备)；反过来，设备也可以通过PCI总线访问物理内存(DMA)或者发送中断通知给CPU(MSI/MSIX)。除了PCI总线，Virtio协议也可以构建在其它总线类型上(如MMIO总线)，它们的作用都是类似的，就是让CPU可以操作设备寄存器、让设备可以操作系统内存并通知CPU有事件发生。

&emsp;&emsp;理解PCI总线机制后，我们就可以设计出物理视角上的项层IO处理流程，这里以单个IO进行示意：

<div align="center">                                                             
    <img src="/images/posts/virtio/IO.png" height="536" width="488">  
</div>

&emsp;&emsp;对于一个IO请求，其完成过程需要经历以下几步：
>* CPU将IO请求放入内存请求队列中(请求队列就是存放请求的地方，这样可以批量、异步地发送请求)；
>* CPU通过写设备中特定的寄存器唤醒设备并通知它有IO请求待处理；
>* 设备被唤醒后通过DMA操作从内存请求队列中取出IO请求；
>* 设备将IO请求交给内部核心处理逻辑进行处理，比如交给块设备(Blk)通过DMA进行数据存取或者网络设备(Net)进行数据收发；
>* 设备处理完成后将IO响应放入内存响应队列；
>* 设备以中断方式通知CPU有IO响应待处理(表示IO请求处理结果)；
>* CPU在中断上下文中对IO响应进行处理，并最终告知应用程序IO处理结果。

&emsp;&emsp;这里有一个设计选择问题就是请求队列和响应队列为什么要放在系统物理内存中？从实现上说，请求队列和响应队列也可以放到设备的寄存器或存储单元中，这样CPU在放入请求或者设备在放入响应时，就可以一步到位，不用通过内存作为中转。实际上，当放入请求动作对应的数据写入量不大的时候，的确可以提升放入请求动作的性能，但此时CPU是处于Stall状态直到写入操作完成。那么当放入动作对应的数据写入量较大时，CPU就会长时间处于Stall状态，导致CPU计算效率变低。所以Virtio协议在设计时选择将队列置于系统内存中而不是直接放在设备中，而有些协议(如NVMe)选择同时支持两种方式。

&emsp;&emsp;从顶层IO处理流程上看，CPU和设备都是基于内存进行读写操作从而完成请求和响应的传递，那么我们该如何设计内存中队列的数据结构？这是Virtio协议设计中最为关键的展开环节。

&emsp;&emsp;首先，既然是队列，最合适的数据结构是数组，那么数组元素该如何设计？数组元素代表的是每个IO请求、数据或者IO响应，而对于不同类型的设备(磁盘、网卡等等)，请求、数据或响应的内部结构又是不相同的。我们可以观察到无论什么样的请求、数据或响应，从结构本质上看，都是由一段或几段连续内存组成的，每段连续内存由起始地址和长度两个要素决定。这样我们就可以设计一个数组，数组中的元素包含两个成员：起始地址和长度，每个IO可以对应若干数组元素。

&emsp;&emsp;为了重复使用队列内存空间，通常会以环形方式使用数组元素，即已经处理完成的IO对应的数组元素可以用来存放新的IO。但是IO完成的顺序和IO放入的顺序并不完全一致，先取出的IO可能最后才完成，且每个IO对应的元素个数也不相同，这就导致空闲的数组元素并不完全连续。一个可行的解决思路就是采用链表结构来链接各个元素，元素在数组中的位置可以不连续。除了链表，还有没有其它解决思路？如果每个IO就对应一个数组元素，不连续也没啥问题，那就不用链表了，这个思路在Virtio中对应的就是Indirect特性，这里暂不展开分析。

&emsp;&emsp;这样我们就有了一个基本的数组结构，用来表示每个IO对应的请求、数据和响应，这就是Virtio中的Descriptor Table，如下所示(flag的作用后续说明)：

<div align="center">                                                             
    <img src="/images/posts/virtio/descriptor.png" height="430" width="608">  
</div>


<br>
转载请注明：[吴斌的博客](https://rootw.github.io) » [自顶向下设计与实现Virtio](https://rootw.github.io/2022/10/design-virtio/) 