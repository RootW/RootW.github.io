---
layout: post
title: 【计算子系统】CPU与内存
date: 2017-02-11
tags: 自顶向下分析计算机系统(基于Linux内核)
---

### 什么是CPU与内存？

&emsp;&emsp;CPU与内存是计算机中的核心子系统，在老式的单任务系统中，CPU内部的指令指针(Instruction Pointer)或程序计数(Programm Counter)寄存器不断地发生变化，同时内存中的数据段也跟着发生变化，并且该变化与指令指针所指向的内存代码段内容(指令)存在确定性对应关系。因此，从功能上看，CPU是在指令的控制下，完成对数据的读取、计算和回写功能，并通过控制转移指令形成顺序、分支、循环与函数调用等组合结构，即代码段。单任务系统逻辑结构如下图所示：

<div align="center">                                                             
    <img src="/images/posts/i440fx/CPU_single.jpg" height="190" width="250">  
</div>

&emsp;&emsp;现代计算机是多任务系统，即一个CPU上可执行多个任务(不过，同一时刻同一CPU上只能执行一个任务)，如下图所示。从多任务的视角看，一个CPU总是处于任务上下文或者中断上下文：

* CPU处于任务上下文时，同一时刻只能执行一个任务，此时对任务代码的执行类似单任务系统；与单任务系统不同的是，CPU内集成了一个内存管理单元(MMU,Memory Management Unit)，CPU上任务访问的内存都是虚拟内存(Virtual Memory)，MMU负责将虚拟内存转换成物理内存；另一个和单任务不同的是，系统内存中驻留一段被称为内存(kernel)的程序，它被所有任务所共享，每个任务需要访问系统全局资源(如文件系统或网络接口)时，都需要通过系统调用执行内存程序来完成。

* CPU接收到外部中断或发生内部异常时便处于中断上下文，此时CPU将执行内核程序对中断或异常进行处理：我们常见的外部中断有时钟中断和外部设备中断，通过对时钟中断的处理，CPU可以执行对任务的调度和切换，而通过对外部中断的处理，CPU可以获知外部设备对请求的处理结果；常见的异常主要是缺页异常，当CPU中的MMU通过页表进行虚拟到物理地址转换时，如果发现页表中没有对应的项或者访问权限不足时，CPU就会触发缺页异常。该异常发生后CPU会调用内核程序中的缺页处理功能进行相应的处理。

<div align="center">                                                                
    <img src="/images/posts/i440fx/CPU_multitask.jpg" height="410" width="410">     
</div>

&emsp;&emsp;因此，CPU与内存的核心功能是为任务的执行提供硬件环境，而多任务并行化的需求，大大增加了系统的复杂性。CPU通过MMU实现内存虚拟化功能，使得不同任务可以使用相同的虚拟地址空间范围。CPU与内存中增加了独立内核程序，由它完成内存管理、进程管理、设备与中断管理、文件系统和网络协议栈等多种系统功能。理解计算机系统便需要深入理解内核程序。

### 如何深入理解CPU与内存？

&emsp;&emsp;我们可以从时间和空间两个维度来深入分析CPU与内存系统：从时间维度深入看，对于各种应用程序以及内核程序都可以通过源代码层层分析它是实现原理，顶层代码重在逻辑和功能，底层代码重在过程。顶层代码一般用C之类的高级语言，底层代码用汇编。从空间维度深入看，我们便需要剖析CPU内部体系结构，如指令流水、缓存架构等等。

&emsp;&emsp;本系列博文将从时间维度深入展开内核程序的执行过程和实现原理，这里针对X86_64架构对CPU基本执行环境作个介绍，如下所示：

<div align="center">                                                             
    <img src="/images/posts/i440fx/CPU_x86_64.jpg" height="730" width="590">  
</div> 

>* Address Space，任务可见的虚拟地址空间，最大2^64字节，实际映射的物理内存地址在Intel Xeon CPU中通常最大为2^46，可通常CPUID指令查询；
>* Basic Program Execution Registers，任务执行时使用的基础寄存器，包含16个64位通用寄存器(General Purpose Registers，RAX~RDX、RBP、RSP、RDI、RSI、R8~R15)，标志寄存器(RFLAGS)，6个16位段寄存器(cs、ds、ss、es、fs、gs)，指令指针寄存器(RIP)；
>* Controll Registers，系统控制寄存器(CR0、CR2、CR3)；
>* Descriptor Table Registers，描述符表寄存器(GDTR、IDTR、LDTR、TR)；
>* FPU Registers，浮点寄存器，与浮点运算相关；
>* MMX and XMM Registers，与SIMD指令相关；

<br>
转载请注明：[吴斌的博客](https://rootw.github.io) » [【计算子系统】开篇与目录](https://rootw.github.io/2017/02/计算子系统/) 
