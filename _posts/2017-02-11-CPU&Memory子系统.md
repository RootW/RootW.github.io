---
layout: post
title: CPU&Memory子系统(1)-开篇
date: 2017-02-11
tags: 自顶向下分析计算机系统 CPU&Memory子系统
---

&emsp;&emsp;正如前篇介绍通用计算机系统的博文中所述，CPU&Memory子系统是整个计算系统的核心，因此从本篇博文起将对该核心系统进行一系列深入分析。

### 什么是CPU&Memory子系统？

&emsp;&emsp;在前篇对通用计算机系统的内部实现进行简要说明时，我们看到过CPU&Memory子系统。在单核架构下，内存是负责存储程序(指令的集合)和数据的部件，CPU则根据程序对数据进行读取、运算和写回，并对外部设备进行控制，通过编写程序来控制CPU实现具体功能。在多核架构下，系统变得复杂了：内存被多个进程共享，每个进程仍然包含指令和数据两个部分，并且每个进程都认为自己独占了整个内存地址空间，相互之间并不直接感知，由执行的CPU进行内存地址的转换；每个CPU在同一时刻只能执行一个进程，并通过进程进行数据的计算和外设控制等核心功能，此外CPU还需要负责进程的创建、替换、终止、调度、通信(间接感知)等一系列动作，下图是多核架构下CPU&Memory的状态示意图，需要补充说明的是进程内存空间分为用户空间和内核空间两部分(图中未画出)，每个部分均包含代码和数据两个部分，用户空间是进程独立的，用来实现各自独特的功能，但内核空间是所有进程共享的，用来实现全局性的或系统性的功能。

<div align="center">
    <img src="/images/posts/i440fx/cpu.jpg" height="400" width="500">  
</div> 

### 为什么需要CPU&Memory子系统？

&emsp;&emsp;CPU&Memory子系统是计算机内部最为复杂的系统，如上一部分所述，它包含了内存地址转换、进程执行(完成数据计算、外设控制等核心功能，以及系统调用切换等系统过程)、进程管理(创建、替换、终止、调度、通信)、中断处理等一系列过程。后续博文将分篇对这些过程进行介绍(针对CPU&Memory子系统的每一个子过程也可以采用自顶向下思路进行分析)。这里我们仅做一些笼统的说明：CPU&Memory为整个计算机提供了一个多任务并行执行的硬件环境，每个任务可完成由计算、存储、网络组合而成的复杂功能，是对客户操作的直接响应者；同时，任务间的隔离性，也为应用程序的开发提供了便利，程序员不用考虑内存布局等底层细节，从而更有利于系统的扩展性。

### 如何实现CPU&Memory子系统？

&emsp;&emsp;后续我们将以x86_64架构下的linux 3.10为例对各个系统过程进行深入分析，这里我们对涉及CPU内部寄存器及内存布局设计的公共部分进行说明，典型内部状态如下图所示：

<div align="center">
    <img src="/images/posts/i440fx/cpu_low_level.jpg" height="550" width="400">  
</div> 

&emsp;&emsp;

<br>
转载请注明：[吴斌的博客](https://rootw.github.io) » [CPU&Memory子系统(1)-开篇](https://rootw.github.io/2017/02/CPU&Memory子系统/) 
