---
layout: post
title: 【Rados Block Device】OSD原理分析－OSD模块
date: 2018-04-11 
tags: ceph
---

&emsp;&emsp;OSD进程从网络收到客户端的读写请求后，交由OSD模块执行核心的请求处理逻辑，本篇博文将讨论OSD模块的实现原理。

### OSD模块中对象、流程概览

&emsp;&emsp;我们先整体来看一下OSD模块的对象和流程：

<div align="center">
<img src="/images/posts/ceph/rbd_osd_osd.jpg" height="500" width="800">  
</div> 

&emsp;&emsp;回顾前文对SimpleMessenger的分析，我们看到ms_pipe_read线程从网络中收到请求消息后，通过fast_dispatch接口将消息分发给OSD对象进行处理。OSD对象针对接收到的每一个消息，都会将它们放入一个工作队列中(ShardedOpWQ，片式队列)。到这里，ms_pipe_read线程的分发动作就执行完了。对于一个片式队列，会有若干个处理线程，即图中的tp_osd_tp线程，每个处理线程负责处理不同分片中的消息。它们将各自分片中的消息取出后，找到每个消息对应的PG对象(Placement Group)，进而将消息封装成操作(op)转给PG对象处理。PG对象针对读操作将直接从filestore中读出内容并返回响应消息给客户端；而对于写操作，PG对象将请求以事务(Transaction)的方式提交给PGBackend对象(本文主要讨论ReplicatedBackend)，最终事务内的操作会转变成对filestore的操作(我们将在独立的博文中讨论filestore模块的实现原理)。

&emsp;&emsp;为什么一个请求消息要在两个线程(ms_pipe_read和tp_osd_tp)间传递处理？其实这里体现了ceph一个核心的设计理念：流水线。将请求的处理分成多个步骤，每个步骤放在不同的线程中处理；请求从一个线程流动到下一个线程，类似工产里的流水流；这样可以大大提升处理请求的吞吐量(即每秒完成的请求数量)。那么时延呢？

### OSD模块中类的概览

&emsp;&emsp;下面我们来看看OSD模块中涉及的主要类及其关系：

<div align="center">
<img src="/images/posts/ceph/rbd_osd_osd_class.jpg" height="500" width="800">  
</div> 

&emsp;&emsp;

>* OSD是核心类，它内部包含两个Messenger对象指针，分别指向cluster网络(cluster_messenger)和public网络(client_messenger)。store指向后端对象存储池，用来进行实际的对象存取操作。内部包含一个片式队列(ShardedOpWQ)和一个处理线程池(SharedThreadPool)，OSD对象将请求消息放入片式队列中，再由不同的处理线程从队列中取出消息进行下一步处理。OSD中还包含全局的OSDMap和映射到本OSD的所有PG对象。
>* ShardedOpWQ类代表片式队列，number_shards是队列中总的分片数，每个分片都包含一个ShardedData，其内部有一个优先级队列用来接收请求消息(通过_enqueue操作)。每个片式队列都关联一个处理线程池，池中的每个线程都通过_process接口从对应队列中取出消息进行后续处理。
>* PrimaryLogPG类继承PG类，代表具体的Placement Group的一种实现。每个PrimaryLogPG对象包含一个pgbackend对象，该对象负责数据复本的处理。目前有两种数据复本的实现方式，Replicated(复制)和EC(校验码)，分别对应ReplicatedBackend和ECBackend。

### 代码详解

&emsp;&emsp;

#### **1. 初始化过程**

&emsp;&emsp;

```
ceph_osd.cc:main()
    |-Messenger::create()
    |   \-SimpleMessenger::SimpleMessenger()
    |-Messenger::bind() -> SimpleMessenger::bind()
    |   \-Accepter::bind()
    |       |-::socket()
    |       |-::bind()
    |       \-::listen()
    |-OSD::OSD()
    |-Messenger::start() -> SimpleMessenger::start()
    |-OSD::init()
    |   \-Messenger::add_dispatcher_head()
    |       \-Messenger::ready() -> SimpleMessenger::ready()
    |           \-Accepter::start()
    \-Messenger::wait() -> SimpleMessenger::wait()
    
```

&emsp;&emsp;我们先来看

#### **2. 连接建立过程**

&emsp;&emsp;SimpleMessen

#### **3. 消息接收与分发过程**

&emsp;&emsp;每个pipe
&emsp;&emsp;消息的快速处理流程可以回头参考前文的对象、流程图。

#### **4. 消息发送过程**

&emsp;&emsp;任何
<br>
转载请注明：[吴斌的博客](https://rootw.github.io) » [【Rados Block Device】OSD原理分析－OSD模块](https://rootw.github.io/2018/04/RBD-OSD-2) 
