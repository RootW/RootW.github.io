---
layout: post
title: 【时间子系统】计时原理－timekeeper与clocksource
date: 2018-01-25 
tags: 自顶向下分析计算机系统(基于Linux内核)
---

&emsp;&emsp;本篇博文我们将深入分析一下内核是如何使用计时硬件对应用提供服务的。

### 内核表示时间数据结构

&emsp;&emsp;内核中对时间的表示有多种形式，可以使用在不同的应用场景。我们在时间概述中看到的gettimeofday的示例中，采用的数据结构是struct timeval，它的定义如下：

```
linux/include/uapi/linux/time.h:

struct timeval {
    __kernel_time_t         tv_sec;     /* seconds */
    __kernel_suseconds_t    tv_usec;    /* microseconds */
};
```
&emsp;&emsp;从上面的定义中，我们可以看到struct timeval记录了当前时间的秒数和毫秒数，精度就是毫秒。那么这里的秒数和毫秒数是相对哪个时间点(epoch)而言的呢？按照UNIX系统的习惯，记录时间的秒数和毫秒数是相对1970年1月1日00:00:00 +0000(UTC)而言的。另外，记录秒数的__kernel_time_t和记录毫秒的__kernel_suseconds_t在64位系统中都是long型的。

&emsp;&emsp;除了struct timeval，内核中还定义了精度更高的struct timespec，它的精度是纳秒：

```
linux/include/uapi/linux/time.h:

struct timespec {
    __kernel_time_t tv_sec;     /* seconds */
    long            tv_nsec;    /* nanoseconds */
};
```

&emsp;&emsp;此外，为了兼容各种系统架构，内核也定义了ktime_t类型，在64位机器中对应long，时间表示单位是纳秒：

```
linux/include/linux/ktime.h:

union ktime {
    s64	tv64;
#if BITS_PER_LONG != 64 && !defined(CONFIG_KTIME_SCALAR)
    struct {
#ifdef __BIG_ENDIAN
        s32	sec, nsec;
#else
        s32	nsec, sec;
#endif
    } tv;
#endif
};

typedef union ktime ktime_t;
```

### 内核时间类别

&emsp;&emsp;时间概述中示例程序使用的gettimeofday将返回实时间(real time，或叫墙上时间wall time)，代表现实生活中使用的时间。除了墙上时间，内核也提供了线性时间(monotonic time，它不可调整，随系统运行线性增加，但不包括休眠时间)、启动时间(boot time，它也不可调整，并包括了休眠时间)等多种时间类型，以使应用在不同场景(获取不同类型时间的用户态方法是clock_gettime)，下表汇总了各类时间的要素点：

|时间类别|精度|可手动调整|受NTP调整影响|时间起点|受闰秒影响|系统暂停时是否可工作|
|-|-|-|-|-|-|-|
|REALTIME|ns|YES|YES|Linux epoch|YES|NO|
|MONOTONIC|ns|NO|YES|Linux epoch|YES|NO|
|MONOTONIC_RAW|ns|NO|NO|Linux epoch|YES|NO|
|REALTIME_COARSE|tick|YES|YES|Linux epoch|YES|NO|
|MONOTONIC_COARSE|tick|NO|YES|Linux epoch|YES|NO|
|BOOTTIME|ns|NO|YES|machine start|YES|NO|
|REALTIME_ALARM|ns|YES|YES|Linux epoch|YES|YES|
|BOOTTIME_ALARM|ns|NO|YES|machine start|YES|YES|
|TAI|ns|NO|NO|Linux epoch|NO|NO|

&emsp;&emsp;关于闰秒，我们需要先理解什么是原子秒？原子秒提出的背景是人们对于"秒"的精确定义追求。多长时间可以算作1秒？这是一个很难准确回答的问题。但是后来科学家发现铯133原子在能量跃迁时辐射的电磁波振荡频率非常稳定，因此就被用来定义时间的基本单位：秒，即原子秒。通过原子秒延展出来的时间轴就是TAI(International Atomic Time)。原子时间虽然精准，但是对人类来说不太友好，它和传统的地球自转和公转的周期性自然现象存在时间差。在这样的背景下，UTC(Coordinated Universal Time)被提出。它使用原子秒作为计时单位，但又会适当调整以适应人们的日常生活。这个调整的时间差就是闰秒。TAI和UTC在1972进行了校准，两者相差10秒，从此后到2017年，又调整了27次，因此TAI比UTC快了37秒。

### 深入do_gettimeofday

### 计时初始化

&emsp;&emsp;后续

<br>
转载请注明：[吴斌的博客](https://rootw.github.io) » [【时间子系统】计时原理－timekeeper与clocksource](https://rootw.github.io/2018/01/计时/) 
