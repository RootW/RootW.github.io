I"ßG<p>â€ƒâ€ƒé€šè¿‡å¯¹ä½ç²¾åº¦å®šæ—¶å™¨çš„åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“è¿™ç±»å®šæ—¶å™¨çš„ç²¾åº¦æ˜¯æ¯«ç§’çº§çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å­˜åœ¨æ¯«ç§’çº§çš„è¯¯å·®èŒƒå›´ã€‚å¯¹äºåƒIOè¶…æ—¶é”™è¯¯å¤„ç†è¿™ç±»å®šæ—¶ä»»åŠ¡ï¼Œæ¯«ç§’çº§çš„è¯¯å·®å®Œå…¨ä¸ç®—ä»€ä¹ˆé—®é¢˜ã€‚ç„¶è€Œï¼Œå¯¹äºå·¥ä¸šä¸Šçš„è®¸å¤šå®æ—¶ä»»åŠ¡ï¼Œæ¯«ç§’çº§çš„è¯¯å·®æ˜¯å®Œå…¨ä¸å¯æ¥å—çš„ã€‚å› æ­¤ï¼ŒåŸºäºæ›´é«˜ç²¾åº¦çš„æ—¶é—´ç¡¬ä»¶(ä¾‹å¦‚TSCå’ŒLAPIC Timer)ï¼Œå†…æ ¸å·¥ç¨‹å¸ˆä»¬å¼€å‘äº†ä¸€å¥—å…¨æ–°çš„é«˜ç²¾åº¦å®šæ—¶å™¨åŠŸèƒ½(ä¼ ç»ŸåŸºäºæ—¶é—´è½®çš„ä½ç²¾åº¦å®šæ—¶å™¨å·²ç»å¾ˆç¨³å®šäº†ï¼Œä¸å…¶å¯¹å®ƒä¿®ä¿®è¡¥è¡¥ï¼Œè¿˜ä¸å¦‚æ–°å»ºä¸€å¥—å…¨æ–°çš„æœºåˆ¶)ã€‚</p>

<h3 id="1-é«˜ç²¾åº¦å®šæ—¶å™¨çš„åˆå§‹åŒ–">1. é«˜ç²¾åº¦å®šæ—¶å™¨çš„åˆå§‹åŒ–</h3>

<p>â€ƒâ€ƒé«˜ç²¾åº¦å®šæ—¶å™¨çš„åˆå§‹åŒ–å’Œä½ç²¾åº¦å®šæ—¶å™¨çš„åˆå§‹åŒ–æœ‰äº›ç±»ä¼¼ï¼Œéœ€è¦æŒ‡å®šåˆ°æœŸåçš„å›è°ƒå‡½æ•°ã€‚ç„¶è€Œåœ¨å†…éƒ¨æ•°æ®ç»“æ„çš„è®¾è®¡ä¸Šï¼Œä¸åŒäºä½ç²¾åº¦å®šæ—¶å™¨çš„æ—¶é—´è½®ï¼Œé«˜ç²¾åº¦å®šæ—¶å™¨é‡‡ç”¨äº†çº¢é»‘æ ‘(å¯ä»¥é«˜æ•ˆåœ°å®ç°æ’åºã€å¢åˆ æ”¹ç­‰æ“ä½œï¼Œå†…æ ¸ä¸­æœ‰æ¯”è¾ƒæˆç†Ÿç¨³å®šçš„ä»£ç å®ç°)ã€‚å¦å¤–ï¼Œä½ç²¾åº¦å®šæ—¶å™¨çš„è®¡æ—¶å‚ç…§æ˜¯jiffiesï¼Œè€Œé«˜ç²¾åº¦å®šæ—¶å™¨å¯ä»¥é‡‡ç”¨timekeeperä¸­çš„å¤šç§è®¡æ—¶å‚ç…§ï¼Œå¦‚REAL TIMEã€MONOTONIC TIMEç­‰ç­‰ã€‚ä»£ç å®ç°å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/hrtimer.c:

/**
 * hrtimer_init - initialize a timer to the given clock
 * @timer:	the timer to be initialized
 * @clock_id:	the clock to be used
 * @mode:	timer mode abs/rel
 */
void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,
    enum hrtimer_mode mode)
{
    debug_init(timer, clock_id, mode);
    __hrtimer_init(timer, clock_id, mode);
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/hrtimer.h:

/**
 * struct hrtimer - the basic hrtimer structure
 * @node:   timerqueue node, which also manages node.expires,
 *          the absolute expiry time in the hrtimers internal
 *          representation. The time is related to the clock on
 *          which the timer is based. Is setup by adding
 *          slack to the _softexpires value. For non range timers
 *          identical to _softexpires.
 * @_softexpires: the absolute earliest expiry time of the hrtimer.
 *          The time which was given as expiry time when the timer
 *          was armed.
 * @function:   timer expiry callback function
 * @base:   pointer to the timer base (per cpu and per clock)
 * @state:  state information (See bit values above)
 *
 * The hrtimer structure must be initialized by hrtimer_init()
 */
struct hrtimer {
    struct timerqueue_node      node;
    ktime_t                     _softexpires;
    enum hrtimer_restart        (*function)(struct hrtimer *);
    struct hrtimer_clock_base   *base;
    unsigned long               state;
    ...
};

enum hrtimer_mode {
    HRTIMER_MODE_ABS = 0x0,		/* Time value is absolute */
    HRTIMER_MODE_REL = 0x1,		/* Time value is relative to now */
    HRTIMER_MODE_PINNED = 0x02,	/* Timer is bound to CPU */
    HRTIMER_MODE_ABS_PINNED = 0x02,
    HRTIMER_MODE_REL_PINNED = 0x03,
};
</code></pre></div></div>

<p>â€ƒâ€ƒé€šè¿‡ä¸Šé¢çš„ä»£ç å’Œæ³¨é‡Šï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œé«˜ç²¾åº¦å®šæ—¶å™¨åˆå§‹åŒ–æ—¶å¯ä»¥æŒ‡å®šè®¡æ—¶å‚ç…§å¯¹è±¡(clock_id)å’Œè®¡æ—¶æ¨¡å¼(é‡‡ç”¨ç»å¯¹è®¡æ—¶æˆ–ç›¸å¯¹è®¡æ—¶)ã€‚é«˜ç²¾åº¦å®šæ—¶å™¨å†…éƒ¨ç»“æ„ä¸­çš„nodeå³æ˜¯åœ¨çº¢é»‘æ ‘ä¸­çš„æŒ‚æ¥å¯¹è±¡ï¼ŒbaseæŒ‡å‘æ¯ä¸ªCPUé’ˆå¯¹ä¸åŒè®¡æ—¶å‚ç…§å¯¹è±¡çš„å…¨å±€æ•°æ®ç»“æ„ï¼Œå…¶å†…éƒ¨åŒ…å«ä¸€æ£µçº¢é»‘æ ‘ã€‚__hrtimer_initçš„å…·ä½“å®ç°æ¯”è¾ƒç®€å•ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/hrtimer.c:

static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,
    enum hrtimer_mode mode)
{
    struct hrtimer_cpu_base *cpu_base;
    int base;

    memset(timer, 0, sizeof(struct hrtimer));

    cpu_base = &amp;__raw_get_cpu_var(hrtimer_bases); /*è·å–å½“å‰CPUçš„hrtimer_cpu_baseå¯¹è±¡*/

    if (clock_id == CLOCK_REALTIME &amp;&amp; mode != HRTIMER_MODE_ABS) /*REALTIMEåªæ”¯æŒç»å¯¹æ¨¡å¼*/
        clock_id = CLOCK_MONOTONIC;

    base = hrtimer_clockid_to_base(clock_id); /*ç´¢å¼•è®¡æ—¶å‚ç…§*/
    timer-&gt;base = &amp;cpu_base-&gt;clock_base[base];
    timerqueue_init(&amp;timer-&gt;node); /*åˆå§‹åŒ–çº¢é»‘æ ‘èŠ‚ç‚¹*/

    ...
}
</code></pre></div></div>

<h3 id="2-é«˜ç²¾åº¦å®šæ—¶å™¨çš„å¯åŠ¨">2. é«˜ç²¾åº¦å®šæ—¶å™¨çš„å¯åŠ¨</h3>

<p>â€ƒâ€ƒåˆå§‹åŒ–å®Œæˆå¹¶æŒ‡å®šå›è°ƒå¤„ç†å‡½æ•°åï¼Œæˆ‘ä»¬é€šè¿‡hrtimer_startå‡½æ•°å¯ä»¥å¯åŠ¨ä¸€ä¸ªå®šæ—¶å™¨ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/hrtimer.c:

/**
 * hrtimer_start - (re)start an hrtimer on the current CPU
 * @timer:  the timer to be added
 * @tim:    expiry time
 * @mode:   expiry mode: absolute (HRTIMER_MODE_ABS) or
 *          relative (HRTIMER_MODE_REL)
 *
 * Returns:
 *  0 on success
 *  1 when the timer was active
 */
int hrtimer_start(struct hrtimer *timer, ktime_t tim, const enum hrtimer_mode mode)
{
    return __hrtimer_start_range_ns(timer, tim, 0, mode, 1);
}
</code></pre></div></div>

<p>â€ƒâ€ƒé«˜ç²¾åº¦å®šæ—¶å™¨å…è®¸æœ‰ä¸€ä¸ªçº³ç§’çº§åˆ«çš„è¯¯å·®ï¼Œç”±__hrtimer_start_range_nsçš„delta_nså‚æ•°æŒ‡æ˜ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/hrtimer.c:

int __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,
    unsigned long delta_ns, const enum hrtimer_mode mode, int wakeup)
{
    struct hrtimer_clock_base *base, *new_base;
    unsigned long flags;
    int ret, leftmost;

    base = lock_hrtimer_base(timer, &amp;flags); /*é”å®šè¯¥timerå¯¹åº”çš„hrtimer_clock_baseå¯¹è±¡*/

    /* Remove an active timer from the queue: */
    ret = remove_hrtimer(timer, base);

    if (mode &amp; HRTIMER_MODE_REL) {
        tim = ktime_add_safe(tim, base-&gt;get_time());
        ...
    }

    hrtimer_set_expires_range_ns(timer, tim, delta_ns); /*è®¾ç½®å®šæ—¶å™¨å†…éƒ¨çš„è¶…æ—¶æ—¶é—´*/

    /* Switch the timer base, if necessary: */
    new_base = switch_hrtimer_base(timer, base, mode &amp; HRTIMER_MODE_PINNED);

    leftmost = enqueue_hrtimer(timer, new_base); /*å°†å®šæ—¶å™¨åŠ å…¥åˆ°å¯¹åº”hrtimer_clock_baseçš„çº¢é»‘æ ‘ä¸­*/

    if (leftmost &amp;&amp; new_base-&gt;cpu_base == &amp;__get_cpu_var(hrtimer_bases)
        &amp;&amp; hrtimer_enqueue_reprogram(timer, new_base)) { /*å¦‚æœå½“å‰å®šæ—¶å™¨æ˜¯çº¢é»‘æ ‘ä¸­æœ€æ—©åˆ°æœŸçš„å®šæ—¶å™¨ï¼Œåˆ™é‡æ–°è®¾ç½®clock event deviceçš„oneshotè®¡æ•°ã€‚æ³¨ï¼Œé«˜ç²¾åº¦å®šæ—¶å™¨æ­£å¸¸å·¥ä½œæ—¶ï¼Œä¼šå°†clock event deviceçš„å·¥ä½œæ¨¡å¼åˆ‡æ¢åˆ°oneshot*/
        ...
    }

    unlock_hrtimer_base(timer, &amp;flags);

    return ret;
}
</code></pre></div></div>

<h3 id="3-åˆ‡æ¢åˆ°é«˜ç²¾åº¦æ¨¡å¼">3. åˆ‡æ¢åˆ°é«˜ç²¾åº¦æ¨¡å¼</h3>

<p>â€ƒâ€ƒå†…æ ¸æ­£å¸¸å¯åŠ¨åé¦–å…ˆå·¥ä½œåœ¨ä½ç²¾åº¦æ¨¡å¼ï¼Œç„¶è€Œåœ¨æ—¶é’Ÿä¸­æ–­çš„å¤„ç†ä¸­ï¼Œå†…æ ¸ä¼šæ£€æµ‹æ˜¯å¦å…·å¤‡åˆ‡æ¢åˆ°é«˜ç²¾åº¦çš„æ¡ä»¶ï¼Œå¦‚æœå„æ¡ä»¶å‡æ»¡è¶³ï¼Œåˆ™åˆ‡æ¢åˆ°é«˜ç²¾åº¦æ¨¡å¼å·¥ä½œã€‚æ—¶é’Ÿä¸­æ–­ä¸­åœ¨å¤„ç†ä½ç²¾åº¦æ—¶é’Ÿæ—¶ï¼Œé€šè¿‡hrtimer_run_pending()å®Œæˆåˆ‡æ¢åŠ¨ä½œï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/timer.c:

static void run_timer_softirq(struct softirq_action *h)
{
    struct tvec_base *base = __this_cpu_read(tvec_bases);

    hrtimer_run_pending();

    if (time_after_eq(jiffies, base-&gt;timer_jiffies))
        __run_timers(base);
}

void hrtimer_run_pending(void)
{
    if (hrtimer_hres_active()) /*å¦‚æœå·²ç»åˆ‡æ¢åˆ°é«˜ç²¾åº¦æ¨¡å¼åˆ™è¿”å›*/
        return;

    if (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) /*åˆ¤æ–­æ˜¯å¦å…·å¤‡åˆ‡æ¢åˆ°é«˜ç²¾åº¦çš„æ¡ä»¶ï¼Œå¦‚æ—¶é’Ÿæºç²¾åº¦æ˜¯å¦æ»¡è¶³ã€æ˜¯å¦æ”¯æŒoneshotæ¨¡å¼*/
        hrtimer_switch_to_hres();
}
</code></pre></div></div>

<p>â€ƒâ€ƒå¦‚æœåˆ‡æ¢æ¡ä»¶å‡æ»¡è¶³ï¼Œåˆ™é€šè¿‡hrtimer_switch_to_hresåˆ‡æ¢åˆ°é«˜ç²¾åº¦æ¨¡å¼ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/hrtimer.c:

static int hrtimer_switch_to_hres(void)
{
    int i, cpu = smp_processor_id();
    struct hrtimer_cpu_base *base = &amp;per_cpu(hrtimer_bases, cpu);
    unsigned long flags;

    if (base-&gt;hres_active)
        return 1;

    local_irq_save(flags);

    if (tick_init_highres()) { /*å°†tickæ¨¡å¼åˆ‡æ¢åˆ°oneshotæ¨¡å¼å¹¶é‡æ–°æŒ‡å®šä¸­æ–­å¤„ç†å‡½æ•°*/
        local_irq_restore(flags);
        printk(KERN_WARNING "Could not switch to high resolution "
        "mode on CPU %d\n", cpu);
        return 0;
    }
    base-&gt;hres_active = 1;
    for (i = 0; i &lt; HRTIMER_MAX_CLOCK_BASES; i++)
    base-&gt;clock_base[i].resolution = KTIME_HIGH_RES;

    tick_setup_sched_timer(); /*è®¾ç½®ä¸€ä¸ªä¸“é—¨çš„è°ƒåº¦å®šæ—¶å™¨ï¼Œç”¨æ¥å¤„ç†è°ƒåº¦ä»»åŠ¡*/
    /* "Retrigger" the interrupt to get things going */
    retrigger_next_event(NULL);
    local_irq_restore(flags);
    return 1;
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/time/tick-oneshot.c:

/**
 * tick_init_highres - switch to high resolution mode
 *
 * Called with interrupts disabled.
 */
int tick_init_highres(void)
{
    return tick_switch_to_oneshot(hrtimer_interrupt); /*é«˜ç²¾åº¦æ¨¡å¼ä¸‹æ—¶é’Ÿä¸­æ–­å¤„ç†å‡½æ•°ä¸ºhrtimer_interrupt*/
}

/**
 * tick_switch_to_oneshot - switch to oneshot mode
 */
int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))
{
    struct tick_device *td = &amp;__get_cpu_var(tick_cpu_device);
    struct clock_event_device *dev = td-&gt;evtdev;

    if (!dev || !(dev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT) ||
        !tick_device_is_functional(dev)) {
        ...
    }

    td-&gt;mode = TICKDEV_MODE_ONESHOT;
    dev-&gt;event_handler = handler;
    clockevents_set_mode(dev, CLOCK_EVT_MODE_ONESHOT);
    tick_broadcast_switch_to_oneshot();
    return 0;
}
</code></pre></div></div>

<h3 id="4-é«˜ç²¾åº¦å®šæ—¶å™¨çš„åˆ°æœŸå¤„ç†">4. é«˜ç²¾åº¦å®šæ—¶å™¨çš„åˆ°æœŸå¤„ç†</h3>

<p>â€ƒâ€ƒå¦‚å‰æ‰€è¿°ï¼Œé«˜ç²¾åº¦æ¨¡å¼ä¸‹ï¼Œæ—¶é’Ÿä¸­æ–­çš„å¤„ç†å‡½æ•°å·²ç»ä»tick_handle_periodicåˆ‡æ¢æˆhrtimer_interruptäº†ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/hrtimer.c:

/*
 * High resolution timer interrupt
 * Called with interrupts disabled
 */
void hrtimer_interrupt(struct clock_event_device *dev)
{
    struct hrtimer_cpu_base *cpu_base = &amp;__get_cpu_var(hrtimer_bases);
    ktime_t expires_next, now, entry_time, delta;
    int i, retries = 0;

    BUG_ON(!cpu_base-&gt;hres_active);
    cpu_base-&gt;nr_events++;
    dev-&gt;next_event.tv64 = KTIME_MAX;

    raw_spin_lock(&amp;cpu_base-&gt;lock);
    entry_time = now = hrtimer_update_base(cpu_base); /*é€šè¿‡æ—¶é’Ÿæºæ›´æ–°å½“å‰ç³»ç»Ÿæ—¶é—´*/
retry:
    expires_next.tv64 = KTIME_MAX;
    /*
     * We set expires_next to KTIME_MAX here with cpu_base-&gt;lock
     * held to prevent that a timer is enqueued in our queue via
     * the migration code. This does not affect enqueueing of
     * timers which run their callback and need to be requeued on
     * this CPU.
     */
    cpu_base-&gt;expires_next.tv64 = KTIME_MAX;

    for (i = 0; i &lt; HRTIMER_MAX_CLOCK_BASES; i++) { /*é’ˆå¯¹ä¸åŒçš„è®¡æ—¶å‚ç…§å¯¹è±¡ä¾æ¬¡å¤„ç†*/
        struct hrtimer_clock_base *base;
        struct timerqueue_node *node;
        ktime_t basenow;

        if (!(cpu_base-&gt;active_bases &amp; (1 &lt;&lt; i)))
            continue;

        base = cpu_base-&gt;clock_base + i;
        basenow = ktime_add(now, base-&gt;offset);

        while ((node = timerqueue_getnext(&amp;base-&gt;active))) { /*æ ¹æ®åˆ°æœŸæ—¶é—´ä¾æ¬¡å¤„ç†çº¢é»‘æ ‘ä¸­çš„å®šæ—¶å™¨*/
            struct hrtimer *timer;

            timer = container_of(node, struct hrtimer, node);

            /*
             * The immediate goal for using the softexpires is
             * minimizing wakeups, not running timers at the
             * earliest interrupt after their soft expiration.
             * This allows us to avoid using a Priority Search
             * Tree, which can answer a stabbing querry for
             * overlapping intervals and instead use the simple
             * BST we already have.
             * We don't add extra wakeups by delaying timers that
             * are right-of a not yet expired timer, because that
             * timer will have to trigger a wakeup anyway.
             */

            if (basenow.tv64 &lt; hrtimer_get_softexpires_tv64(timer)) {
                /*æœªåˆ°æœŸåˆ™é€€å‡ºwhileå¾ªç¯*/

                ktime_t expires;

                expires = ktime_sub(hrtimer_get_expires(timer), base-&gt;offset);
                if (expires.tv64 &lt; 0)
                    expires.tv64 = KTIME_MAX;
                if (expires.tv64 &lt; expires_next.tv64)
                    expires_next = expires;
                break;
            }

            __run_hrtimer(timer, &amp;basenow); /*è°ƒç”¨åˆ°æœŸå›è°ƒå‡½æ•°*/
        } /*end of while*/
    } /*end of for*/

    /*
     * Store the new expiry value so the migration code can verify
     * against it.
     */
    cpu_base-&gt;expires_next = expires_next;
    raw_spin_unlock(&amp;cpu_base-&gt;lock);

    /*ä¸‹é¢é‡æ–°è®¾ç½®clock event deviceçš„ä¸­æ–­è§¦å‘æ—¶é—´ï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›*/
    /* Reprogramming necessary ? */
    if (expires_next.tv64 == KTIME_MAX ||
            !tick_program_event(expires_next, 0)) {
        cpu_base-&gt;hang_detected = 0;
        return;
    }

    /*æ‰§è¡Œåˆ°æ­¤ï¼Œåç»­çš„é€»è¾‘æ˜¯å¤„ç†ä¸€ç§ç‰¹æ®Šçš„åœºæ™¯ï¼Œå³å®šæ—¶å™¨åˆ°æœŸå›è°ƒå‡½æ•°æ‰§è¡Œæ—¶é—´è¿‡é•¿å¯¼è‡´ä¸‹ä¸€ä¸ªå®šæ—¶å™¨åˆåˆ°æœŸäº†*/

    /*
     * The next timer was already expired due to:
     * - tracing
     * - long lasting callbacks
     * - being scheduled away when running in a VM
     *
     * We need to prevent that we loop forever in the hrtimer
     * interrupt routine. We give it 3 attempts to avoid
     * overreacting on some spurious event.
     *
     * Acquire base lock for updating the offsets and retrieving
     * the current time.
     */
    raw_spin_lock(&amp;cpu_base-&gt;lock);
    now = hrtimer_update_base(cpu_base);
    cpu_base-&gt;nr_retries++;
    if (++retries &lt; 3)
        goto retry;
    /*
     * Give the system a chance to do something else than looping
     * here. We stored the entry time, so we know exactly how long
     * we spent here. We schedule the next event this amount of
     * time away.
     */
    cpu_base-&gt;nr_hangs++;
    cpu_base-&gt;hang_detected = 1;
    raw_spin_unlock(&amp;cpu_base-&gt;lock);
    delta = ktime_sub(now, entry_time);
    if (delta.tv64 &gt; cpu_base-&gt;max_hang_time.tv64)
        cpu_base-&gt;max_hang_time = delta;
    /*
     * Limit it to a sensible value as we enforce a longer
     * delay. Give the CPU at least 100ms to catch up.
     */
    if (delta.tv64 &gt; 100 * NSEC_PER_MSEC)
        expires_next = ktime_add_ns(now, 100 * NSEC_PER_MSEC);
    else
        expires_next = ktime_add(now, delta);
    tick_program_event(expires_next, 1);
    printk_once(KERN_WARNING "hrtimer: interrupt took %llu ns\n", ktime_to_ns(delta));
}
</code></pre></div></div>

<p>â€ƒâ€ƒé€šè¿‡åˆ†æé«˜ç²¾åº¦æ¨¡å¼ä¸‹çš„æ—¶é’Ÿä¸­æ–­å¤„ç†å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°å®ƒåªè´Ÿè´£å¤„ç†å®šæ—¶å™¨çš„åˆ°æœŸå¤„ç†ã€‚é‚£ä¹ˆä½ç²¾è°ƒæ¨¡å¼ä¸‹çš„è¿›ç¨‹è°ƒåº¦çš„å¤„ç†é€»è¾‘å»å“ªé‡Œäº†ï¼Ÿä¸éœ€è¦äº†å—ï¼Ÿå…¶å®ï¼Œåœ¨å‰æ–‡ä»£ç ä¸­æˆ‘ä»¬çœ‹åˆ°ï¼Œé«˜ç²¾åº¦æ¨¡å¼ä¸‹å†…æ ¸ä¼šç»™æ¯ä¸ªCPUç”Ÿæˆä¸€ä¸ªè°ƒåº¦å®šæ—¶å™¨ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/time/tick-sched.c:

/**
 * tick_setup_sched_timer - setup the tick emulation timer
 */
void tick_setup_sched_timer(void)
{
    struct tick_sched *ts = &amp;__get_cpu_var(tick_cpu_sched);
    ktime_t now = ktime_get();

    /*
     * Emulate tick processing via per-CPU hrtimers:
     */
    hrtimer_init(&amp;ts-&gt;sched_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
    ts-&gt;sched_timer.function = tick_sched_timer; /*è°ƒåº¦å®šæ—¶å™¨çš„å›è°ƒå‡½æ•°*/

    /* Get the next period (per cpu) */
    hrtimer_set_expires(&amp;ts-&gt;sched_timer, tick_init_jiffy_update());

    /* Offset the tick to avert jiffies_lock contention. */
    if (sched_skew_tick) {
        u64 offset = ktime_to_ns(tick_period) &gt;&gt; 1;
        do_div(offset, num_possible_cpus());
        offset *= smp_processor_id();
        hrtimer_add_expires_ns(&amp;ts-&gt;sched_timer, offset);
    }

    for (;;) {
        hrtimer_forward(&amp;ts-&gt;sched_timer, now, tick_period);
        hrtimer_start_expires(&amp;ts-&gt;sched_timer, HRTIMER_MODE_ABS_PINNED);
        /* Check, if the timer was already in the past */
        if (hrtimer_active(&amp;ts-&gt;sched_timer))
            break;
        now = ktime_get();
    }
    ...
}

/*
 * We rearm the timer until we get disabled by the idle code.
 * Called with interrupts disabled.
 */
static enum hrtimer_restart tick_sched_timer(struct hrtimer *timer)
{
    struct tick_sched *ts =
        container_of(timer, struct tick_sched, sched_timer);
    struct pt_regs *regs = get_irq_regs();
    ktime_t now = ktime_get();

    tick_sched_do_timer(now);

    /*
     * Do not call, when we are not in irq context and have
     * no valid regs pointer
     */
    if (regs)
    tick_sched_handle(ts, regs);

    hrtimer_forward(timer, now, tick_period);

    return HRTIMER_RESTART;
}

static void tick_sched_do_timer(ktime_t now)
{
    int cpu = smp_processor_id();

    ...
    /* Check, if the jiffies need an update */
    if (tick_do_timer_cpu == cpu)
        tick_do_update_jiffies64(now);
}

static void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)
{
    ...
    update_process_times(user_mode(regs));
    profile_tick(CPU_PROFILING);
}
</code></pre></div></div>

<p>â€ƒâ€ƒç”±æ­¤å¯è§ï¼Œè°ƒåº¦å®šæ—¶å™¨æŒ‰tick_periodå‘¨æœŸæ€§è§¦å‘(æš‚ä¸è€ƒè™‘åŠ¨æ€æ—¶é’Ÿnohzç‰¹æ€§)ï¼Œæ¯æ¬¡åˆ°æœŸåå’Œå¤„ç†é€»è¾‘å’Œä½ç²¾åº¦æ¨¡å¼ä¸‹çš„é€»è¾‘ç±»ä¼¼ã€‚</p>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2018/02/é«˜ç²¾åº¦å®šæ—¶å™¨/">ã€æ—¶é—´å­ç³»ç»Ÿã€‘äº”ã€é«˜ç²¾åº¦å®šæ—¶å™¨</a></p>
:ET