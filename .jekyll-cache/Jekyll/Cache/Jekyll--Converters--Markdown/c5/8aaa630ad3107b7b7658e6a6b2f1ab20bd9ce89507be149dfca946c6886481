I"ÈA<p>â€ƒâ€ƒæœ¬èŠ‚å°†è®¨è®ºå†…å­˜å›æ”¶ï¼Œè®¡ç®—å­ç³»ç»Ÿç›¸å…³å†…å®¹ç›®å½•<a href="https://rootw.github.io/2017/02/è®¡ç®—å­ç³»ç»Ÿ/">ç‚¹æ­¤è¿›å…¥</a>ã€‚</p>

<h3 id="ä»€ä¹ˆæ˜¯å†…å­˜å›æ”¶ä¸ºä»€ä¹ˆéœ€è¦å®ƒ">ä»€ä¹ˆæ˜¯å†…å­˜å›æ”¶ï¼Ÿä¸ºä»€ä¹ˆéœ€è¦å®ƒï¼Ÿ</h3>

<p>â€ƒâ€ƒå†…å­˜åˆ†é…è¿‡ç¨‹ä¸­å¦‚æœå‘ç°å‰©ä½™å†…å­˜é‡ä½äºé¢„å®šçš„æ°´ä½çº¿(ä»£è¡¨å†…å­˜ä½¿ç”¨ç´§å¼ )ï¼Œå°±ä¼šå¼ºåˆ¶å›æ”¶ä¸€éƒ¨åˆ†ä½¿ç”¨é¢‘åº¦ä¸é«˜çš„å·²åˆ†é…å†…å­˜ï¼Œä¾›åç»­åˆ†é…ä½¿ç”¨ã€‚å¦‚æ­¤ä¸€æ¥ï¼Œå¥½çš„æ–¹é¢æ˜¯å¯æœ€å¤§é™åº¦æ»¡è¶³ç³»ç»Ÿå†…åº”ç”¨ç¨‹åºçš„å†…å­˜åˆ†é…è¯·æ±‚ï¼Œæå‡ç³»ç»Ÿå¯ç”¨æ€§ã€‚åçš„æ–¹é¢æ˜¯è¢«å›æ”¶é¡µæ‰€å±çš„åº”ç”¨å¯èƒ½å†æ¬¡è®¿é—®è¯¥é¡µï¼Œéœ€è¦é€šè¿‡ç¼ºé¡µå¤„ç†å†æ¬¡åˆ†é…æ˜ å°„é¡µï¼Œä»è€Œå¸¦æ¥åº”ç”¨æ€§èƒ½çš„ä¸‹é™ã€‚ä¸€ä¸ªä¼˜ç§€çš„å†…å­˜å›æ”¶ç®—æ³•éœ€è¦åœ¨ç³»ç»Ÿæ•´ä½“å¯ç”¨æ€§å’Œåº”ç”¨æ€§èƒ½ä¹‹é—´å¯»æ‰¾åˆé€‚çš„å¹³è¡¡ç‚¹ã€‚</p>

<h3 id="å¦‚ä½•å®ç°">å¦‚ä½•å®ç°ï¼Ÿ</h3>

<h4 id="1-å››å¤§é“¾è¡¨"><strong>1. å››å¤§é“¾è¡¨</strong></h4>

<p>â€ƒâ€ƒå†…å­˜å›æ”¶éœ€è¦æ€è€ƒçš„ç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯å…³äºå›æ”¶å¯¹è±¡ï¼Œå³å›æ”¶è°ï¼ŸLinuxå†…æ ¸åªèƒ½å›æ”¶åŠ¨æ€åˆ†é…ç»™åº”ç”¨ç¨‹åºçš„å†…å­˜é¡µï¼Œå†…æ ¸è‡ªèº«ç›´æ¥åˆ†é…ä½¿ç”¨çš„é¡µæ˜¯ä¸å‚ä¸å›æ”¶çš„(é€šè¿‡slabåˆ†é…çš„å†…å­˜å¯å›æ”¶ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸åšæ·±å…¥è®¨è®º)ã€‚åº”ç”¨ç¨‹åºä½¿ç”¨çš„å†…å­˜é¡µè¦ä¹ˆæ˜¯é€šè¿‡æ–‡ä»¶æ˜ å°„çš„(å¦‚ä»£ç æ®µ)ï¼Œè¦ä¹ˆæ˜¯åŒ¿åæ˜ å°„çš„(å¦‚å †æ ˆæ®µ)ã€‚å› æ­¤å†…æ ¸å°†åˆ†é…ç»™åº”ç”¨ç¨‹åºçš„å†…å­˜é¡µåˆ†ä¸ºä¸¤å¤§ç±»ï¼Œå³æ–‡ä»¶é¡µå’ŒåŒ¿åé¡µï¼›åŒæ—¶æ ¹æ®å†…å­˜é¡µä½¿ç”¨çš„é¢‘åº¦åˆåˆ†ä¸ºæ´»è·ƒé¡µå’Œä¸æ´»è·ƒ
é¡µã€‚è¿™æ ·ï¼Œå†…æ ¸é’ˆå¯¹NUMAèŠ‚ç‚¹çš„æ¯ä¸ªzoneå°†å·²åˆ†é…é¡µæ”¾åˆ°å››ä¸ªLRUé“¾è¡¨ä¸­ï¼šéæ´»è·ƒåŒ¿åé¡µé“¾è¡¨ã€æ´»è·ƒåŒ¿åé¡µé“¾è¡¨ã€éæ´»è·ƒæ–‡ä»¶é¡µé“¾è¡¨ã€æ´»è·ƒæ–‡ä»¶é¡µé“¾è¡¨ã€‚è§¦å‘å†…å­˜å›æ”¶åï¼Œå†…æ ¸ä¼šå°†æ´»è·ƒé¡µé“¾è¡¨ä¸­ä½¿ç”¨é¢‘åº¦ä½çš„é¡µæ·˜æ±°åˆ°éæ´»è·ƒé¡µé“¾è¡¨ä¸­ï¼Œå†ä»éæ´»è·ƒé¡µé“¾è¡¨ä¸­å–å‡ºé¢‘åº¦ä½çš„é¡µç›´æ¥å›æ”¶ã€‚æ¯ä¸ªzoneçš„å››å¤§é“¾è¡¨å®šä¹‰å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/mmzone.h:

/*
 * We do arithmetic on the LRU lists in various places in the code,
 * so it is important to keep the active lists LRU_ACTIVE higher in
 * the array than the corresponding inactive lists, and to keep
 * the *_FILE lists LRU_FILE higher than the corresponding _ANON lists.
 *
 * This has to be kept in sync with the statistics in zone_stat_item
 * above and the descriptions in vmstat_text in mm/vmstat.c
 */
#define LRU_BASE 0
#define LRU_ACTIVE 1
#define LRU_FILE 2

enum lru_list {
    LRU_INACTIVE_ANON = LRU_BASE,
    LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,
    LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,
    LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,
    LRU_UNEVICTABLE,
    NR_LRU_LISTS
};
</code></pre></div></div>

<p>â€ƒâ€ƒäº†è§£å››å¤§é“¾è¡¨ç»“æ„åï¼Œå¯ä»¥æ€è€ƒå†…æ ¸æ˜¯å¦‚ä½•æ„ŸçŸ¥å†…å­˜é¡µçš„æ´»è·ƒç¨‹åº¦çš„ï¼Ÿå†…æ ¸æ˜¯é€šè¿‡mark_page_accessedå‡½æ•°æ˜¾å¼æ ‡è®°é¡µçš„æ´»è·ƒç¨‹åº¦ã€‚åˆå§‹åˆ†é…çš„åŒ¿åé¡µè¢«æ”¾ç½®åˆ°æ´»è·ƒé“¾è¡¨ä¸­ï¼Œè€Œæ–‡ä»¶é¡µè¢«æ”¾ç½®åˆ°éæ´»è·ƒé“¾è¡¨ä¸­ï¼Œå¹¶ç”±å†…æ ¸åœ¨åç»­æ“ä½œè¿‡ç¨‹ä¸­æ˜¾å¼æ ‡è®°æ´»è·ƒç¨‹åº¦ï¼šè¿ç»­ä¸¤æ¬¡è¢«è®¿é—®åï¼Œè¯¥é¡µå°†è¢«ç§»åŠ¨åˆ°æ´»è·ƒé¡µé“¾è¡¨ä¸­ã€‚ç›¸å…³å‡½æ•°å¦‚ä¸‹:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/mm/swap.c:

/*
 * Mark a page as having seen activity.
 *
 * inactive,unreferenced	-&gt;	inactive,referenced
 * inactive,referenced		-&gt;	active,unreferenced
 * active,unreferenced		-&gt;	active,referenced
 */
void mark_page_accessed(struct page *page)
{
    if (!PageActive(page) &amp;&amp; !PageUnevictable(page) &amp;&amp;
            PageReferenced(page) &amp;&amp; PageLRU(page)) {
        activate_page(page);
        ClearPageReferenced(page);
    } else if (!PageReferenced(page)) {
        SetPageReferenced(page);
    }
}

</code></pre></div></div>

<h4 id="2-æ•´ä½“æµç¨‹"><strong>2. æ•´ä½“æµç¨‹</strong></h4>

<p>â€ƒâ€ƒä»¥ä¸‹è°ƒç”¨æµç¨‹ä»¥é¡µåˆ†é…ä¸ºå‡ºå‘ç‚¹æ¥è·Ÿè¸ªå†…å­˜å›æ”¶shrink_zoneï¼šget_scan_countè®¡ç®—å„ä¸ªé“¾è¡¨çš„å›æ”¶æ¯”ä¾‹ï¼Œç„¶åå†é€šè¿‡shrink_listä¾æ¬¡å›æ”¶ã€‚ä¸‹é¢æˆ‘ä»¬è¿›ä¸€æ­¥å±•å¼€ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alloc_pages
    -&gt;get_page_from_freelist
        -&gt;zone_reclaim
            -&gt;shrink_zone
                -&gt;shrink_lruvec
                    -&gt;get_scan_count
                    -&gt;shrink_list
</code></pre></div></div>

<h4 id="21-å›æ”¶æ¯”ä¾‹"><strong>2.1 å›æ”¶æ¯”ä¾‹</strong></h4>

<p>â€ƒâ€ƒå†…å­˜å›æ”¶æ—¶æœ‰å››å¤§é“¾è¡¨ä¾›é€‰æ‹©ï¼Œæ¯æ¬¡å›æ”¶æ—¶éƒ½éœ€è¦æ‰«ææ‰€æœ‰é“¾è¡¨å—ï¼Ÿä¸æ˜¯è¿™æ ·çš„ï¼Œå†…æ ¸é€šè¿‡get_scan_countè®¡ç®—æ¯ä¸ªé“¾è¡¨çš„æ‰«ææ¯”ä¾‹ï¼Œæ¯”ä¾‹è¶Šé«˜å›æ”¶çš„é¡µå¯èƒ½å°±è¶Šå¤šã€‚è¿™ä¸ªå‡½æ•°è¯¦ç»†çš„ä»£ç å°±ä¸åˆ†æäº†ï¼Œæœ‰ç‚¹å¤æ‚ï¼Œæˆ‘ä»¬åªéœ€è¦çŸ¥é“æœ€ç»ˆnræ•°ç»„ä¼šè®°å½•æ¯ä¸ªé“¾è¡¨çš„æ‰«æé¡µæ•°ã€‚</p>

<h4 id="22-æ´»è·ƒé“¾è¡¨å›æ”¶"><strong>2.2 æ´»è·ƒé“¾è¡¨å›æ”¶</strong></h4>

<p>â€ƒâ€ƒé€šè¿‡ä¸‹é¢shrink_listçš„ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥æ¸…æ¥šçœ‹åˆ°ï¼Œé’ˆå¯¹æ´»è·ƒé“¾è¡¨ï¼Œå¦‚æœéæ´»è·ƒé¡µåå°‘åˆ™é€šè¿‡shrink_active_listå°†éƒ¨åˆ†æ´»è·ƒé¡µç§»åŠ¨åˆ°éæ´»è·ƒé¡µä¸­ï¼Œæ­¤æ—¶å¹¶ä¸è¿›è¡Œå›æ”¶åŠ¨ä½œã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/mm/vmscan.c:

static unsigned long shrink_list(enum lru_list lru, unsigned long nr_to_scan,
                            struct lruvec *lruvec, struct scan_control *sc)
{
    if (is_active_lru(lru)) {
        if (inactive_list_is_low(lruvec, lru))
            shrink_active_list(nr_to_scan, lruvec, sc, lru);
        return 0;
    }

    return shrink_inactive_list(nr_to_scan, lruvec, sc, lru);
}

static void shrink_active_list(unsigned long nr_to_scan,
                        struct lruvec *lruvec,
                        struct scan_control *sc,
                        enum lru_list lru)
{
    unsigned long nr_taken;
    unsigned long nr_scanned;
    unsigned long vm_flags;
    LIST_HEAD(l_hold);	/* The pages which were snipped off */
    LIST_HEAD(l_active);
    LIST_HEAD(l_inactive);
    struct page *page;
    unsigned long nr_rotated = 0;
    isolate_mode_t isolate_mode = 0;
    int file = is_file_lru(lru);
    struct zone *zone = lruvec_zone(lruvec);

    ...

    spin_lock_irq(&amp;zone-&gt;lru_lock);
    /*ä»æ´»è·ƒé“¾è¡¨lruvec[lru]ä¸­ç§»åŠ¨éƒ¨åˆ†é¡µåˆ°l_holdä¸­ï¼Œnr_scannedè®°å½•ç§»åŠ¨é¡µæ•°*/
    nr_taken = isolate_lru_pages(nr_to_scan, lruvec, &amp;l_hold,
                        &amp;nr_scanned, sc, isolate_mode, lru);
    ...
    spin_unlock_irq(&amp;zone-&gt;lru_lock);

    while (!list_empty(&amp;l_hold)) {
        /*é’ˆå¯¹l_holdä¸­çš„æ¯ä¸€é¡µï¼Œå¿è¯•å°†å…¶ç§»åŠ¨åˆ°éæ´»è·ƒé“¾è¡¨ä¸­*/
        cond_resched();
        page = lru_to_page(&amp;l_hold);
        list_del(&amp;page-&gt;lru);

        ...

        /*åˆ¤æ–­å½“å‰é¡µpageæ˜¯å¦è¢«è®¿é—®ï¼Œæ¶‰åŠåå‘æ˜ å°„ï¼Œå¤§å®¶æ„Ÿå…´è¶£å¯ä»¥æ·±å…¥åˆ†æ*/
        if (page_referenced(page, 0, sc-&gt;target_mem_cgroup, &amp;vm_flags)) {
            nr_rotated += hpage_nr_pages(page);
            /*
             * Identify referenced, file-backed active pages and
             * give them one more trip around the active list. So
             * that executable code get better chances to stay in
             * memory under moderate memory pressure.  Anon pages
             * are not likely to be evicted by use-once streaming
             * IO, plus JVM can create lots of anon VM_EXEC pages,
             * so we ignore them here.
             */
            /*é’ˆå¯¹JVMåœºæ™¯ï¼Œä¿ç•™VM_EXECæ®µçš„æ–‡ä»¶é¡µåœ¨æ´»è·ƒé“¾è¡¨ä¸­*/
            if ((vm_flags &amp; VM_EXEC) &amp;&amp; page_is_file_cache(page)) {
                list_add(&amp;page-&gt;lru, &amp;l_active);
                continue;
            }
        }
        
        /*æ¸…é™¤å½“å‰é¡µçš„æ´»è·ƒæ ‡è®°ï¼Œå¹¶æ”¾å…¥ä¸´æ—¶é“¾è¡¨l_inactiveä¸­ï¼Œä¸ºåç»­ç§»åŠ¨ä½œå‡†å¤‡*/
        ClearPageActive(page);	/* we are de-activating */
        list_add(&amp;page-&gt;lru, &amp;l_inactive);
    }

    /*
     * Move pages back to the lru list.
     */
    spin_lock_irq(&amp;zone-&gt;lru_lock);
    ...
    move_active_pages_to_lru(lruvec, &amp;l_active, &amp;l_hold, lru); /*æ‰¹é‡å°†l_activeä¸­çš„é¡µç§»å›æ´»è·ƒé“¾è¡¨*/
    move_active_pages_to_lru(lruvec, &amp;l_inactive, &amp;l_hold, lru - LRU_ACTIVE); /*æ‰¹é‡å°†l_inactiveä¸­çš„é¡µç§»åˆ°éæ´»è·ƒé“¾è¡¨ä¸­*/
    __mod_zone_page_state(zone, NR_ISOLATED_ANON + file, -nr_taken);
    spin_unlock_irq(&amp;zone-&gt;lru_lock);

    free_hot_cold_page_list(&amp;l_hold, 1); /*l_holdä¿ç•™ç§»åŠ¨è¿‡ç¨‹ä¸­å·²è¢«é‡Šæ”¾çš„å†…å­˜é¡µï¼Œè¿™é‡Œå°†å…¶æ­£å¼é‡Šæ”¾*/
}

</code></pre></div></div>

<h4 id="23-éæ´»è·ƒé“¾è¡¨å›æ”¶"><strong>2.3 éæ´»è·ƒé“¾è¡¨å›æ”¶</strong></h4>

<p>â€ƒâ€ƒéæ´»è·ƒé“¾è¡¨ä¸­çš„é¡µæ˜¯é‡ç‚¹å›æ”¶å¯¹è±¡ï¼Œæ ¸å¿ƒåŠŸèƒ½åœ¨shrink_page_listå‡½æ•°ä¸­å®ç°ã€‚è¯¥å‡½æ•°å¯¹éæ´»è·ƒé“¾è¡¨å°¾éƒ¨çš„è‹¥å¹²é¡µä¾æ¬¡è¿›è¡Œæ‰«æï¼šé¦–å…ˆå¯¹å½“å‰æ‰«æé¡µåŠ é”ï¼Œé¿å…æ‰«ææœŸé—´åŒæ—¶å­˜åœ¨å…¶å®ƒé¡µæ“ä½œï¼›æ¥ç€é€šè¿‡writebackæ ‡è®°åˆ¤æ–­å½“å‰æ‰«æé¡µæ˜¯å¦æ­£åœ¨è¢«å›å†™ï¼Œå¦‚æœæ˜¯åˆ™è·³è¿‡å½“å‰é¡µå»æ‰«æä¸‹ä¸€é¡µï¼›æ¥ç€åˆ¤æ–­å½“å‰é¡µæ˜¯å¦è¢«è®¿é—®è¿‡ï¼Œå¦‚æœé¡µè¡¨çš„accessedä½è¢«ç½®ä½åˆ™è¯´æ˜é¡µè¢«è®¿é—®è¿‡ï¼Œæ¸…é™¤æ ‡è®°åä»»è·³è¿‡å½“å‰é¡µï¼›é¡µæœªè¢«è®¿é—®æƒ…å†µä¸‹ï¼Œä¸ºåŒ¿åé¡µæ·»åŠ äº¤æ¢åˆ†åŒºæ˜ å°„(æ–‡ä»¶é¡µå¿…ç„¶æœ‰æ–‡ä»¶ä¸ä¹‹ç›¸åº”)ï¼Œä¹‹åæ­£å¼è§£é™¤å½“å‰æ‰«æé¡µçš„é¡µè¡¨æ˜ å°„ï¼›é¡µè¡¨æ˜ å°„è§£é™¤æˆåŠŸåï¼Œå¼€å§‹å›åˆ·è„é¡µï¼Œå¾…è„é¡µå›åˆ·å®Œæˆåæœ€åå°†å½“å‰é¡µä»æ–‡ä»¶ç¼“å­˜æ˜ å°„æˆ–åŒ¿åæ˜ å°„ä¸­ç§»é™¤ï¼Œä¹‹åä¾¿å¯é‡Šæ”¾å½“å‰é¡µã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/mm/vmscan.c:

/*
 * shrink_page_list() returns the number of reclaimed pages
 */
static unsigned long shrink_page_list(struct list_head *page_list,
                                struct zone *zone,
                                struct scan_control *sc,
                                enum ttu_flags ttu_flags,
                                unsigned long *ret_nr_dirty,
                                unsigned long *ret_nr_writeback,
                                bool force_reclaim)
{
/*å‚æ•°è¯´æ˜ï¼špage_listè®°å½•å¾…å›æ”¶çš„éæ´»è·ƒé¡µï¼›zoneä»£è¡¨å½“å‰è¢«å›æ”¶çš„zoneï¼›scä¸ºå›æ”¶æ§åˆ¶å˜é‡ï¼›
          ttu_flagsè¡¨ç¤ºunmapè§£é™¤é¡µè¡¨æ˜ å°„æ“ä½œæ ‡å¿—ï¼›ret_nr_dirtyè¡¨ç¤ºè¿”å›ç»™å¤–å±‚çš„è„é¡µæ•°ï¼›
          ret_nr_writebackè¡¨ç¤ºè¿”å›ç»™å¤–å±‚çš„æ­£åœ¨å›å†™çš„é¡µæ•°ï¼›force_relcaimä»£è¡¨å¼ºåˆ¶å›æ”¶*/

    LIST_HEAD(ret_pages); /*ä¿å­˜ä¸å¯å›æ”¶çš„é¡µ*/
    LIST_HEAD(free_pages); /*ä¿å­˜å¯å›æ”¶çš„é¡µ*/
    int pgactivate = 0;
    unsigned long nr_dirty = 0;
    unsigned long nr_congested = 0;
    unsigned long nr_reclaimed = 0;
    unsigned long nr_writeback = 0;

    
    while (!list_empty(page_list)) { /*å¯¹page_listä¸­å¾…å›æ”¶é¡µä¾æ¬¡è¿›è¡Œå›æ”¶*/
        struct address_space *mapping;
        struct page *page;
        int may_enter_fs;
        enum page_references references = PAGEREF_RECLAIM_CLEAN;

        cond_resched();

        page = lru_to_page(page_list);
        list_del(&amp;page-&gt;lru);

        /*å¿è¯•é”å®šå½“å‰é¡µï¼Œå¦‚æœæ— æ³•é”å®šåˆ™ä¿ç•™å½“å‰é¡µ*/
        if (!trylock_page(page))
            goto keep;

        ...

        /*å¤„ç†writebacké¡µï¼Œè¯¥æ ‡è®°è¡¨ç¤ºå†…å­˜é¡µæ­£åœ¨è¢«å›åˆ·è½ç›˜ï¼Œä½†IOæ“ä½œæœ‰å¯èƒ½è¿˜æœªå®Œæˆ*/
        if (PageWriteback(page)) {

            if (global_reclaim(sc) || !PageReclaim(page) || !may_enter_fs) {
                /*å¯¹äºå…¨å±€å›æ”¶ç­‰åœºæ™¯ï¼Œä¸å¯¹writebacké¡µä½œå›æ”¶ï¼Œå°†å…¶æ”¾å›é“¾è¡¨*/
                SetPageReclaim(page);
                nr_writeback++;
                goto keep_locked;
            }
            wait_on_page_writeback(page); /*å…¶å®ƒæƒ…å†µä¸‹å°†ç­‰å¾…é¡µé¢å›åˆ·å®Œæˆ*/
        }

        /*å¯¹äºéå¼ºåˆ¶å›æ”¶åœºæ™¯ï¼Œéœ€è¦æ£€æŸ¥å½“å‰å¾…å›æ”¶é¡µçš„è®¿é—®æƒ…å†µï¼Œç¡®å®šè®¿é—®ä¸é¢‘ç¹æ‰å¯å›æ”¶*/
        if (!force_reclaim)
            references = page_check_references(page, sc);

        switch (references) {
        case PAGEREF_ACTIVATE:
            goto activate_locked;
        case PAGEREF_KEEP:
            goto keep_locked;
        case PAGEREF_RECLAIM:
        case PAGEREF_RECLAIM_CLEAN:
            ;/* try to reclaim the page below */
        }

        /*å¦‚æœæ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜å½“å‰é¡µæ˜¯ä¸€ä¸ªå¯å›æ”¶çš„éwritebacké¡µ*/

        /*
         * Anonymous process memory has backing store?
         * Try to allocate it some swap space here.
         */
        if (PageAnon(page) &amp;&amp; !PageSwapCache(page)) {
            /*é’ˆå¯¹åŒ¿åé¡µï¼Œå¦‚æœä¸åœ¨äº¤æ¢ç¼“å†²åŒºä¸­(äº¤æ¢åˆ†åŒºå¯¹åº”çš„å†…å­˜é¡µç¼“å­˜)ï¼Œéœ€è¦å°†å®ƒåŠ å…¥å…¶ä¸­*/
            if (!(sc-&gt;gfp_mask &amp; __GFP_IO))
                goto keep_locked;
            if (!add_to_swap(page, page_list))
                goto activate_locked;
                may_enter_fs = 1;
        }

        mapping = page_mapping(page);

        /*æ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜å½“å‰é¡µå·²å»ºç«‹åç«¯æ˜ å°„å…³ç³»ï¼šæ–‡ä»¶é¡µå¯¹åº”æ–‡ä»¶ï¼ŒåŒ¿åé¡µå¯¹åº”äº¤æ¢åˆ†åŒº*/

        /*
         * The page is mapped into the page tables of one or more
         * processes. Try to unmap it here.
         */
        if (page_mapped(page) &amp;&amp; mapping) {
            /*å¼€å§‹è§£é™¤é¡µè¡¨ä¸­çš„æ˜ å°„å…³ç³»å¹¶åˆ·æ–°TLBè¡¨*/
            switch (try_to_unmap(page, ttu_flags)) {
            case SWAP_FAIL:
                goto activate_locked;
            case SWAP_AGAIN:
                goto keep_locked;
            case SWAP_MLOCK:
                goto cull_mlocked;
            case SWAP_SUCCESS:
                ; /* try to free the page below */
            }
        }

        if (PageDirty(page)) {
            /*å¯¹äºè„é¡µï¼Œå¼€å§‹æ‰§è¡Œå›åˆ·åŠ¨ä½œ*/
            nr_dirty++;

            ...

            /* Page is dirty, try to write it out here */
            switch (pageout(page, mapping, sc)) { /*è°ƒç”¨åº•å±‚æ–‡ä»¶ç³»ç»Ÿæ¥å£è¿›è¡Œå›åˆ·*/
            case PAGE_KEEP:
                nr_congested++;
                goto keep_locked;
            case PAGE_ACTIVATE:
                goto activate_locked;
            case PAGE_SUCCESS:
                /*å›åˆ·åŠ¨ä½œè§¦å‘æˆåŠŸåï¼Œå¦‚æœé¡µé¢å¤„åœ¨writebackçŠ¶æ€ï¼Œåˆ™ä¸åœ¨æœ¬è½®è¿›è¡Œå›æ”¶*/
                if (PageWriteback(page))
                    goto keep;
                if (PageDirty(page))
                    goto keep;

                /*
                 * A synchronous write - probably a ramdisk.  Go
                 * ahead and try to reclaim the page.
                 */
                /*å¯¹äºramdiskè¿™ç±»åœºæ™¯ï¼Œå›åˆ·è§¦å‘ç«‹åˆ»å°±å®Œæˆäº†ï¼Œä¸ä¼šç½®writebackï¼Œå¯ç»§ç»­è¿›è¡Œå›æ”¶*/
                if (!trylock_page(page))
                    goto keep;
                if (PageDirty(page) || PageWriteback(page))
                    goto keep_locked;
                mapping = page_mapping(page);
            case PAGE_CLEAN:
                ; /* try to free the page below */
            }
        }

        ...

        /*ä»æ–‡ä»¶ç¼“å­˜æˆ–äº¤æ¢ç¼“å­˜ä¸­å°†å½“å‰é¡µç§»é™¤ï¼Œå½»åº•è§£é™¤å½“å‰é¡µçš„æ˜ å°„å…³ç³»*/
        if (!mapping || !__remove_mapping(mapping, page))
            goto keep_locked;

        __clear_page_locked(page);
free_it:
        nr_reclaimed++;

        /*
         * Is there need to periodically free_page_list? It would
         * appear not as the counts should be low
         */
        list_add(&amp;page-&gt;lru, &amp;free_pages); /*å°†å½“å‰é¡µåŠ å…¥åˆ°å¾…å›æ”¶é“¾è¡¨ä¸­*/
        continue;

cull_mlocked:
        if (PageSwapCache(page))
            try_to_free_swap(page);
        unlock_page(page);
        putback_lru_page(page);
        continue;

activate_locked:
        /* Not a candidate for swapping, so reclaim swap space. */
        if (PageSwapCache(page) &amp;&amp; vm_swap_full())
            try_to_free_swap(page);
        VM_BUG_ON(PageActive(page));
        SetPageActive(page);
        pgactivate++;
keep_locked:
        unlock_page(page);
keep:
        list_add(&amp;page-&gt;lru, &amp;ret_pages);
        VM_BUG_ON(PageLRU(page) || PageUnevictable(page));
    } // end of while

    free_hot_cold_page_list(&amp;free_pages, 1); /*æ­£å¼å›æ”¶free_pagesé“¾è¡¨ä¸­çš„æ‰€æœ‰é¡µ*/

    ...
    return nr_reclaimed;
}
</code></pre></div></div>
<p>â€ƒâ€ƒè‡³æ­¤ï¼Œå†…å­˜å›æ”¶è¿‡ç¨‹å·²åŸºæœ¬åˆ†æå®Œæˆï¼Œå…¶ä¸­å¯¹äºåŒ¿åé¡µï¼Œå›æ”¶è¿‡ç¨‹ä¼šè§¦å‘å†…å­˜äº¤æ¢ï¼Œæœ‰å…³å†…å­˜äº¤æ¢çš„è¯¦ç»†å†…å®¹æˆ‘ä»¬å°†åœ¨åç»­åšæ–‡ä¸­ç»™å‡ºã€‚</p>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2017/10/å†…å­˜å›æ”¶/">ã€è®¡ç®—å­ç³»ç»Ÿã€‘å†…å­˜ç®¡ç†ä¹‹ä¸‰ï¼šå†…å­˜å›æ”¶</a></p>
:ET