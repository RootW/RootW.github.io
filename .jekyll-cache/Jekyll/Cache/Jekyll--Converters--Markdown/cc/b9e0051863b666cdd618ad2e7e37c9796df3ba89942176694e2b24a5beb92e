I"Ï=<p>â€ƒâ€ƒè¿›ç¨‹ç®¡ç†ä¹Ÿæ˜¯è®¡ç®—å­ç³»ç»Ÿ(CPU&amp;Memory)çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œä»æœ¬ç¯‡åšæ–‡èµ·ï¼Œæˆ‘ä»¬å¼€å§‹è®¨è®ºè¿›ç¨‹ç®¡ç†ã€‚è®¡ç®—å­ç³»ç»Ÿç›¸å…³å†…å®¹ç›®å½•<a href="https://rootw.github.io/2017/02/è®¡ç®—å­ç³»ç»Ÿ/">ç‚¹æ­¤è¿›å…¥</a>ã€‚</p>

<h3 id="ä»€ä¹ˆæ˜¯è¿›ç¨‹ä»€ä¹ˆæ˜¯è¿›ç¨‹ç®¡ç†ä¸ºä»€ä¹ˆéœ€è¦è¿›ç¨‹ç®¡ç†">ä»€ä¹ˆæ˜¯è¿›ç¨‹ï¼Ÿä»€ä¹ˆæ˜¯è¿›ç¨‹ç®¡ç†ï¼Ÿä¸ºä»€ä¹ˆéœ€è¦è¿›ç¨‹ç®¡ç†ï¼Ÿ</h3>

<p>â€ƒâ€ƒä»ç‰©ç†è§†è§’è¯´ä¸Šï¼Œè¿›ç¨‹æ˜¯CPUä¸Šçš„ä¸€æ®µé€»è¾‘è¿‡ç¨‹ï¼Œå®ƒçš„æ§åˆ¶(ä»£ç æ®µ)å’Œæ•°æ®(æ•°æ®æ®µ)å­˜æ”¾äºå†…å­˜ã€‚å›é¡¾ä¸€ä¸‹è®¡ç®—å­ç³»ç»Ÿå¼€ç¯‡ä¸­æç»˜çš„ç³»ç»Ÿç»“æ„å›¾(å¦‚ä¸‹å›¾)ï¼Œè¿›ç¨‹çš„æ‰§è¡Œè¦ç´ åŒ…æ‹¬CPUä¸­çš„å¯„å­˜å™¨å’Œå†…å­˜æ®µä¸¤ä¸ªéƒ¨åˆ†(è™šæ‹Ÿå†…å­˜æ®µæœ€ç»ˆä¼šæ˜ å°„åˆ°ç‰©ç†å†…å­˜æ®µ)ï¼šå¯„å­˜å™¨ä»£è¡¨è¿›ç¨‹çš„ç¬æ—¶è¿è¡ŒçŠ¶æ€ï¼›ä»£ç æ®µå­˜å‚¨æŒ‡ä»¤ï¼Œæ§åˆ¶è¿›ç¨‹æ‰§è¡Œé€»è¾‘ï¼›æ•°æ®æ®µå­˜å‚¨è¿›ç¨‹çš„å…¨å±€æ•°æ®ï¼›å †æ ˆæ®µå­˜å‚¨å±€éƒ¨æ•°æ®å’ŒåŠ¨æ€æ•°æ®ã€‚ä»åŠŸèƒ½è§†è§’è¯´ï¼Œè¿›ç¨‹æ˜¯å„ç§â€œåŠŸèƒ½â€çš„å®ç°å®ä½“ï¼Œè®¡ç®—æœºä¸ºäººä»¬æä¾›çš„è¯¸å¦‚èŠå¤©ã€ä¸Šç½‘ã€çœ‹è§†é¢‘ç­‰å„ç§åŠŸèƒ½éƒ½æ˜¯é€šè¿‡è¿›ç¨‹å®ç°çš„ï¼Œå› æ­¤è¿›ç¨‹æœ‰æ—¶ä¹Ÿè¢«å«ä½œâ€œä»»åŠ¡â€œã€‚</p>

<div align="center">
<img src="/images/posts/i440fx/cpu_low_level.jpg" height="550" width="400" />  
</div>

<p>â€ƒâ€ƒè¿›ç¨‹ç®¡ç†æ˜¯æŒ‡ä¸è¿›ç¨‹ç›¸å…³çš„ä¸€ç³»åˆ—åŠ¨ä½œï¼Œå¦‚åˆ›å»ºã€æ›¿æ¢ã€ç»ˆæ­¢ã€è°ƒåº¦ã€é€šä¿¡ç­‰ç­‰ã€‚è¿›ç¨‹ç®¡ç†ä½¿å¾—ä¸€ä¸ªCPUå¯ä»¥æ‰§è¡Œè‹¥å¹²è¿›ç¨‹ï¼Œå„è¿›ç¨‹åˆ†æ—¶å¤ç”¨CPUçš„ç‰©ç†èµ„æºï¼›å†…å­˜ç®¡ç†ä½¿å¾—å¤šä¸ªè¿›ç¨‹å¯ä»¥å…±äº«ç‰©ç†å†…å­˜ï¼›åŸºäºä¸Šè¿°ä¸¤ä¸ªæ ¸å¿ƒåŠŸèƒ½ï¼Œè®¡ç®—æœºç³»ç»Ÿå¯ä»¥å®ç°å¤šä»»åŠ¡å¹¶è¡Œï¼Œå¤§å¤§æå‡ç³»ç»Ÿè¿è¡Œæ•ˆç‡ï¼Œæ–¹ä½¿å®¢æˆ·ä½¿ç”¨(æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœä½ çš„è®¡ç®—æœºä¸€ä¸ªæ—¶åˆ»åªèƒ½è¿è¡Œä¸€ä¸ªä»»åŠ¡ï¼Œé‚£å°†æ˜¯ä¸€ç§å¤šä¹ˆç³Ÿç³•ä½“éªŒ)ã€‚</p>

<h3 id="å¦‚ä½•åˆ›å»ºè¿›ç¨‹">å¦‚ä½•åˆ›å»ºè¿›ç¨‹ï¼Ÿ</h3>

<p>â€ƒâ€ƒè¿›ç¨‹åˆ›å»ºå°±æ˜¯æ–°å»ºä¸€ä¸ªè¿›ç¨‹ï¼Œè¿™æ˜¯è¿›ç¨‹ç®¡ç†æœ€åŸºæœ¬çš„åŠŸèƒ½ï¼Œä¹Ÿæ˜¯è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸçš„èµ·ç‚¹ã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥çœ‹çœ‹è¿›ç¨‹åˆ›å»ºåœ¨Linuxå†…æ ¸ä¸­æ˜¯å¦‚ä½•å®ç°çš„ã€‚</p>

<h4 id="forkvforkå’Œclone"><strong>forkã€vforkå’Œclone</strong></h4>

<p>â€ƒâ€ƒä»åº”ç”¨ç¨‹åºå¼€å‘çš„å±‚æ¬¡ä¸Šï¼Œæˆ‘ä»¬åº”è¯¥çŸ¥é“åˆ›å»ºè¿›ç¨‹(æˆ–çº¿ç¨‹ï¼Œå³è½»é‡çº§è¿›ç¨‹)æœ‰forkã€vforkå’Œcloneä¸‰ç§<a href="https://rootw.github.io/2017/02/ç³»ç»Ÿè°ƒç”¨/">ç³»ç»Ÿè°ƒç”¨</a>ï¼šforkæ˜¯åˆ›å»ºè¿›ç¨‹æ ‡å‡†åšæ³•ï¼Œçˆ¶å­è¿›ç¨‹å…±äº«ä»£ç æ®µï¼Œä½†æ‹¥æœ‰ç‹¬ç«‹æ•°æ®ã€å †æ ˆæ®µï¼›vforkæ˜¯è½»é‡çº§è¿›ç¨‹åˆ›å»ºæ–¹æ³•ï¼Œçˆ¶å­è¿›ç¨‹å…±äº«ä»£ç ã€æ•°æ®å’Œå †æ ˆæ®µï¼Œå­è¿›ç¨‹è¿è¡ŒæœŸé—´çˆ¶è¿›ç¨‹æ˜¯ç¡çœ çš„ï¼Œå½“å­è¿›ç¨‹ç»“æŸåçˆ¶è¿›ç¨‹æ‰ç»§ç»­è¿è¡Œï¼›cloneåˆ™æä¾›äº†æ›´çµæ´»çš„è¿›ç¨‹åˆ›å»ºæ–¹å¼ï¼Œå¯ä»¥é€šè¿‡clone_flagsæ¥æ§åˆ¶åˆ›å»ºè¿‡ç¨‹ï¼Œlibpthreadåº“æä¾›çš„ç›¸å…³APIå³æ˜¯é€šè¿‡cloneç³»ç»Ÿè°ƒç”¨å®ç°çš„ã€‚å¤§å®¶å¯ä»¥åœ¨ç½‘ä¸Šæ‰¾ä¸€äº›è¿™ä¸‰ç§æ–¹å¼çš„ç¤ºä¾‹ä»£ç ï¼ŒåŠ¨æ‰‹å®éªŒä¸€ä¸‹ä»¥åŠ æ·±ç†è§£ã€‚åˆ°äº†å†…æ ¸æ€ï¼Œè¿™ä¸‰ä¸ªç³»ç»Ÿè°ƒç”¨æœ€ç»ˆéƒ½é€šè¿‡do_forkå‡½æ•°æ¥å®ç°å…¶æ ¸å¿ƒåŠŸèƒ½ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/fork.c:

SYSCALL_DEFINE0(fork)
{
    return do_fork(SIGCHLD, 0, 0, NULL, NULL);
}

SYSCALL_DEFINE0(vfork)
{
    return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, 0, 
        0, NULL, NULL);
}

SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,
                int __user *, parent_tidptr,
                int __user *, child_tidptr,
                int, tls_val)
{
    return do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr);
}
</code></pre></div></div>

<h4 id="è¿›ç¨‹æ§åˆ¶å—struct-task_struct"><strong>è¿›ç¨‹æ§åˆ¶å—ï¼šstruct task_struct</strong></h4>

<p>â€ƒâ€ƒåœ¨æ·±å…¥åˆ†ædo_forkä¹‹å‰ï¼Œæˆ‘ä»¬é¦–å…ˆè¦æ˜ç™½å†…æ ¸å¯¹è¿›ç¨‹éœ€è¦æœ‰ä¸€ä¸ªæŠ½è±¡çš„æ•°æ®è¡¨è¾¾ï¼ŒåŸºäºè¿™ç§æ•°æ®è¡¨è¾¾æ‰èƒ½å®ç°å„ç§ç®¡ç†åŠŸèƒ½ã€‚æˆ‘ä»¬å°†å†…æ ¸ä¸­è¡¨è¾¾è¿›ç¨‹çš„æ•°æ®ç»“æ„å«åšè¿›ç¨‹æ§åˆ¶å—ï¼Œåœ¨linuxä¸­åˆ™æ˜¯struct task_structã€‚è¿™é‡Œæˆ‘ä¸æ‰“ç®—å¯¹task_structä¸­çš„å„ä¸ªå­—æ®µè¿›è¡Œé€ä¸€æè¿°ï¼Œå› ä¸ºéš¾ä»¥è¡¨è¿°æ¸…æ¥šï¼Œå¤§å®¶å¯ä»¥ç»“åˆåç»­çš„ä»£ç æµç¨‹æ¥æ·±å…¥ç†è§£å„å­—æ®µçš„å«ä¹‰ï¼Œä¸‹é¢æ˜¯ä¸€å¹…æ•´ä½“ç»“æ„å›¾ï¼Œä¾›å‚è€ƒï¼š</p>

<div align="center">
<img src="/images/posts/i440fx/process1_1.jpg" height="500" width="450" />  
</div>

<p>â€ƒâ€ƒå¦å¤–ï¼Œåœ¨æ—©æœŸçš„linuxç‰ˆæœ¬ä¸­ï¼Œè¿›ç¨‹æ§åˆ¶å—æ˜¯åŒ…å«è¿›ç¨‹çš„å†…æ ¸æ€æ ˆçš„(é€šå¸¸æ˜¯8KBå¤§å°)ã€‚ä»€ä¹ˆæ˜¯å†…æ ¸æ€æ ˆï¼Ÿæ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ç”¨æˆ·æ€ç©ºé—´å’Œå†…æ ¸æ€ç©ºé—´ä¸¤ä¸ªæ‰§è¡Œç©ºé—´ï¼Œå‡ºäºå®‰å…¨éš”ç¦»çš„è€ƒè™‘ï¼Œä¸¤ä¸ªç©ºé—´ä½¿ç”¨ç‹¬ç«‹çš„æ ˆï¼Œå› æ­¤å†…æ ¸æ ˆå°±è¢«å®‰æ’åœ¨äº†è¿›ç¨‹æ§åˆ¶å—ä¸­ï¼Œæ ˆåº•åœ¨é«˜åœ°å€ç«¯ï¼Œä»é«˜åœ°å€å¾€ä½åœ°å€æ‰©å±•ï¼Œè€Œè¿›ç¨‹æ§åˆ¶å—å…¶å®ƒæ•°æ®åˆ™è¢«æ”¾ç½®åœ¨8Kçš„ä½åœ°å€èµ·å§‹ä½ç½®å¤„ã€‚éšç€å†…æ ¸çš„å‘å±•ï¼Œå„ç§åŠŸèƒ½ä¸æ–­è¢«åŠ å…¥ï¼Œè¿›ç¨‹æ§åˆ¶å—çš„æ•°æ®ç»“æ„ä¹Ÿåœ¨ä¸æ–­å˜å¤§ï¼Œå› æ­¤å°±å­˜åœ¨æŒ¤å å†…æ ¸æ ˆçš„é£é™©ã€‚æ‰€ä»¥é«˜ç‰ˆæœ¬å†…æ ¸å°†è¿›ç¨‹æ§åˆ¶å—å’Œå†…æ ¸æ ˆè¿›è¡Œäº†åˆ†ç¦»ï¼šå†…æ ¸æ ˆçš„ä½åœ°å€ç«¯åªä¿ç•™åŸºæœ¬çš„è¿›ç¨‹ä¿¡æ¯ï¼Œå¹¶é€šè¿‡æŒ‡é’ˆå¯¹å‘çœŸæ­£çš„è¿›ç¨‹æ§åˆ¶å—ç»“æ„ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p>

<div align="center">
<img src="/images/posts/i440fx/process1_2.jpg" height="300" width="450" />  
</div>

<h4 id="æ·±å…¥do_fork"><strong>æ·±å…¥do_fork</strong></h4>

<p>â€ƒâ€ƒdo_forkåœ¨ä¼ å…¥å‚æ•°clone_flagsçš„æ§åˆ¶ä¸‹ï¼ŒåŸºäºå½“å‰è¿›ç¨‹å¤åˆ¶äº†ä¸€ä¸ªæ–°è¿›ç¨‹ï¼Œå…¶å¤§ä½“æµç¨‹æ˜¯ï¼šå…ˆå¤åˆ¶å½“å‰è¿›ç¨‹äº§ç”Ÿæ–°çš„è¿›ç¨‹æ§åˆ¶å—ï¼Œç„¶åå†è°ƒåº¦æ–°è¿›ç¨‹è¿›å…¥è¿è¡Œæ€ã€‚ä»£ç æ¡†æ¶å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/fork.c:

/*
 *  Ok, this is the main fork-routine.
 *
 * It copies the process, and if successful kick-starts
 * it and waits for it to finish using the VM if required.
 */
long do_fork(unsigned long clone_flags,
        unsigned long stack_start,
        unsigned long stack_size,
        int __user *parent_tidptr,
    int __user *child_tidptr)
{
    struct task_struct *p;
    long nr;

    ...

    /*åŸºäºå½“å‰è¿›ç¨‹çš„task_structå’Œclone_flagså¤åˆ¶æ–°è¿›ç¨‹*/
    p = copy_process(clone_flags, stack_start, stack_size,
                                child_tidptr, NULL, trace);
    /*
     * Do this prior waking up the new thread - the thread pointer
     * might get invalid after that point, if the thread exits quickly.
     */
    if (!IS_ERR(p)) {
        struct completion vfork;
        struct pid *pid;

        pid = get_task_pid(p, PIDTYPE_PID);
        nr = pid_vnr(pid);

        if (clone_flags &amp; CLONE_PARENT_SETTID)
            put_user(nr, parent_tidptr);

        /*å¦‚æœclone_flagsä¸­ç½®äº†CLONE_VFORKæ ‡ç½®ï¼Œåˆ™éœ€è¦åˆå§‹åŒ–ç­‰å¾…ç»“æ„ä½“*/
        if (clone_flags &amp; CLONE_VFORK) {
            p-&gt;vfork_done = &amp;vfork;
            init_completion(&amp;vfork);
            get_task_struct(p);
        }

        /*å°†æ–°åˆ›å»ºçš„è¿›ç¨‹åŠ å…¥è°ƒåº¦é˜Ÿåˆ—*/
        wake_up_new_task(p);

        ...

        /*å¯¹äºVFORKï¼Œå½“å‰è¿›ç¨‹(å³çˆ¶è¿›ç¨‹)éœ€è¦ç­‰å¾…å­è¿›ç¨‹å®Œæˆåæ‰èƒ½ç»§ç»­è¿è¡Œ*/
        if (clone_flags &amp; CLONE_VFORK) {
            if (!wait_for_vfork_done(p, &amp;vfork))
                ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);
            }

        put_pid(pid);
    } else {
        nr = PTR_ERR(p);
    }
    return nr;
}

</code></pre></div></div>

<p>â€ƒâ€ƒè¡¥å……ä¸€ä¸‹å…³äºclone_flagsæ ‡è®°çš„æ³¨é‡Šè¯´æ˜ï¼Œå»ºè®®å¤§å®¶åœ¨ä½¿ç”¨åˆ°çš„ä»£ç ä½ç½®å¤„ä»”ç»†é˜…è¯»ï¼Œä»¥åŠ æ·±ç†è§£ï¼š</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/uapi/linux/sched.h:

/*
 * cloning flags:
 */
#define CSIGNAL		0x000000ff	/* signal mask to be sent at exit */
#define CLONE_VM	0x00000100	/* set if VM shared between processes */
#define CLONE_FS	0x00000200	/* set if fs info shared between processes */
#define CLONE_FILES	0x00000400	/* set if open files shared between processes */
#define CLONE_SIGHAND	0x00000800	/* set if signal handlers and blocked signals shared */
#define CLONE_PTRACE	0x00002000	/* set if we want to let tracing continue on the child too */
#define CLONE_VFORK	0x00004000	/* set if the parent wants the child to wake it up on mm_release */
#define CLONE_PARENT	0x00008000	/* set if we want to have the same parent as the cloner */
#define CLONE_THREAD	0x00010000	/* Same thread group? */
#define CLONE_NEWNS	0x00020000	/* New namespace group? */
#define CLONE_SYSVSEM	0x00040000	/* share system V SEM_UNDO semantics */
#define CLONE_SETTLS	0x00080000	/* create a new TLS for the child */
#define CLONE_PARENT_SETTID	0x00100000	/* set the TID in the parent */
#define CLONE_CHILD_CLEARTID	0x00200000	/* clear the TID in the child */
#define CLONE_DETACHED		0x00400000	/* Unused, ignored */
#define CLONE_UNTRACED		0x00800000	/* set if the tracing process can't force CLONE_PTRACE on this clone */
#define CLONE_CHILD_SETTID	0x01000000	/* set the TID in the child */
/* 0x02000000 was previously the unused CLONE_STOPPED (Start in stopped state)
and is now available for re-use. */
#define CLONE_NEWUTS		0x04000000	/* New utsname group? */
#define CLONE_NEWIPC		0x08000000	/* New ipcs */
#define CLONE_NEWUSER		0x10000000	/* New user namespace */
#define CLONE_NEWPID		0x20000000	/* New pid namespace */
#define CLONE_NEWNET		0x40000000	/* New network namespace */
#define CLONE_IO		0x80000000	/* Clone io context */

</code></pre></div></div>

<p>â€ƒâ€ƒæ¥ä¸‹æ¥æ·±å…¥çœ‹ä¸€ä¸‹æ ¸å¿ƒå‡½æ•°copy_processï¼Œå®ƒä¸»è¦å®Œæˆäº†é¡µè¡¨å’Œå¯„å­˜å™¨å€¼çš„å¤åˆ¶ï¼Œè¿™é‡Œæˆ‘ä»¬ç•¥å»cgroupå’Œä¸€äº›éé‡ç‚¹ä»£ç ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/fork.c:

/*
 * This creates a new process as a copy of the old one,
 * but does not actually start it yet.
 *
 * It copies the registers, and all the appropriate
 * parts of the process environment (as per the clone
 * flags). The actual kick-off is left to the caller.
 */
static struct task_struct *copy_process(unsigned long clone_flags,
            unsigned long stack_start,
            unsigned long stack_size,
            int __user *child_tidptr,
            struct pid *pid,
            int trace)
{
    int retval;
    struct task_struct *p;
    
    ...
    /*åˆ†é…task_structç»“æ„å†…å­˜å’Œthread_infoé¡µï¼Œå¹¶å°†å½“å‰è¿›ç¨‹ç›¸å…³ä¿¡æ¯å¤åˆ¶åˆ°å¯¹åº”å†…å­˜å­—æ®µ*/
    retval = -ENOMEM;
    p = dup_task_struct(current);
    if (!p)
        goto fork_out;

    ...
    /* Perform scheduler related setup. Assign this task to a CPU. */
    sched_fork(p);

    ...
    /*æ–°å»ºå¹¶å¤åˆ¶task_structä¸­fileså­—æ®µï¼Œå®ƒè¡¨ç¤ºå·²æ‰“å¼€æ–‡ä»¶ï¼›
      å¦‚æœCLONE_FILESç½®ä½ï¼Œåˆ™å…±äº«å½“å‰è¿›ç¨‹çš„files*/
    retval = copy_files(clone_flags, p);

    ...
    /*æ–°å»ºå¹¶å¤åˆ¶task_structä¸­çš„fså­—æ®µï¼Œå®ƒè¡¨ç¤ºå½“å‰ç›®å½•ï¼›
      å¦‚æœCLONE_FSç½®ä½ï¼Œåˆ™å…±äº«å½“å‰è¿›ç¨‹çš„fs*/
    retval = copy_fs(clone_flags, p);

    ...
    /*å¤åˆ¶ä¿¡å·åŠä¿¡å·å¤„ç†å‡½æ•°*/
    retval = copy_sighand(clone_flags, p);
    ...
    retval = copy_signal(clone_flags, p);

    ...
    /*æ–°å»ºå¹¶å¤åˆ¶mm_structï¼Œå¹¶å®Œæˆé¡µè¡¨å¤åˆ¶ï¼›
      å¦‚æœCLONE_VMç½®ä½ï¼Œåˆ™å…±äº«å½“å‰è¿›ç¨‹çš„mm_struct*/
    retval = copy_mm(clone_flags, p);

    ...
    /*å¤åˆ¶å¯„å­˜å™¨å€¼*/
    retval = copy_thread(clone_flags, stack_start, stack_size, p);

    ...
    return p;
    ...
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)
{
    struct mm_struct *mm, *oldmm;
    int retval;

    ...
    tsk-&gt;mm = NULL;
    tsk-&gt;active_mm = NULL;

    /*
     * Are we cloning a kernel thread?
     *
     * We need to steal a active VM for that..
     */
    oldmm = current-&gt;mm;
    if (!oldmm)
        return 0;

    /*å¦‚æœCLONE_VMç½®ä½ï¼Œåˆ™å…±äº«å½“å‰è¿›ç¨‹mm_struct*/
    if (clone_flags &amp; CLONE_VM) {
        atomic_inc(&amp;oldmm-&gt;mm_users);
        mm = oldmm;
        goto good_mm;
    }

    retval = -ENOMEM;
    mm = dup_mm(tsk);
    if (!mm)
        goto fail_nomem;

good_mm:
    tsk-&gt;mm = mm;
    tsk-&gt;active_mm = mm;
    return 0;

fail_nomem:
    return retval;
}

/*
 * Allocate a new mm structure and copy contents from the
 * mm structure of the passed in task structure.
 */
struct mm_struct *dup_mm(struct task_struct *tsk)
{
    struct mm_struct *mm, *oldmm = current-&gt;mm;
    int err;

    if (!oldmm)
        return NULL;

    /*åˆ†é…mm_structå†…å­˜*/
    mm = allocate_mm();
    if (!mm)
        goto fail_nomem;
    
    /*å¤åˆ¶mm_structå†…å®¹ï¼Œè¿™é‡Œæ²¡æœ‰åŠ é”ä¿æŠ¤ï¼Œæˆ‘ç†è§£æ˜¯å› ä¸ºå…¶ä¸­å…³é”®å­—æ®µ
      ä¼šåœ¨åç»­æµç¨‹ä¸­é‡æ–°èµ‹å€¼*/
    memcpy(mm, oldmm, sizeof(*mm));
    mm_init_cpumask(mm);

    ...
    /*é‡æ–°åˆå§‹åŒ–mm_structä¸­ç›¸å…³å­—æ®µï¼Œè¿™é‡Œä¼šé‡æ–°åˆ†é…pgdè¡¨å¹¶å°†å†…æ ¸ç©ºé—´
      åœ°å€æ˜ å°„å¤åˆ¶åˆ°å…¶ä¸­*/
    if (!mm_init(mm, tsk))
        goto fail_nomem;

    if (init_new_context(tsk, mm))
        goto fail_nocontext;

    dup_mm_exe_file(oldmm, mm);

    /*å¤åˆ¶ç”¨æˆ·æ€vmaæ®µå’Œé¡µè¡¨*/
    err = dup_mmap(mm, oldmm);
    if (err)
        goto free_pt;

    ...

    return mm;

    ...
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int copy_thread(unsigned long clone_flags, unsigned long sp,
        unsigned long arg, struct task_struct *p)
{
    int err;
    struct pt_regs *childregs;
    struct task_struct *me = current;

    /*task_stack_page(p)ï¼Œå³p-&gt;stackï¼Œä¸ºthread_infoèµ·å§‹åœ°å€ï¼›åŠ ä¸ŠTHREAD_SIZE
      åä¸ºå†…æ ¸æ ˆèµ·å§‹åœ°å€*/
    p-&gt;thread.sp0 = (unsigned long)task_stack_page(p) + THREAD_SIZE;

    /*childregsæŒ‡å‘å†…æ ¸æ ˆä¸­ä¿ç•™æ‰€æœ‰å¯„å­˜å™¨åçš„åç§»ä½ç½®*/
    childregs = task_pt_regs(p);
    p-&gt;thread.sp = (unsigned long) childregs;

    /*å¤åˆ¶å½“å‰è¿›ç¨‹çš„ç”¨æˆ·æ€æ ˆæŒ‡é’ˆ*/
    p-&gt;thread.usersp = me-&gt;thread.usersp;

    /*è®¾ç½®TIF_FORKæ ‡è®°ï¼Œforkç³»ç»Ÿè°ƒç”¨è¿”å›æ—¶ç”¨æ¥åˆ¤æ–­æ˜¯å¦
      ä¸ºæ–°ç”Ÿæˆçš„è¿›ç¨‹*/
    set_tsk_thread_flag(p, TIF_FORK);
    ...

    /*å¯¹äºå†…æ ¸è¿›ç¨‹ï¼Œspä¸­ä¿å­˜çš„æ˜¯å…¥å£å‡½æ•°æŒ‡é’ˆ*/
    if (unlikely(p-&gt;flags &amp; PF_KTHREAD)) {
        /* kernel thread */
        memset(childregs, 0, sizeof(struct pt_regs));
        childregs-&gt;sp = (unsigned long)childregs;
        childregs-&gt;ss = __KERNEL_DS;
        childregs-&gt;bx = sp; /* function */
        childregs-&gt;bp = arg;
        childregs-&gt;orig_ax = -1;
        childregs-&gt;cs = __KERNEL_CS | get_kernel_rpl();
        childregs-&gt;flags = X86_EFLAGS_IF | X86_EFLAGS_FIXED;
        return 0;
    }
    
    /*å¤åˆ¶å½“å‰è¿›ç¨‹åœ¨æ‰§è¡Œforkç³»ç»Ÿè°ƒç”¨æ—¶ä¿å­˜çš„å¯„å­˜å™¨çŠ¶æ€*/
    *childregs = *current_pt_regs();

    /*å­è¿›ç¨‹çš„axå¯„å­˜å™¨èµ‹ä¸ºé›¶ï¼Œè¯¥å€¼å³forkç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼*/
    childregs-&gt;ax = 0;

    /*å¦‚æœä¼ å…¥spæŒ‡é’ˆï¼Œåˆ™æ›´æ–°forkè¿”å›åæ ˆæŒ‡é’ˆå€¼*/
    if (sp)
        childregs-&gt;sp = sp;

    ...
    return err;
}

</code></pre></div></div>

<h4 id="é›¶å·è¿›ç¨‹ä¸ä¸€å·è¿›ç¨‹"><strong>é›¶å·è¿›ç¨‹ä¸ä¸€å·è¿›ç¨‹</strong></h4>

<p>â€ƒâ€ƒç³»ç»Ÿä¸­æœ‰ä¸¤ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„è¿›ç¨‹ï¼Œå³é›¶å·å’Œä¸€å·è¿›ç¨‹ã€‚é›¶å·è¿›ç¨‹æ˜¯å†…æ ¸åˆå§‹åŒ–è¿‡ç¨‹ä¸­æœ€æ—©äº§ç”Ÿçš„è¿›ç¨‹ï¼Œæœ€ç»ˆæˆä¸ºbsp(SMPç³»ç»Ÿä¸­çš„å¯åŠ¨CPU)ä¸Šçš„idleè¿›ç¨‹(swapper)ã€‚é›¶å·è¿›ç¨‹ä¼šåˆ›å»ºä¸€å·è¿›ç¨‹ï¼Œç”±ä¸€å·è¿›ç¨‹å®Œæˆéƒ¨åˆ†åˆå§‹åŒ–åŠ¨ä½œå¹¶æ‹‰èµ·shellè¿›ç¨‹ã€‚æœ€ç»ˆä¸€å·è¿›ç¨‹æˆä¸ºæ‰€æœ‰å­¤å„¿è¿›ç¨‹çš„å›æ”¶è¿›ç¨‹è€Œé•¿æœŸå­˜åœ¨äºç³»ç»Ÿä¹‹ä¸­ã€‚</p>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2018/01/è¿›ç¨‹åˆ›å»º/">ã€è®¡ç®—å­ç³»ç»Ÿã€‘è¿›ç¨‹ç®¡ç†ä¹‹ä¸€ï¼šè¿›ç¨‹åˆ›å»º</a></p>
:ET