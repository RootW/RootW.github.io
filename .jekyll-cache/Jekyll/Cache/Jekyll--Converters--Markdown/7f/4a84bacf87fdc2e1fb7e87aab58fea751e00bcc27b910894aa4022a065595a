I"«;<p>â€ƒâ€ƒå†…æ ¸RBDé©±åŠ¨æ•´ä½“è½¯ä»¶æ ˆå¦‚ä¸‹ï¼š</p>

<div align="center">
<img src="/images/posts/ceph/rbd_4.jpg" height="400" width="600" />  
</div>

<h3 id="3-rbdå—è®¾å¤‡ioæµç¨‹åˆ†æ">3. RBDå—è®¾å¤‡IOæµç¨‹åˆ†æ</h3>

<p>â€ƒâ€ƒä¸ŠèŠ‚æˆ‘ä»¬åœ¨åˆ†ææ˜ å°„æµç¨‹æ—¶ï¼Œå·²ç»æ¶‰åŠå’ŒOSDçš„äº¤äº’ï¼Œä½†å¹¶æœªæ·±å…¥è®¨è®ºï¼Œå› æ­¤è¿™é‡Œæˆ‘ä»¬å°†é€šè¿‡IOçš„å¤„ç†æµç¨‹æ¥æ·±å…¥åˆ†æå…¶å†…éƒ¨åŸç†ã€‚</p>

<p>â€ƒâ€ƒIOæµç¨‹å¯åˆ†ä¸ºè¯·æ±‚ä¸‹å‘å’Œå“åº”è¿”å›ä¸¤ä¸ªé˜¶æ®µï¼Œæ•´ä½“è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p>
<blockquote>
  <ul>
    <li>åº”ç”¨ç¨‹åºä¸‹å‘çš„IOè¯·æ±‚åœ¨rbdå±‚è¢«è¡¨è¾¾ä¸ºä¸€ä¸ªrbd_img_requestï¼›æ¯ä¸ªrbd_img_requestä¼šè¢«åˆ’åˆ†æˆä¸€ä¸ªä¸ªä»¥4Mä¸ºç²’åº¦çš„rbd_obj_request(å…¶å®æˆ‘ä»¬åœ¨ä¸Šä¸€èŠ‚åˆ†ææ—¶å·²ç»æ¶‰åŠrbd_obj_request)ï¼Œè¿™äº›rbd_obj_requestå¯¹åº”OSDä¸­å­˜å‚¨çš„å¯¹è±¡ï¼›é€šè¿‡CRUSHç®—æ³•è®¡ç®—å‡ºå­˜å‚¨rbd_obj_requestçš„ä¸»OSDåï¼Œå°†rbd_obj_requestå°è£…æˆceph_osd_requestï¼Œæ¥ç€å°†ceph_osd_requestæ”¾å…¥ä¸€ä¸ªceph_msgä¸­å¹¶é€šè¿‡lmessengeræ¨¡å—è¿›è¡Œå‘é€ï¼›</li>
    <li>OSDè¯·æ±‚å¤„ç†å®Œæˆåå›å¤å“åº”ï¼Œmessengeræ¨¡å—é€šè¿‡ceph_msgæ¥æ”¶å“åº”æ¶ˆæ¯ï¼Œå¹¶æ‰¾åˆ°å¯¹åº”çš„ceph_osd_requestï¼Œæ¥ç€å°±è¿›è¡Œå›è°ƒçš„å¤„ç†ï¼›</li>
  </ul>
</blockquote>

<p>â€ƒâ€ƒ</p>

<div align="center">
<img src="/images/posts/ceph/rbd_io.jpg" height="400" width="600" />  
</div>

<h4 id="31-ioä¸‹å‘rbd_request_fn"><strong>3.1. IOä¸‹å‘ï¼šrbd_request_fn</strong></h4>

<p>â€ƒâ€ƒIOå¤„ç†çš„æ ¸å¿ƒå‡½æ•°æ˜¯rbd_request_fnï¼Œå…¶è°ƒç”¨æ ˆå¤§ä½“å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbd_request_fn[*]
    |-rbd_img_request_create
    |-rbd_img_request_fill
    |   |-rbd_obj_request_create
    |   |-rbd_osd_req_create
    |   |-osd_req_op_extent_osd_data_bio
    |   \-rbd_osd_req_format_write(or read)
    \-rbd_img_request_submit
        |-__register_request
        |-__map_request
        \-__send_queued
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

/*å½“åº”ç”¨å‘RBDå—è®¾å¤‡ä¸‹å‘è¯»å†™è¯·æ±‚æ—¶ï¼Œæœ€ç»ˆä¼šè°ƒç”¨è¯¥å‡½æ•°ï¼›
  qä»£è¡¨è¯·æ±‚æ‰€åœ¨çš„è¯·æ±‚é˜Ÿåˆ—*/
static void rbd_request_fn(struct request_queue *q)
__releases(q-&gt;queue_lock) __acquires(q-&gt;queue_lock)
{
    struct rbd_device *rbd_dev = q-&gt;queuedata; /*é˜Ÿåˆ—ç§æœ‰æ•°æ®ï¼Œåˆå§‹åŒ–æ—¶æŒ‡å®šï¼Œä»£è¡¨rbd_devå¯¹è±¡*/
    struct request *rq;
    int result;

    /*é€šè¿‡ä¸€ä¸ªå¤§å¾ªç¯ï¼Œä¸æ–­è°ƒç”¨blk_fetch_requestä»è¯·æ±‚é˜Ÿåˆ—ä¸­å–å‡ºå¾…å¤„ç†çš„è¯·æ±‚rq*/
    while ((rq = blk_fetch_request(q))) {
        bool write_request = rq_data_dir(rq) == WRITE; /*åˆ¤æ–­è¯·æ±‚è¯»å†™ç±»å‹*/
        struct rbd_img_request *img_request;
        u64 offset;
        u64 length;

        ...
        offset = (u64) blk_rq_pos(rq) &lt;&lt; SECTOR_SHIFT; /*è®¡ç®—è¯·æ±‚èµ·å§‹ä½ç½®ï¼Œä»æ‰‡åŒºè½¬æ¢æˆå­—èŠ‚*/
        length = (u64) blk_rq_bytes(rq); /*è·å–è¯·æ±‚å¤§å°*/
        ...

        result = -ENOMEM;
        /*é’ˆå¯¹æ¯ä¸ªrqï¼Œè¿™é‡Œä¼šç”Ÿæˆä¸€ä¸ªrbd_img_requestä¸ä¹‹å¯¹åº”ï¼›å…¶å†…éƒ¨ä¼šè®°å½•è¯·æ±‚èµ·å§‹ä½ç½®ã€é•¿åº¦å’Œè¯»å†™ç±»å‹ç­‰ä¿¡æ¯*/
        img_request = rbd_img_request_create(rbd_dev, offset, length, write_request);
        if (!img_request)
            goto end_request;
        
        /*ç»‘å®šimg_requestå’Œrqä¹‹é—´çš„å…³ç³»*/
        img_request-&gt;rq = rq;

        /*å‘img_requestä¸­å¡«å…¥bioä¿¡æ¯ï¼Œä¸‹é¢å°†å±•å¼€åˆ†æ*/
        result = rbd_img_request_fill(img_request, OBJ_REQUEST_BIO, rq-&gt;bio);
        /*å°†img_requesté€’äº¤ç»™åº•å±‚libcephè¿‡è¡Œç½‘ç»œå‘é€ï¼Œä¸‹é¢å°†å±•å¼€åˆ†æ*/
        if (!result)
            result = rbd_img_request_submit(img_request);
        ...
    }
}
</code></pre></div></div>

<h5 id="311-rbd_img_request_fill"><strong>3.1.1. rbd_img_request_fill</strong></h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbd_request_fn
    |-rbd_img_request_create
    |-rbd_img_request_fill[*]
    |   |-rbd_obj_request_create
    |   |-rbd_osd_req_create
    |   |-osd_req_op_extent_osd_data_bio
    |   \-rbd_osd_req_format_write(or read)
    \-rbd_img_request_submit
        |-__register_request
        |-__map_request
        \-__send_queued
</code></pre></div></div>

<p>â€ƒâ€ƒç”±äºæ¯ä¸ªRBDè®¾å¤‡ä¼šä»¥4Mä¸ºç²’åº¦åˆ’åˆ†æˆä¸€ä¸ªä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥å¯¹æ¯ä¸ªRBDè®¾å¤‡çš„è¯·æ±‚(image request)ä¼šè½¬æ¢æˆè‹¥å¹²å¯¹è±¡è¯·æ±‚(object request)ã€‚rbd_img_request_fillçš„ä¸»è¦ä½œç”¨å°±æ˜¯å®Œæˆimage requeståˆ°object requestçš„è½¬æ¢ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

static int rbd_img_request_fill(struct rbd_img_request *img_request,
                        enum obj_request_type type,void *data_desc)
{
    struct rbd_device *rbd_dev = img_request-&gt;rbd_dev;
    struct rbd_obj_request *obj_request = NULL;
    struct rbd_obj_request *next_obj_request;
    bool write_request = img_request_write_test(img_request); /*æ˜¯å¦ä¸ºå†™è¯·æ±‚*/
    struct bio *bio_list = 0;
    unsigned int bio_offset = 0;
    struct page **pages = 0;
    u64 img_offset;
    u64 resid;
    u16 opcode;

    
    opcode = write_request ? CEPH_OSD_OP_WRITE : CEPH_OSD_OP_READ;
    img_offset = img_request-&gt;offset; /*image requestå¯¹åº”çš„è¯·æ±‚åç§»*/
    resid = img_request-&gt;length; /*image requestå¯¹åº”çš„è¯·æ±‚é•¿åº¦*/
    rbd_assert(resid &gt; 0);

    if (type == OBJ_REQUEST_BIO) {/*è¿™é‡Œä¸»è¦è€ƒè™‘bioç±»å‹çš„è¯·æ±‚*/
        bio_list = data_desc;
        rbd_assert(img_offset == bio_list-&gt;bi_sector &lt;&lt; SECTOR_SHIFT);
    } else {
        ...
    }

    while (resid) {
        struct ceph_osd_request *osd_req;
        const char *object_name;
        u64 offset;
        u64 length;

        /*æ ¹æ®image requeståç§»ä½ç½®è®¡ç®—å¯¹è±¡åç§°*/
        object_name = rbd_segment_name(rbd_dev, img_offset);
        ...
        /*4Må¯¹è±¡å†…çš„åç§»*/
        offset = rbd_segment_offset(rbd_dev, img_offset);
        /*4Må¯¹è±¡å†…çš„é•¿åº¦*/
        length = rbd_segment_length(rbd_dev, img_offset, resid);
        /*æ–°å»ºä¸€ä¸ªobject request*/
        obj_request = rbd_obj_request_create(object_name, offset, length, type);
        /* object request has its own copy of the object name */
        rbd_segment_name_free(object_name);
        if (!obj_request)
            goto out_unwind;
        /*
         * set obj_request-&gt;img_request before creating the
         * osd_request so that it gets the right snapc
         */
        rbd_img_obj_request_add(img_request, obj_request);

        if (type == OBJ_REQUEST_BIO) {
            unsigned int clone_size;

            rbd_assert(length &lt;= (u64)UINT_MAX);
            clone_size = (unsigned int)length;
            /*å…‹éš†object requestå¯¹åº”çš„bioæ®µ*/
            obj_request-&gt;bio_list =
                bio_chain_clone_range(&amp;bio_list,
                                    &amp;bio_offset,
                                    clone_size,
                                    GFP_ATOMIC);
            ...
        } else {
            ...
        }

        /*é’ˆå¯¹object requeståˆ›å»ºåº•å±‚çš„osd request*/
        osd_req = rbd_osd_req_create(rbd_dev, write_request, obj_request);
        ...
        obj_request-&gt;osd_req = osd_req;
        obj_request-&gt;callback = rbd_img_obj_callback; /*è¯·æ±‚å¤„ç†å®Œæˆæ—¶çš„å›è°ƒ*/
        rbd_img_request_get(img_request);

        /*å°†object requestçš„bioä¿¡æ¯å¡«å…¥åˆ°osd requestçš„extentä¸­*/
        osd_req_op_extent_init(osd_req, 0, opcode, offset, length, 0, 0);
        if (type == OBJ_REQUEST_BIO)
            osd_req_op_extent_osd_data_bio(osd_req, 0, obj_request-&gt;bio_list, length);
        else
            ...

        if (write_request) /*è¿™é‡Œå°†ceph_osd_requestä¸­çš„ä¿¡æ¯å¡«å…¥åˆ°ceph_msg(r_request)ä¸­*/
            rbd_osd_req_format_write(obj_request);
        else
            rbd_osd_req_format_read(obj_request);

        obj_request-&gt;img_offset = img_offset;

        /*æ›´æ–°åç§»å’Œé•¿åº¦ï¼Œå¹¶ç»§ç»­å¾ªç¯*/
        img_offset += length; 
        resid -= length;
    }

    return 0;

    ...
}
</code></pre></div></div>

<p>â€ƒâ€ƒè¿™é‡Œæˆ‘ä»¬æ·±å…¥çœ‹çœ‹ceph_osd_requestçš„ç»“æ„å®šä¹‰ï¼Œå®ƒä½“ç°äº†OSDå¯¹å®¢æˆ·ç«¯å‘ˆç°çš„æ“ä½œæ¥å£ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/ceph/osd_client.h:

struct ceph_osd_request {
    u64             r_tid;              /* unique for this client */
    ...
    struct ceph_osd *r_osd; /*è¯·æ±‚å¯¹åº”çš„OSD*/
    ...
    struct ceph_msg  *r_request, *r_reply; /*è¯·æ±‚å¯¹åº”çš„å‘é€æ¶ˆæ¯å’Œå“åº”æ¥æ”¶æ¶ˆæ¯*/
    ...
    /* request osd ops array  */ /*æ¯ä¸ªè¯·æ±‚ç”±è‹¥å¹²æ“ä½œç»„æˆï¼Œå¦‚CEPH_OSD_OP_READ*/
    unsigned int		r_num_ops;
    struct ceph_osd_req_op	r_ops[CEPH_OSD_MAX_OP];

    ...
};

 /*OSDæä¾›äº†è®¸å¤šä¸åŒçš„æ“ä½œï¼Œå‡ä»¥CEPH_OSD_OP_æ‰“å¤´ã€‚ä¾‹å¦‚å¯¹äºè¯»è¯·æ±‚ï¼ŒåŒ…å«ä¸€ä¸ªCEPH_OSD_OP_READæ“ä½œï¼Œ
   æ“ä½œå¯¹è±¡extentä¸­ä¿å­˜å¯¹è±¡è®¿é—®çš„åç§»ã€é•¿åº¦å’Œæ•°æ®å­˜å‚¨å†…å­˜çš„ä½ç½®ä¿¡æ¯ï¼›å¯¹äºå†™è¯·æ±‚ï¼Œ
   åŒ…å«ä¸€ä¸ªCEPH_OSD_OP_WRITEï¼Œæ“ä½œå¯¹è±¡ä¹Ÿåœ¨extentä¸­*/
struct ceph_osd_req_op {
    u16 op;           /* CEPH_OSD_OP_* */
    u32 payload_len;
    union {
        struct ceph_osd_data raw_data_in;
        struct {
            u64 offset, length;
            u64 truncate_size;
            u32 truncate_seq;
            struct ceph_osd_data osd_data;
        } extent; /*CEPH_OSD_OP_READ/WRITEä¹‹ç±»çš„æ“ä½œä½¿ç”¨*/
        struct {
            const char *class_name;
            const char *method_name;
            struct ceph_osd_data request_info;
            struct ceph_osd_data request_data;
            struct ceph_osd_data response_data;
            __u8 class_len;
            __u8 method_len;
            __u8 argc;
        } cls; /*CEPH_OSD_OP_CALLæ“ä½œä½¿ç”¨*/
        struct {
            u64 cookie;
            u64 ver;
            u32 prot_ver;
            u32 timeout;
            __u8 flag;
        } watch;
    };
};

enum ceph_osd_data_type {
    CEPH_OSD_DATA_TYPE_NONE = 0,
    CEPH_OSD_DATA_TYPE_PAGES,
    CEPH_OSD_DATA_TYPE_PAGELIST,
    CEPH_OSD_DATA_TYPE_BIO,
};

/*æ•°æ®ä¿å­˜å†…å­˜ä½ç½®å¯ä»¥é€šè¿‡pageæ•°ç»„ã€pagelistå’Œbioä¸‰ç§æ–¹å¼è¡¨è¾¾*/
struct ceph_osd_data {
    enum ceph_osd_data_type	type;
    union {
        struct {
            struct page	**pages;
            u64		length;
            u32		alignment;
            bool		pages_from_pool;
            bool		own_pages;
        };
        struct ceph_pagelist	*pagelist;
        struct {
            struct bio	*bio;		/* list of bios */
            size_t		bio_length;	/* total in list */
        };
    };
};
</code></pre></div></div>

<h5 id="312-rbd_img_request_submit"><strong>3.1.2. rbd_img_request_submit</strong></h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbd_request_fn
    |-rbd_img_request_create
    |-rbd_img_request_fill
    |   |-rbd_obj_request_create
    |   |-rbd_osd_req_create
    |   |-osd_req_op_extent_osd_data_bio
    |   \-rbd_osd_req_format_write(or read)
    \-rbd_img_request_submit[*]
        |-__register_request
        |-__map_request
        \-__send_queued
</code></pre></div></div>

<p>â€ƒâ€ƒå®Œæˆobject requestå¯¹è±¡çš„æˆç”Ÿåï¼Œrbd_image_request_submitè°ƒç”¨rbd_obj_request_submitï¼Œæœ€ç»ˆæ¥åˆ°libcephä¸­çš„ceph_osdc_start_requestï¼Œå®ƒçš„ä¸»è¦ä½œç”¨å°±æ˜¯æ ¹æ®è®¿é—®å¯¹è±¡ã€OSDMapå’ŒCRUSHç®—æ³•è®¡ç®—å‡ºå¯¹è±¡æ‰€åœ¨PGå¯¹åº”çš„ä¸»OSDèŠ‚ç‚¹ï¼Œå¹¶å°†è¯¥object requestå¯¹åº”çš„osd requestçš„r_requestæ¶ˆæ¯é€šè¿‡ç½‘ç»œå‘é€ç»™è¯¥OSDå¤„ç†ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/osd_client.c:

int ceph_osdc_start_request(struct ceph_osd_client *osdc,
            struct ceph_osd_request *req, bool nofail)
{
    int rc = 0;

    down_read(&amp;osdc-&gt;map_sem);
    mutex_lock(&amp;osdc-&gt;request_mutex);
    /*å°†è¯¥osdè¯·æ±‚æ·»åŠ åˆ°osdcä¸­*/
    __register_request(osdc, req);
    req-&gt;r_sent = 0;
    req-&gt;r_got_reply = 0;
    /*é€šè¿‡CRUSHç®—æ³•åŠOSDMapæ˜ å°„å½“å‰osdè¯·æ±‚åˆ°OSDèŠ‚ç‚¹ï¼Œæœ‰å…³CRUSHçš„åŸç†å¯ä»¥å‚è€ƒç›¸å…³è®ºæ–‡*/
    rc = __map_request(osdc, req, 0);
    if (rc &lt; 0) {
        ...
    }
    if (req-&gt;r_osd == NULL) {
        dout("send_request %p no up osds in pg\n", req);
        ceph_monc_request_next_osdmap(&amp;osdc-&gt;client-&gt;monc);
    } else {
        /*å°†è¯¥è¯·æ±‚å‘é€ç»™OSDèŠ‚ç‚¹*/
        __send_queued(osdc);
    }
    rc = 0;
out_unlock:
    mutex_unlock(&amp;osdc-&gt;request_mutex);
    up_read(&amp;osdc-&gt;map_sem);
    return rc;
}
</code></pre></div></div>

<h4 id="32-ioè¿”å›"><strong>3.2. IOè¿”å›</strong></h4>

<p>â€ƒâ€ƒIOè¯·æ±‚é€šè¿‡ç½‘ç»œå‘é€ç»™OSDèŠ‚ç‚¹åï¼ŒOSDèŠ‚ç‚¹åœ¨å¤„ç†å®Œæˆåä¼šå›å¤å“åº”ï¼Œå“åº”çš„å¤„ç†é€»è¾‘åœ¨å®¢æˆ·ç«¯åˆ›å»ºOSDå¯¹è±¡æ—¶æŒ‡å®šï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/osd_client.c:

static struct ceph_osd *create_osd(struct ceph_osd_client *osdc, int onum)
{
    struct ceph_osd *osd;

    osd = kzalloc(sizeof(*osd), GFP_NOFS);
    if (!osd)
        return NULL;

    atomic_set(&amp;osd-&gt;o_ref, 1);
    osd-&gt;o_osdc = osdc;
    osd-&gt;o_osd = onum;
    RB_CLEAR_NODE(&amp;osd-&gt;o_node);
    INIT_LIST_HEAD(&amp;osd-&gt;o_requests);
    INIT_LIST_HEAD(&amp;osd-&gt;o_linger_requests);
    INIT_LIST_HEAD(&amp;osd-&gt;o_osd_lru);
    osd-&gt;o_incarnation = 1;

    ceph_con_init(&amp;osd-&gt;o_con, osd, &amp;osd_con_ops, &amp;osdc-&gt;client-&gt;msgr);

    INIT_LIST_HEAD(&amp;osd-&gt;o_keepalive_item);
    return osd;
}

static const struct ceph_connection_operations osd_con_ops = {
    .get = get_osd_con,
    .put = put_osd_con,
    .dispatch = dispatch, /*æ¶ˆæ¯å¤„ç†é€»è¾‘*/
    .get_authorizer = get_authorizer,
    .verify_authorizer_reply = verify_authorizer_reply,
    .invalidate_authorizer = invalidate_authorizer,
    .alloc_msg = alloc_msg,
    .fault = osd_reset,
};

static void dispatch(struct ceph_connection *con, struct ceph_msg *msg)
{
    struct ceph_osd *osd = con-&gt;private;
    struct ceph_osd_client *osdc;
    int type = le16_to_cpu(msg-&gt;hdr.type);

    if (!osd)
        goto out;
    osdc = osd-&gt;o_osdc;

    switch (type) {
    case CEPH_MSG_OSD_MAP:
        ceph_osdc_handle_map(osdc, msg);
        break;
    case CEPH_MSG_OSD_OPREPLY:
        handle_reply(osdc, msg, con);
        break;
    case CEPH_MSG_WATCH_NOTIFY:
        handle_watch_notify(osdc, msg);
        break;

    default:
        pr_err("received unknown message type %d %s\n", type,
        ceph_msg_type_name(type));
    }
out:
    ceph_msg_put(msg);
}
</code></pre></div></div>

<p>â€ƒâ€ƒåœ¨handle_replyä¸­ä¼šä»osd requeståˆ°object requestï¼Œå†åˆ°image requestï¼Œå±‚å±‚è°ƒç”¨å›è°ƒå¹¶å¤„ç†å·²ç»ç»“æŸçš„IOè¯·æ±‚ã€‚</p>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2018/01/RBD-client-3/">ã€Rados Block Deviceã€‘å››ã€Clientå†…æ ¸RBDé©±åŠ¨åˆ†æï¼è®¾å¤‡IOæµç¨‹</a></p>
:ET