I"Õ.<p>â€ƒâ€ƒé€šè¿‡å®šæ—¶å™¨ï¼Œæˆ‘ä»¬å¯ä»¥æ§åˆ¶è®¡ç®—æœºåœ¨å°†æ¥æŒ‡å®šçš„æŸä¸ªæ—¶åˆ»æ‰§è¡Œç‰¹å®šçš„åŠ¨ä½œã€‚ä¼ ç»Ÿçš„å®šæ—¶å™¨ï¼Œä»¥æ—¶é’Ÿæ»´ç­”(jiffy)ä½œä¸ºè®¡æ—¶å•ä½ï¼Œå› æ­¤å®ƒçš„ç²¾åº¦è¾ƒä½(ä¾‹å¦‚HZ=1000æ—¶ï¼Œç²¾åº¦ä¸º1æ¯«ç§’)ï¼Œæˆ‘ä»¬ä¹Ÿç§°ä¹‹ä¸ºä½ç²¾åº¦å®šæ—¶å™¨ã€‚</p>

<h3 id="1-åˆå§‹åŒ–å®šæ—¶å™¨">1. åˆå§‹åŒ–å®šæ—¶å™¨</h3>

<p>â€ƒâ€ƒæˆ‘ä»¬åœ¨æ¦‚è¿°ä¸­ä»‹ç»è¿‡ï¼Œå†…æ ¸ä¸­é€šè¿‡init_timerå¯¹å®šæ—¶å™¨è¿›è¡Œåˆå§‹åŒ–ï¼Œå®šæ—¶å™¨ä¸­æœ€å…³é”®çš„ä¸‰ä¸ªä¿¡æ¯æ˜¯ï¼šåˆ°æœŸæ—¶é—´ã€åˆ°æœŸå¤„ç†å‡½æ•°ã€åˆ°æœŸå¤„ç†å‡½æ•°çš„å‚æ•°ã€‚init_timerå®åŠå®šæ—¶å™¨ç»“æ„struct timer_list(å–åstruct timerå¯èƒ½æ›´åˆé€‚)çš„å®šä¹‰å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/timer.h:

#define init_timer(timer)                       \
    __init_timer((timer), 0)

#define __init_timer(_timer, _flags)            \
    init_timer_key((_timer), (_flags), NULL, NULL)

struct timer_list {
    /*
     * All fields that change during normal runtime grouped to the
     * same cacheline
     */
    struct list_head entry; /*ç”¨äºå°†å½“å‰å®šæ—¶å™¨æŒ‚åˆ°CPUçš„tvec_baseé“¾è¡¨ä¸­*/
    unsigned long expires; /*å®šæ—¶å™¨åˆ°æœŸæ—¶é—´*/
    struct tvec_base *base; /*å®šæ—¶å™¨æ‰€å±çš„tvec_base*/

    void (*function)(unsigned long); /*åˆ°æœŸå¤„ç†å‡½æ•°*/
    unsigned long data; /*åˆ°æœŸå¤„ç†å‡½æ•°çš„å‚æ•°*/

    int slack; /*å…è®¸çš„åå·®å€¼*/

    ...
};
</code></pre></div></div>

<p>â€ƒâ€ƒinit_timer_keyå®ç°æ—¶ï¼Œä¼šå°†å®šæ—¶å™¨æŒ‡å‘æ‰§è¡Œåˆå§‹åŒ–åŠ¨ä½œçš„CPUçš„tvec_baseç»“æ„ã€‚å†…æ ¸ä¸ºæ¯ä¸ªCPUåˆ†é…ä¸€ä¸ªstruct tvec_baseå¯¹è±¡ï¼Œç”¨æ¥è®°å½•æ¯ä¸ªCPUä¸Šå®šæ—¶å™¨ç›¸å…³çš„å…¨å±€ä¿¡æ¯(æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€èŠ‚è¯¦ç»†è¯´æ˜)ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/timer.c:

/**
 * init_timer_key - initialize a timer
 * @timer: the timer to be initialized
 * @flags: timer flags
 * @name: name of the timer
 * @key: lockdep class key of the fake lock used for tracking timer
 *       sync lock dependencies
 *
 * init_timer_key() must be done to a timer prior calling *any* of the
 * other timer functions.
 */
void init_timer_key(struct timer_list *timer, unsigned int flags,
    const char *name, struct lock_class_key *key)
{
    debug_init(timer);
    do_init_timer(timer, flags, name, key);
}

static void do_init_timer(struct timer_list *timer, unsigned int flags,
    const char *name, struct lock_class_key *key)
{
    struct tvec_base *base = __raw_get_cpu_var(tvec_bases);

    timer-&gt;entry.next = NULL;
    timer-&gt;base = (void *)((unsigned long)base | flags);
    timer-&gt;slack = -1;
    ...
}

struct tvec_base {
    spinlock_t lock; /*åŒæ­¥å½“å‰tvec_baseçš„é“¾è¡¨æ“ä½œ*/
    struct timer_list *running_timer; /*æ­£åœ¨è¿è¡Œ(åˆ°æœŸè§¦å‘)çš„å®šæ—¶å™¨*/
    unsigned long timer_jiffies; /*ç”¨äºåˆ¤æ–­å®šæ—¶å™¨æ˜¯å¦åˆ°æœŸçš„å½“å‰æ—¶é—´ï¼Œé€šå¸¸å’Œç³»ç»Ÿçš„jiffieså€¼ç›¸ç­‰*/
    unsigned long next_timer; /*ä¸‹ä¸€ä¸ªåˆ°æœŸçš„å®šæ—¶å™¨çš„åˆ°æœŸæ—¶é—´*/
    unsigned long active_timers; /*æ¿€æ´»çš„å®šæ—¶å™¨çš„ä¸ªæ•°*/
    struct tvec_root tv1; /*tv1~tv5æ˜¯ç”¨äºä¿å­˜å·²æ·»åŠ å®šæ—¶å™¨çš„é“¾è¡¨ï¼Œä¹Ÿç§°ä¸ºæ—¶é—´è½®*/
    struct tvec tv2;
    struct tvec tv3;
    struct tvec tv4;
    struct tvec tv5;
} ____cacheline_aligned;

/*
 * per-CPU timer vector definitions:
 */
#define TVN_BITS (CONFIG_BASE_SMALL ? 4 : 6)
#define TVR_BITS (CONFIG_BASE_SMALL ? 6 : 8)
#define TVN_SIZE (1 &lt;&lt; TVN_BITS)
#define TVR_SIZE (1 &lt;&lt; TVR_BITS)
#define TVN_MASK (TVN_SIZE - 1)
#define TVR_MASK (TVR_SIZE - 1)
#define MAX_TVAL ((unsigned long)((1ULL &lt;&lt; (TVR_BITS + 4*TVN_BITS)) - 1))

struct tvec {
    struct list_head vec[TVN_SIZE];
};

struct tvec_root {
    struct list_head vec[TVR_SIZE];
};
</code></pre></div></div>

<h3 id="2-æ·»åŠ å®šæ—¶å™¨">2. æ·»åŠ å®šæ—¶å™¨</h3>

<p>â€ƒâ€ƒadd_timerå°†å®šæ—¶å™¨æ·»åŠ åˆ°æ‰§è¡ŒCPUçš„tvec_baseçš„æ—¶é—´è½®é“¾è¡¨ä¸­ã€‚å†…æ ¸æ ¹æ®å®šæ—¶å™¨åˆ°æœŸæ—¶é—´ä¸å½“å‰æ—¶é—´jiffiesçš„å·®å€¼(å€¼è¶Šå°è¯´æ˜åˆ°æœŸæ—¶é—´è¶Šæ—©)ï¼Œå°†å®šæ—¶å™¨åˆ†åˆ«æŒ‚åˆ°äº”ä¸ªçº§åˆ«çš„é“¾è¡¨æ•°ç»„ï¼Œçº§åˆ«è¶Šä½é“¾è¡¨åˆ°æœŸæ—¶é—´è¶Šæ—©ï¼Œå¦‚ä¸‹è¡¨æ‰€ç¤ºï¼š</p>

<table>
  <thead>
    <tr>
      <th>é“¾è¡¨æ•°ç»„</th>
      <th>æ—¶é—´å·®</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>tv1</td>
      <td>0-255(2^8)</td>
    </tr>
    <tr>
      <td>tv2</td>
      <td>256â€“16383(2^14)</td>
    </tr>
    <tr>
      <td>tv3</td>
      <td>16384â€“1048575(2^20)</td>
    </tr>
    <tr>
      <td>tv4</td>
      <td>1048576â€“67108863(2^26)</td>
    </tr>
    <tr>
      <td>tv5</td>
      <td>67108864â€“4294967295(2^32)</td>
    </tr>
  </tbody>
</table>

<p>â€ƒâ€ƒå…¶ä¸­tv1çš„æ•°ç»„å¤§å°ä¸ºTVR_SIZEï¼Œ tv2 tv3 tv4 tv5çš„æ•°ç»„å¤§å°ä¸ºTVN_SIZEï¼Œæ ¹æ®CONFIG_BASE_SMALLé…ç½®é¡¹çš„ä¸åŒï¼Œå®ƒä»¬æœ‰ä¸åŒçš„å¤§å°ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ²¡æœ‰ä½¿èƒ½CONFIG_BASE_SMALLï¼ŒTVR_SIZEçš„å¤§å°æ˜¯256ï¼ŒTVN_SIZEçš„å¤§å°åˆ™æ˜¯64ï¼Œå½“éœ€è¦èŠ‚çœå†…å­˜ç©ºé—´æ—¶ï¼Œä¹Ÿå¯ä»¥ä½¿èƒ½CONFIG_BASE_SMALLï¼Œè¿™æ—¶TVR_SIZEçš„å¤§å°æ˜¯64ï¼ŒTVN_SIZEçš„å¤§å°åˆ™æ˜¯16ï¼Œä»¥ä¸‹çš„è®¨è®ºæˆ‘éƒ½æ˜¯åŸºäºæ²¡æœ‰ä½¿èƒ½CONFIG_BASE_SMALLçš„æƒ…å†µã€‚å½“æœ‰ä¸€ä¸ªæ–°çš„å®šæ—¶å™¨è¦åŠ å…¥æ—¶ï¼Œç³»ç»Ÿæ ¹æ®å®šæ—¶å™¨åˆ°æœŸçš„jiffieså€¼å’Œtimer_jiffieså­—æ®µçš„å·®å€¼æ¥å†³å®šè¯¥å®šæ—¶å™¨è¢«æ”¾å…¥tv1è‡³tv5ä¸­çš„å“ªä¸€ä¸ªæ•°ç»„ä¸­ï¼Œæœ€ç»ˆï¼Œç³»ç»Ÿä¸­æ‰€æœ‰çš„å®šæ—¶å™¨çš„ç»„ç»‡ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p>

<div align="center">
<img src="/images/posts/i440fx/timer_2.jpg" height="350" width="500" />  
</div>

<p>â€ƒâ€ƒä»add_timerä»£ç å®ç°ä¸Šçœ‹ï¼Œæœ€ç»ˆä¼šè°ƒç”¨__internal_add_timerå¹¶æ ¹æ®æ—¶é—´å·®å°†å®šæ—¶å™¨åŠ å…¥åˆ°åˆé€‚çš„é“¾è¡¨ä¸­ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/timer.c:

static void
__internal_add_timer(struct tvec_base *base, struct timer_list *timer)
{
    unsigned long expires = timer-&gt;expires;
    unsigned long idx = expires - base-&gt;timer_jiffies; /*idxå³ä¸ºæ—¶é—´å·®*/
    struct list_head *vec;

    if (idx &lt; TVR_SIZE) {
        int i = expires &amp; TVR_MASK; /*ä»¥è¶…æ—¶æ—¶é—´(è€Œéæ—¶é—´å·®idx)ä½œä¸ºç´¢å¼•å¯»æ‰¾å¯¹åº”çš„é“¾è¡¨ï¼Œæ–¹ä¾¿åç»­çš„è¶…æ—¶å¤„ç†*/
        vec = base-&gt;tv1.vec + i;
    } else if (idx &lt; 1 &lt;&lt; (TVR_BITS + TVN_BITS)) {
        int i = (expires &gt;&gt; TVR_BITS) &amp; TVN_MASK;
        vec = base-&gt;tv2.vec + i;
    } else if (idx &lt; 1 &lt;&lt; (TVR_BITS + 2 * TVN_BITS)) {
        int i = (expires &gt;&gt; (TVR_BITS + TVN_BITS)) &amp; TVN_MASK;
        vec = base-&gt;tv3.vec + i;
    } else if (idx &lt; 1 &lt;&lt; (TVR_BITS + 3 * TVN_BITS)) {
        int i = (expires &gt;&gt; (TVR_BITS + 2 * TVN_BITS)) &amp; TVN_MASK;
        vec = base-&gt;tv4.vec + i;
    } else if ((signed long) idx &lt; 0) {
        /*
         * Can happen if you add a timer with expires == jiffies,
         * or you set a timer to go off in the past
         */
        vec = base-&gt;tv1.vec + (base-&gt;timer_jiffies &amp; TVR_MASK);
    } else {
        int i;
        /* If the timeout is larger than MAX_TVAL (on 64-bit
         * architectures or with CONFIG_BASE_SMALL=1) then we
         * use the maximum timeout.
         */
        if (idx &gt; MAX_TVAL) {
            idx = MAX_TVAL;
            expires = idx + base-&gt;timer_jiffies;
        }
        i = (expires &gt;&gt; (TVR_BITS + 3 * TVN_BITS)) &amp; TVN_MASK;
        vec = base-&gt;tv5.vec + i;
    }
    /*
     * Timers are FIFO:
     */
    list_add_tail(&amp;timer-&gt;entry, vec);
}
</code></pre></div></div>

<h3 id="3-è§¦å‘å®šæ—¶å™¨">3. è§¦å‘å®šæ—¶å™¨</h3>

<p>â€ƒâ€ƒåœ¨æ—¶é’Ÿä¸­æ–­éƒ¨åˆ†ï¼Œæˆ‘ä»¬æåˆ°è¿‡æ¯æ¬¡ä¸­æ–­å¤„ç†æ—¶éƒ½ä¼šè°ƒç”¨run_local_timersè¿›è¡Œæœ¬åœ°å®šæ—¶å™¨çš„å¤„ç†ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/timer.c:

/*
 * Called by the local, per-CPU timer interrupt on SMP.
 */
void run_local_timers(void)
{
    ...
    raise_softirq(TIMER_SOFTIRQ); /*æœ€ç»ˆåœ¨ä¸­æ–­è¿”å›æ—¶è¿›å…¥è½¯ä¸­æ–­å¤„ç†å‡½æ•°run_timer_softirq*/
}

/*
 * This function runs timers and the timer-tq in bottom half context.
 */
static void run_timer_softirq(struct softirq_action *h)
{
    struct tvec_base *base = __this_cpu_read(tvec_bases);

    ...

    if (time_after_eq(jiffies, base-&gt;timer_jiffies)) /*å®é™…å½“å‰æ—¶é—´æ™šäºbaseä¸­è®°å½•çš„å½“å‰æ—¶é—´ï¼Œè¯´æ˜éœ€è¦æ›´æ–°baseä¸­æ—¶é—´æˆ–è€…æœ‰å®šæ—¶å™¨åˆ°æœŸ*/
        __run_timers(base);
}
</code></pre></div></div>

<p>â€ƒâ€ƒå®šæ—¶å™¨çš„åˆ°æœŸå¤„ç†é€»è¾‘ä¸­ï¼Œæ€»æ˜¯å…ˆå¤„ç†tv1ä¸­çš„å®šæ—¶å™¨ï¼Œå¦‚æœtv1ä¸­æ‰€æœ‰çš„é“¾è¡¨ä¸ºç©ºï¼Œå†ä»tv2ä¸­ç§»åŠ¨é“¾è¡¨å¹¶é‡æ–°æ·»åŠ åˆ°tv1ä¸­ï¼›å¦‚æœtv1å’Œtv2ä¸­ä¸ºç©ºï¼Œå†ä»tv3ä¸­ç§»åŠ¨é“¾è¡¨é‡æ–°æ·»åŠ åˆ°tv1å’Œtv2ä¸­ï¼›ä¾æ­¤ç±»æ¨ã€‚ä»£ç å®ç°å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/timer.c:

/**
 * __run_timers - run all expired timers (if any) on this CPU.
 * @base: the timer vector to be processed.
 *
 * This function cascades all vectors and executes all expired timer
 * vectors.
 */
static inline void __run_timers(struct tvec_base *base)
{
    struct timer_list *timer;

    spin_lock_irq(&amp;base-&gt;lock);
    while (time_after_eq(jiffies, base-&gt;timer_jiffies)) {
        struct list_head work_list;
        struct list_head *head = &amp;work_list;
        int index = base-&gt;timer_jiffies &amp; TVR_MASK; /*ä»¥baseä¸­çš„å½“å‰æ—¶é—´ä¸ºç´¢å¼•å–å‡ºå·²åˆ°æœŸçš„å®šæ—¶å™¨*/

        /*
         * Cascade timers:
         */
        /*å¦‚æœä½çº§é“¾è¡¨ä¸ºç©ºï¼Œåˆ™ä»é«˜çº§åˆ«é“¾è¡¨ä¸­ç§»åŠ¨æ·»åŠ åˆ°ä½çº§åˆ«ä¸­*/
        if (!index &amp;&amp;
            (!cascade(base, &amp;base-&gt;tv2, INDEX(0))) &amp;&amp;
            (!cascade(base, &amp;base-&gt;tv3, INDEX(1))) &amp;&amp;
            !cascade(base, &amp;base-&gt;tv4, INDEX(2)))
                cascade(base, &amp;base-&gt;tv5, INDEX(3));
        ++base-&gt;timer_jiffies; /*ç´¯åŠ baseä¸­å½“å‰æ—¶é—´*/
        list_replace_init(base-&gt;tv1.vec + index, &amp;work_list);
        /*å¤„ç†å·²åˆ°æœŸçš„å®šæ—¶æœŸçš„å›è°ƒå‡½æ•°*/
        while (!list_empty(head)) {
            void (*fn)(unsigned long);
            unsigned long data;
            bool irqsafe;

            timer = list_first_entry(head, struct timer_list,entry);
            fn = timer-&gt;function;
            data = timer-&gt;data;
            irqsafe = tbase_get_irqsafe(timer-&gt;base);

            timer_stats_account_timer(timer);

            base-&gt;running_timer = timer;
            detach_expired_timer(timer, base);

            if (irqsafe) {
                spin_unlock(&amp;base-&gt;lock);
                call_timer_fn(timer, fn, data);
                spin_lock(&amp;base-&gt;lock);
            } else {
                spin_unlock_irq(&amp;base-&gt;lock);
                call_timer_fn(timer, fn, data);
                spin_lock_irq(&amp;base-&gt;lock);
            }
        }
    }
    base-&gt;running_timer = NULL;
    spin_unlock_irq(&amp;base-&gt;lock);
}

#define INDEX(N) ((base-&gt;timer_jiffies &gt;&gt; (TVR_BITS + (N) * TVN_BITS)) &amp; TVN_MASK)

static int cascade(struct tvec_base *base, struct tvec *tv, int index)
{
    /* cascade all the timers from tv up one level */
    struct timer_list *timer, *tmp;
    struct list_head tv_list;

    list_replace_init(tv-&gt;vec + index, &amp;tv_list);

    /*
     * We are removing _all_ timers from the list, so we
     * don't have to detach them individually.
     */
    list_for_each_entry_safe(timer, tmp, &amp;tv_list, entry) {
        BUG_ON(tbase_get_base(timer-&gt;base) != base);
        /* No accounting, while moving them */
        __internal_add_timer(base, timer);
    }

    return index;
}
</code></pre></div></div>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2018/02/ä½ç²¾åº¦å®šæ—¶å™¨/">ã€æ—¶é—´å­ç³»ç»Ÿã€‘å››ã€ä½ç²¾åº¦å®šæ—¶å™¨</a></p>
:ET