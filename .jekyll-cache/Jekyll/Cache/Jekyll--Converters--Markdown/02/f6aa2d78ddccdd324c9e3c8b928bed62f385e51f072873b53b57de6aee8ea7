I"}»<p>â€ƒâ€ƒå†…æ ¸RBDé©±åŠ¨æ•´ä½“è½¯ä»¶æ ˆå¦‚ä¸‹ï¼š</p>

<div align="center">
<img src="/images/posts/ceph/rbd_4.jpg" height="400" width="600" />  
</div>

<p>â€ƒâ€ƒrbdå·¥å…·é€šè¿‡mapå­å‘½ä»¤æ˜ å°„äº§ç”Ÿä¸€ä¸ªå¯ä½¿ç”¨çš„å†…æ ¸å—è®¾å¤‡ï¼Œå…¶æœ¬è´¨åŸç†æ˜¯ç”±rbdå·¥å…·å¾€sysfs(â€œ/sys/bus/rbd/addâ€)å†…æ ¸æ–‡ä»¶æ¥å£ä¸­å†™å…¥å¾…åˆ›å»ºå—è®¾å¤‡çš„ä¿¡æ¯(ä¾‹å¦‚å‰æ–‡å®ä¾‹å†™å…¥çš„å†…å®¹ä¸ºâ€9.22.115.154:6789 name=amdin,key=client, wbpool wb -â€œï¼Œå…¶ä¸­9.22.115.154ä¸ºä¸»monitorçš„IP)ï¼Œå†…æ ¸åœ¨å¤„ç†è¿™ä¸ªå†™å…¥è¯·æ±‚æ—¶ä¼šè°ƒç”¨ç”±RBDé©±åŠ¨äº‹å…ˆæ³¨å†Œå¥½çš„å¤„ç†å‡½æ•°æ¥ç”Ÿæˆä¸€ä¸ªå†…æ ¸å—è®¾å¤‡å¯¹è±¡ã€‚</p>

<h3 id="2-rbdå—è®¾å¤‡æ˜ å°„æµç¨‹åˆ†æ">2. RBDå—è®¾å¤‡æ˜ å°„æµç¨‹åˆ†æ</h3>

<p>â€ƒâ€ƒæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹rbdæ¨¡å—åŠ è½½åˆå§‹åŒ–æ—¶å®Œæˆäº†å“ªäº›åˆå§‹åŒ–åŠ¨ä½œï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

static int __init rbd_init(void)
{
    int rc;

    /*é¦–å…ˆæ£€æŸ¥rbdé©±åŠ¨ä¾èµ–çš„åº•å±‚libcephé©±åŠ¨çš„å…¼å®¹æ€§*/
    if (!libceph_compatible(NULL)) {
        rbd_warn(NULL, "libceph incompatibility (quitting)");

        return -EINVAL;
    }

    /*åˆå§‹åŒ–rbdé©±åŠ¨ä¸­ä½¿ç”¨çš„å†…å­˜åˆ†é…å™¨*/
    rc = rbd_slab_init();
    if (rc)
        return rc;

    /*sysfsæ–‡ä»¶æ¥å£åˆå§‹åŒ–ï¼Œä¸ºç”¨æˆ·æ€rbdå·¥å…·æš´éœ²è®¿é—®æ¥å£*/
    rc = rbd_sysfs_init();
    if (rc)
        rbd_slab_exit();
    else
    pr_info("loaded " RBD_DRV_NAME_LONG "\n");

    return rc;
}

module_init(rbd_init);
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

/*
 * create control files in sysfs
 * /sys/bus/rbd/...
 */
static int rbd_sysfs_init(void)
{
    int ret;

    ret = device_register(&amp;rbd_root_dev);
    if (ret &lt; 0)
        return ret;

    /*æ ¹æ®rbd_bus_typeå®šä¹‰çš„ä¿¡æ¯åœ¨/sys/bus/ä¸‹ç”Ÿæˆå­ç›®å½•*/
    ret = bus_register(&amp;rbd_bus_type);
    if (ret &lt; 0)
        device_unregister(&amp;rbd_root_dev);

    return ret;
}

static struct bus_attribute rbd_bus_attrs[] = {
    __ATTR(add, S_IWUSR, NULL, rbd_add), /*å¯¹rbdç›®å½•ä¸‹çš„addæ–‡ä»¶è¿›è¡Œå†™æ“ä½œæ—¶å°†è°ƒç”¨rbd_add*/
    __ATTR(remove, S_IWUSR, NULL, rbd_remove), /*å¯¹rbdç›®å½•ä¸‹çš„removeæ–‡ä»¶è¿›è¡Œå†™æ“ä½œæ—¶å°†è°ƒç”¨rbd_remove*/
    __ATTR_NULL
};

static struct bus_type rbd_bus_type = {
    .name		= "rbd", /* /sys/bus/æˆç”Ÿçš„å­ç›®å½•å */
    .bus_attrs	= rbd_bus_attrs,
};

</code></pre></div></div>

<p>â€ƒâ€ƒä¸‹é¢æˆ‘ä»¬é¡ºç€æœ¬æ–‡å¼€å¤´ç»™å‡ºçš„è½¯ä»¶æ ˆä»ä¸Šè‡³ä¸‹(rbd-&gt;libceph)æ·±å…¥åˆ†ærbd_addå‡½æ•°ï¼Œçœ‹çœ‹å†…æ ¸RBDé©±åŠ¨æ˜¯å¦‚ä½•è¿›è¡Œå—è®¾å¤‡çš„ç”Ÿæˆçš„ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

/*ç”¨æˆ·æ€å·¥å…·å¾€/sys/bus/rbd/addä¸­å†™å…¥RBDè®¾å¤‡ä¿¡æ¯ï¼Œå†…æ ¸åœ¨å¤„ç†è¯¥å†™å…¥è¯·æ±‚æ—¶å°±ä¼š
  è°ƒç”¨è¿™é‡Œçš„rbd_addï¼Œå…¶ä¸­buså°±æ˜¯/sys/bus/rbdå¯¹è±¡ï¼Œbufä¸­å­˜æ”¾ç”¨æˆ·æ€å·¥å…·å†™å…¥çš„
  å­—ç¬¦ä¸²ï¼Œå¦‚"9.22.115.154:6789 name=amdin,key=client, wbpool wb -"ï¼Œ
  countä¸ºå†™å…¥çš„å­—ç¬¦ä¸²é•¿åº¦*/

static ssize_t rbd_add(struct bus_type *bus,
                const char *buf, size_t count)
{
    struct rbd_device *rbd_dev = NULL;
    struct ceph_options *ceph_opts = NULL;
    struct rbd_options *rbd_opts = NULL;
    struct rbd_spec *spec = NULL;
    struct rbd_client *rbdc;
    struct ceph_osd_client *osdc;
    bool read_only;
    int rc = -ENOMEM;

    ...

    /*é¦–å…ˆå¯¹ç”¨æˆ·æ€å†™å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œè§£æï¼Œç»“æœè¿”å›åˆ°ceph_optsï¼Œrbd_optå’Œspecä¸­ï¼š
      (1)ceph_optsä¸­ä¿å­˜cephé›†ç¾¤ç›¸å…³ä¿¡æ¯ï¼Œé’ˆå¯¹å‰æ–‡ç¤ºä¾‹ï¼Œceph_opts.mon_addrä¸­å°†ä¿å­˜
         "9.22.115.154:6789"ï¼›ceph_opts.nameä¸º"admin"ï¼Œä»£è¡¨è®¿é—®cephé›†ç¾¤çš„è§’è‰²åç§°ï¼›
         ceph_opts.keyå¯¹åº”ç³»ç»Ÿé…ç½®ä¸­çš„"ceph.client.admin.keyring"ï¼Œä¸ºç™»é™†å¯†é’¥ã€‚
      (2)rbd_optä¸­åŒ…å«å½“å‰rbdè®¾å¤‡æ˜¯å¦åªè¯»ï¼Œé’ˆå¯¹å‰æ–‡ç¤ºä¾‹ï¼Œrbd_opt.read_onlyä¸ºfalseã€‚
      (3)specä¸­åŒ…å«å½“å‰rbdè®¾å¤‡çš„è¯¦ç»†æè¿°ä¿¡æ¯ï¼Œé’ˆå¯¹ç¤ºä¾‹ï¼Œspec.pool_nameä¸º"wb_pool"ï¼Œ
         spec.image_nameä¸º"wb"ï¼Œspec.snap_nameä¸º"-"ï¼Œè¡¨ç¤ºæ— å¿«ç…§*/

    /* parse add command */
    rc = rbd_add_parse_args(buf, &amp;ceph_opts, &amp;rbd_opts, &amp;spec);
    if (rc &lt; 0)
        goto err_out_module;
    read_only = rbd_opts-&gt;read_only;
    kfree(rbd_opts);
    rbd_opts = NULL;	/* done with this */

    /*æ¥ç€æ ¹æ®cephé›†ç¾¤é…ç½®ceph_optsåœ¨å½“å‰å®¢æˆ·ç«¯æŸ¥æ‰¾æ˜¯å¦å·²ç”Ÿæˆrbd_client(å¯¹åº”ä¸€ä¸ªceph_clientï¼Œ
      å†…éƒ¨åŒ…å«mon_clientå’Œosd_client)ï¼›å¦‚æœæœªæ‰¾åˆ°åˆ™ç”Ÿæˆä¸€ä¸ªæ–°çš„rbd_clientï¼Œå¹¶å»ºç«‹ä¼šè¯(å®Œæˆè®¤è¯ã€è·
      å–monmapå’Œosdmapç­‰ä¸€ç³»ç»Ÿåˆå§‹åŒ–åŠ¨ä½œ)*/
    rbdc = rbd_get_client(ceph_opts);
    if (IS_ERR(rbdc)) {
        rc = PTR_ERR(rbdc);
        goto err_out_args;
    }

    /*ä»cephé›†ç¾¤è¿”å›çš„osdmapä¸­è·å–å½“å‰poolå¯¹åº”çš„id*/
    /* pick the pool */
    osdc = &amp;rbdc-&gt;client-&gt;osdc;
    rc = ceph_pg_poolid_by_name(osdc-&gt;osdmap, spec-&gt;pool_name);
    if (rc &lt; 0)
        goto err_out_client;
    spec-&gt;pool_id = (u64)rc;

    ...

    /*åˆ›å»ºå†…æ ¸ä¸­çš„rbd_devå¯¹è±¡*/
    rbd_dev = rbd_dev_create(rbdc, spec);
    if (!rbd_dev)
        goto err_out_client;
    rbdc = NULL;		/* rbd_dev now owns this */
    spec = NULL;		/* rbd_dev now owns this */

    /*ä»cephé›†ç¾¤ä¸­æŸ¥è¯¢å½“å‰rbdè®¾å¤‡(image)çš„å…ƒæ•°æ®ä¿¡æ¯ï¼Œå³ä»rbd_id.[rbdè®¾å¤‡å]ä¸­è·çŸ¥image idï¼Œå¹¶ä»
      rbd_header.[image id]çš„omapä¸­è·å¾—è®¾å¤‡å¤§å°ï¼Œåˆ†ç‰‡å¤§å°ç­‰ä¿¡æ¯*/
    rc = rbd_dev_image_probe(rbd_dev, true);
    if (rc &lt; 0)
        goto err_out_rbd_dev;

    ...

    /*æ ¹æ®cephé›†ç¾¤è¿”å›çš„rbdä¿¡æ¯ï¼Œå®Œæˆå¯¹rbd_devçš„è®¾ç½®ï¼Œå¹¶é€šè¿‡å†…æ ¸å—å±‚æ¥å£ç”Ÿæˆæ–°çš„å—è®¾å¤‡å¯¹è±¡*/
    rc = rbd_dev_device_setup(rbd_dev);
    if (rc) {
        rbd_dev_image_release(rbd_dev);
        goto err_out_module;
    }

    return count;

    ...
}

</code></pre></div></div>

<h4 id="21-rbd_get_client"><strong>2.1. rbd_get_client</strong></h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbd_get_client[*]
\-rbd_client_create
    |-ceph_create_client
    |   |-ceph_messenger_init
    |   |-ceph_monc_init
    |   \-ceph_osdc_init
    \_ceph_open_session
        |-ceph_monc_open_session
        |   \-__open_session
        |       |-ceph_con_open
        |       |-ceph_auth_build_hello
        |       \-__send_prepared_auth_request
        \-wait_event_interruptible_timeout
</code></pre></div></div>
<p>â€ƒâ€ƒé’ˆå¯¹åŒä¸€ä¸ªradosé›†ç¾¤ï¼Œæ¯ä¸ªå®¢æˆ·ç«¯èŠ‚ç‚¹éƒ½ä¼šåœ¨å†…æ ¸ä¸­ç”Ÿæˆä¸€ä¸ªrbd_clientå¯¹è±¡ï¼Œç”¨æ¥å’Œè¯¥radosé›†ç¾¤è¿›è¡Œä¼šè¯ï¼›åœ¨ä¸€ä¸ªå®¢æˆ·ç«¯èŠ‚ç‚¹ä¸Šï¼Œå¦‚æœé’ˆå¯¹åŒä¸€ä¸ªradosé›†ç¾¤åˆ›å»ºäº†å¤šä¸ªRBDè®¾å¤‡ï¼Œé‚£ä¹ˆè¿™äº›RBDè®¾å¤‡ä¼šå…±ç”¨åŒä¸€ä¸ªrbd_clientã€‚ä¸‹é¢æˆ‘ä»¬çœ‹çœ‹rbd_get_clientçš„å†…éƒ¨å®ç°ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

/*
 * Get a ceph client with specific addr and configuration, if one does
 * not exist create it.  Either way, ceph_opts is consumed by this
 * function.
 */
static struct rbd_client *rbd_get_client(struct ceph_options *ceph_opts)
{
    struct rbd_client *rbdc;

    rbdc = rbd_client_find(ceph_opts); /*åœ¨å…¨å±€é“¾è¡¨rbd_client_listä¸­æ ¹æ®ceph_optsçš„é›†ç¾¤ä¿¡æ¯æŸ¥æ‰¾rbd_client*/
    if (rbdc)	/* using an existing client */
        ceph_destroy_options(ceph_opts); /*å¦‚æœæ‰¾åˆ°ç›¸åŒçš„rbd_client(å¯¹åº”åŒä¸€ä¸ªradosé›†ç¾¤)ï¼Œåˆ™å¤ç”¨è¯¥å¯¹è±¡ï¼ŒåŒæ—¶é”€æ¯ceph_opts*/
    else
        rbdc = rbd_client_create(ceph_opts); /*å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç›¸åŒçš„rbd_clientï¼Œåˆ™æ–°å»ºä¸€ä¸ªå¹¶æ·»åŠ åˆ°rbd_client_listä¸­*/

    return rbdc;
}
</code></pre></div></div>

<p>â€ƒâ€ƒæ¥ç€çœ‹rbd_client_createï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

/*rbd_clientä»£è¡¨rbdå®¢æˆ·ç«¯å®ä¾‹ï¼Œå¤šä¸ªrbdè®¾å¤‡å¯å…±ç”¨ä¸€ä¸ªå®¢æˆ·ç«¯å®ä¾‹ï¼›å…¶å†…éƒ¨ä¸»è¦åŒ…å«ä¸€ä¸ªceph_clientå¯¹è±¡*/
/*
 * an instance of the client.  multiple devices may share an rbd client.
 */
struct rbd_client {
    struct ceph_client	*client;
    struct kref		kref;
    struct list_head	node;
};

/*
 * Initialize an rbd client instance.  Success or not, this function
 * consumes ceph_opts.
 */
static struct rbd_client *rbd_client_create(struct ceph_options *ceph_opts)
{
    struct rbd_client *rbdc;
    int ret = -ENOMEM;

    rbdc = kmalloc(sizeof(struct rbd_client), GFP_KERNEL);
    ...

    /*è°ƒç”¨libceph.koä¸­çš„å‡½æ•°åˆ›å»ºceph_clientå¯¹è±¡*/
    rbdc-&gt;client = ceph_create_client(ceph_opts, rbdc, 0, 0);
    ...

    /*è°ƒç”¨libceph.koä¸­çš„å‡½æ•°æ‰“å¼€ceph_clientå¯¹è±¡çš„ä¼šè¯ï¼ŒåŸºäºè¯¥ä¼šè¯å¯ä»¥å’Œradosé›†ç¾¤(monitor or OSD)è¿›è¡Œé€šä¿¡*/
    ret = ceph_open_session(rbdc-&gt;client);
    ...

    spin_lock(&amp;rbd_client_list_lock);
    list_add_tail(&amp;rbdc-&gt;node, &amp;rbd_client_list);
    spin_unlock(&amp;rbd_client_list_lock);

    ...

    return rbdc;

    ...
}
</code></pre></div></div>

<p>â€ƒâ€ƒä¸‹é¢æˆ‘ä»¬å†æ·±å…¥ä¸€å±‚ï¼Œçœ‹çœ‹libcephä¸­ceph_clientçš„ç›¸å…³å®ç°ï¼Œä½†ä¸ä¼šæ·±å…¥åˆ°messengeræ¨¡å—ä¸­(å¤æ‚æ€§è¾ƒé«˜)ï¼Œæˆ‘ä»¬åœ¨2.1.3èŠ‚ä¼šæ€»ç»“ä¸€ä¸‹å¯¹messengeræ¨¡å—çš„ä½¿ç”¨æ–¹æ³•(API)ã€‚å¯¹äºmessengerçš„åˆ†ææˆ‘ä»¬å°†æ”¾åˆ°å•ç‹¬çš„åšæ–‡ä¸­ä»‹ç»ã€‚</p>

<h5 id="211-rbd_get_client---ceph_create_client"><strong>2.1.1. rbd_get_client -&gt; ceph_create_client</strong></h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbd_get_client
\-rbd_client_create
    |-ceph_create_client[*]
    |   |-ceph_messenger_init
    |   |-ceph_monc_init
    |   \-ceph_osdc_init
    \_ceph_open_session
        |-ceph_monc_open_session
        |   \-__open_session
        |       |-ceph_con_open
        |       |-ceph_auth_build_hello
        |       \-__send_prepared_auth_request
        \-wait_event_interruptible_timeout
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/ceph/libceph.h:

/*
 * per client state
 *
 * possibly shared by multiple mount points, if they are
 * mounting the same ceph filesystem/cluster.
 */
struct ceph_client {
    ...

    /*æ¯ä¸ªceph_clientåŒ…å«ä¸€ä¸ªmessengerå®ä¾‹ã€ä¸€ä¸ªmon_clientå®ä¾‹å’Œä¸€ä¸ªosd_clientå®ä¾‹ï¼š
      (1)messengerå®ä¾‹æè¿°äº†ä¸ç½‘ç»œé€šä¿¡ç›¸å…³çš„ä¿¡æ¯ï¼Œå±äºmessengeræ¨¡å—ï¼Œæ˜¯cephå®¢æˆ·ç«¯åŸºäºsocketå°è£…çš„ç½‘ç»œæœåŠ¡å±‚ï¼›
      (2)mon_clientå®ä¾‹æ˜¯ä¸“é—¨ç”¨æ¥ä¸monitoré€šä¿¡çš„å®¢æˆ·ç«¯ï¼›
      (3)osd_clientå®ä¾‹æ˜¯ä¸“é—¨ç”¨æ¥ä¸æ‰€æœ‰osdé€šä¿¡çš„å®¢æˆ·ç«¯ã€‚*/
    struct ceph_messenger msgr;   /* messenger instance */
    struct ceph_mon_client monc;
    struct ceph_osd_client osdc;

    ...
};
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/ceph_common.c:

/*ceph_create_clientåˆ›å»ºceph_clientå¯¹è±¡å¹¶å¯¹å…¶å†…éƒ¨çš„messengerã€mon_clientã€osd_clientè¿›è¡Œåˆå§‹åŒ–*/
/*
 * create a fresh client instance
 */
struct ceph_client *ceph_create_client(struct ceph_options *opt, void *private,
        unsigned int supported_features, unsigned int required_features)
{
    struct ceph_client *client;
    struct ceph_entity_addr *myaddr = NULL;
    int err = -ENOMEM;

    client = kzalloc(sizeof(*client), GFP_KERNEL);
    if (client == NULL)
        return ERR_PTR(-ENOMEM);

    client-&gt;private = private;
    client-&gt;options = opt;

    ...

    /* msgr */
    if (ceph_test_opt(client, MYIP))
        myaddr = &amp;client-&gt;options-&gt;my_addr;
    ceph_messenger_init(&amp;client-&gt;msgr, myaddr, client-&gt;supported_features,
        client-&gt;required_features, ceph_test_opt(client, NOCRC));

    /* subsystems */
    err = ceph_monc_init(&amp;client-&gt;monc, client);
    if (err &lt; 0)
        goto fail;
    err = ceph_osdc_init(&amp;client-&gt;osdc, client);
    if (err &lt; 0)
        goto fail_monc;

    return client;
    ...
}
</code></pre></div></div>

<p>â€ƒâ€ƒæ¥ç€æˆ‘ä»¬å¯ä»¥æµè§ˆä¸€ä¸‹messengerã€mon_clientã€osd_clientçš„åˆå§‹åŒ–ï¼Œé‡ç‚¹å…³æ³¨æ³¨é‡Šéƒ¨åˆ†ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/ceph/messenger.h:

struct ceph_messenger {
    struct ceph_entity_inst inst;    /* my name+address */
    struct ceph_entity_addr my_enc_addr;

    atomic_t stopping;
    bool nocrc;

    /*
     * the global_seq counts connections i (attempt to) initiate
     * in order to disambiguate certain connect race conditions.
     */
    u32 global_seq;
    spinlock_t global_seq_lock;

    u32 supported_features;
    u32 required_features;
};
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/messenger.c:

/*
 * initialize a new messenger instance
 */
void ceph_messenger_init(struct ceph_messenger *msgr,
            struct ceph_entity_addr *myaddr,
            u32 supported_features,
            u32 required_features,
            bool nocrc)
{
    msgr-&gt;supported_features = supported_features;
    msgr-&gt;required_features = required_features;

    spin_lock_init(&amp;msgr-&gt;global_seq_lock);

    if (myaddr)
        msgr-&gt;inst.addr = *myaddr;

    /* select a random nonce */
    msgr-&gt;inst.addr.type = 0;
    get_random_bytes(&amp;msgr-&gt;inst.addr.nonce, sizeof(msgr-&gt;inst.addr.nonce));
    encode_my_addr(msgr);
    msgr-&gt;nocrc = nocrc;

    atomic_set(&amp;msgr-&gt;stopping, 0);

    dout("%s %p\n", __func__, msgr);
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/ceph/mon_client.h:

struct ceph_mon_client {
    struct ceph_client *client;
    struct ceph_monmap *monmap;

    struct mutex mutex;
    struct delayed_work delayed_work;

    struct ceph_auth_client *auth;
    struct ceph_msg *m_auth, *m_auth_reply, *m_subscribe, *m_subscribe_ack;
    int pending_auth;

    bool hunting;
    int cur_mon;                       /* last monitor i contacted */
    unsigned long sub_sent, sub_renew_after;
    struct ceph_connection con;

    /* pending generic requests */
    struct rb_root generic_request_tree;
    int num_generic_requests;
    u64 last_tid;

    /* mds/osd map */
    int want_mdsmap;
    int want_next_osdmap; /* 1 = want, 2 = want+asked */
    u32 have_osdmap, have_mdsmap;
};

</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/mon_client.c:

int ceph_monc_init(struct ceph_mon_client *monc, struct ceph_client *cl)
{
    int err = 0;

    dout("init\n");
    memset(monc, 0, sizeof(*monc));
    monc-&gt;client = cl;
    monc-&gt;monmap = NULL;
    mutex_init(&amp;monc-&gt;mutex);

    err = build_initial_monmap(monc);
    if (err)
        goto out;

    /* connection */
    /* authentication */
    monc-&gt;auth = ceph_auth_init(cl-&gt;options-&gt;name, cl-&gt;options-&gt;key);
    ...
    monc-&gt;auth-&gt;want_keys =
        CEPH_ENTITY_TYPE_AUTH | CEPH_ENTITY_TYPE_MON |
        CEPH_ENTITY_TYPE_OSD | CEPH_ENTITY_TYPE_MDS;

    /* msgs */
    err = -ENOMEM;
    monc-&gt;m_subscribe_ack = ceph_msg_new(CEPH_MSG_MON_SUBSCRIBE_ACK,
        sizeof(struct ceph_mon_subscribe_ack), GFP_NOFS, true);
    ...
    monc-&gt;m_subscribe = ceph_msg_new(CEPH_MSG_MON_SUBSCRIBE, 96, GFP_NOFS, true);
    ...
    monc-&gt;m_auth_reply = ceph_msg_new(CEPH_MSG_AUTH_REPLY, 4096, GFP_NOFS, true);
    ...
    monc-&gt;m_auth = ceph_msg_new(CEPH_MSG_AUTH, 4096, GFP_NOFS, true);
    monc-&gt;pending_auth = 0;
    ...

    /*mon_clienté€šè¿‡åº•å±‚messengeræ¨¡å—ä¸­çš„connectionå¯¹è±¡è¿›è¡Œç½‘ç»œé€šä¿¡ï¼Œè¿™é‡Œå¯¹mon_clientä½¿ç”¨çš„connectionè¿›è¡Œ
      åˆå§‹åŒ–ï¼Œå¹¶æŒ‡å®šå…¶ç½‘ç»œå±‚å›è°ƒå‡½æ•°é›†ä¸ºmon_con_opsï¼Œç”¨æ¥å¤„ç†æ¶ˆæ¯å›è°ƒã€ç½‘ç»œè¿æ¥æ•…éšœç­‰*/
    ceph_con_init(&amp;monc-&gt;con, monc, &amp;mon_con_ops, &amp;monc-&gt;client-&gt;msgr);

    monc-&gt;cur_mon = -1;
    monc-&gt;hunting = true;
    monc-&gt;sub_renew_after = jiffies;
    monc-&gt;sub_sent = 0;

    INIT_DELAYED_WORK(&amp;monc-&gt;delayed_work, delayed_work);
    monc-&gt;generic_request_tree = RB_ROOT;
    monc-&gt;num_generic_requests = 0;
    monc-&gt;last_tid = 0;

    monc-&gt;have_mdsmap = 0;
    monc-&gt;have_osdmap = 0;
    monc-&gt;want_next_osdmap = 1;
    return 0;

    ...
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/ceph/osd_client.h:

struct ceph_osd_client {
    struct ceph_client     *client;

    struct ceph_osdmap     *osdmap;       /* current map */
    struct rw_semaphore    map_sem;
    struct completion      map_waiters;
    u64                    last_requested_map;

    struct mutex           request_mutex;
    struct rb_root         osds;          /* osds */
    struct list_head       osd_lru;       /* idle osds */
    u64                    timeout_tid;   /* tid of timeout triggering rq */
    u64                    last_tid;      /* tid of last request */
    struct rb_root         requests;      /* pending requests */
    struct list_head       req_lru;	      /* in-flight lru */
    struct list_head       req_unsent;    /* unsent/need-resend queue */
    struct list_head       req_notarget;  /* map to no osd */
    struct list_head       req_linger;    /* lingering requests */
    int                    num_requests;
    struct delayed_work    timeout_work;
    struct delayed_work    osds_timeout_work;

    mempool_t              *req_mempool;

    struct ceph_msgpool	msgpool_op;
    struct ceph_msgpool	msgpool_op_reply;

    spinlock_t		event_lock;
    struct rb_root		event_tree;
    u64			event_count;

    struct workqueue_struct	*notify_wq;
};
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/osd_client.c:

int ceph_osdc_init(struct ceph_osd_client *osdc, struct ceph_client *client)
{
    int err;

    dout("init\n");
    osdc-&gt;client = client;
    osdc-&gt;osdmap = NULL;
    init_rwsem(&amp;osdc-&gt;map_sem);
    init_completion(&amp;osdc-&gt;map_waiters);
    osdc-&gt;last_requested_map = 0;
    mutex_init(&amp;osdc-&gt;request_mutex);
    osdc-&gt;last_tid = 0;
    osdc-&gt;osds = RB_ROOT;
    INIT_LIST_HEAD(&amp;osdc-&gt;osd_lru);
    osdc-&gt;requests = RB_ROOT;
    INIT_LIST_HEAD(&amp;osdc-&gt;req_lru);
    INIT_LIST_HEAD(&amp;osdc-&gt;req_unsent);
    INIT_LIST_HEAD(&amp;osdc-&gt;req_notarget);
    INIT_LIST_HEAD(&amp;osdc-&gt;req_linger);
    osdc-&gt;num_requests = 0;
    INIT_DELAYED_WORK(&amp;osdc-&gt;timeout_work, handle_timeout);
    INIT_DELAYED_WORK(&amp;osdc-&gt;osds_timeout_work, handle_osds_timeout);
    spin_lock_init(&amp;osdc-&gt;event_lock);
    osdc-&gt;event_tree = RB_ROOT;
    osdc-&gt;event_count = 0;

    schedule_delayed_work(&amp;osdc-&gt;osds_timeout_work,
        round_jiffies_relative(osdc-&gt;client-&gt;options-&gt;osd_idle_ttl * HZ));

    err = -ENOMEM;
    osdc-&gt;req_mempool = mempool_create_kmalloc_pool(10, sizeof(struct ceph_osd_request));
    if (!osdc-&gt;req_mempool)
        goto out;

    err = ceph_msgpool_init(&amp;osdc-&gt;msgpool_op, CEPH_MSG_OSD_OP,
            OSD_OP_FRONT_LEN, 10, true, "osd_op");
    if (err &lt; 0)
        goto out_mempool;
    err = ceph_msgpool_init(&amp;osdc-&gt;msgpool_op_reply, CEPH_MSG_OSD_OPREPLY,
        OSD_OPREPLY_FRONT_LEN, 10, true, "osd_op_reply");
    if (err &lt; 0)
        goto out_msgpool;

    err = -ENOMEM;
    osdc-&gt;notify_wq = create_singlethread_workqueue("ceph-watch-notify");
    if (!osdc-&gt;notify_wq)
        goto out_msgpool;
    return 0;

out_msgpool:
    ceph_msgpool_destroy(&amp;osdc-&gt;msgpool_op);
out_mempool:
    mempool_destroy(osdc-&gt;req_mempool);
out:
    return err;
}
</code></pre></div></div>

<h5 id="212-rbd_get_client---ceph_open_session"><strong>2.1.2. rbd_get_client -&gt; ceph_open_session</strong></h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbd_get_client
\-rbd_client_create
    |-ceph_create_client
    |   |-ceph_messenger_init
    |   |-ceph_monc_init
    |   \-ceph_osdc_init
    \_ceph_open_session[*]
        |-ceph_monc_open_session
        |   \-__open_session
        |       |-ceph_con_open
        |       |-ceph_auth_build_hello
        |       \-__send_prepared_auth_request
        \-wait_event_interruptible_timeout
</code></pre></div></div>

<p>â€ƒâ€ƒåœ¨å®Œæˆceph_clientçš„åˆå§‹åŒ–åŠ¨ä½œåï¼Œä¸‹ä¸€æ­¥æ˜¯æ‰“å¼€ä¼šè¯ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/ceph_common.c:

int ceph_open_session(struct ceph_client *client)
{
    ...

    ret = __ceph_open_session(client, started);

    ...
    return ret;
}

/*
 * mount: join the ceph cluster, and open root directory.
 */
int __ceph_open_session(struct ceph_client *client, unsigned long started)
{
    int err;
    /*timeoutè¡¨ç¤ºæ‰“å¼€ä¼šè¯çš„è¶…æ—¶æ—¶é—´ï¼Œé»˜è®¤ä¸º60ç§’*/
    unsigned long timeout = client-&gt;options-&gt;mount_timeout * HZ;

    /*ceph_clientå†…éƒ¨æ˜¯é€šè¿‡mon_clientæ¥æ‰“å¼€ä¼šè¯ï¼Œå¦‚æœmon_clientæˆåŠŸæ‰“å¼€ä¼šè¯ï¼Œ
      å®ƒä¼šæˆåŠŸè·å¾—radosé›†ç¾¤çš„mon_map(æè¿°æ‰€æœ‰monitorsä¿¡æ¯)å’Œosd_map(æè¿°æ‰€æœ‰çš„osdä¿¡æ¯)*/
    /* open session, and wait for mon and osd maps */
    err = ceph_monc_open_session(&amp;client-&gt;monc);
    if (err &lt; 0)
        return err;

    while (!have_mon_and_osd_map(client)) { /*å¦‚æœæ²¡æœ‰è·å¾—mon_mapå’Œosd_mapï¼Œåˆ™ç­‰å¾…ç›´åˆ°è¶…æ—¶*/
        err = -EIO;
        if (timeout &amp;&amp; time_after_eq(jiffies, started + timeout)) /*è¶…æ—¶é€€å‡º*/
            return err;

        /* wait */
        dout("mount waiting for mon_map\n");
        /*ä¸‹é¢ï¼Œå½“å‰è¿›ç¨‹(rbdå·¥å…·)å°†è¿›å…¥ç¡çœ çŠ¶æ€ï¼Œç›´åˆ°å†…æ ¸æ¥æ”¶åˆ°mon_mapå’Œosd_mapæ—¶è¢«é‡æ–°å”¤é†’ï¼Œ
          æˆ–è€…å‡ºç°è®¤è¯é”™æ—¶ä¹Ÿå°†è¢«å”¤é†’*/
        err = wait_event_interruptible_timeout(client-&gt;auth_wq,
            have_mon_and_osd_map(client) || (client-&gt;auth_err &lt; 0),
            timeout);
        if (err == -EINTR || err == -ERESTARTSYS)
            return err;
        if (client-&gt;auth_err &lt; 0)
            return client-&gt;auth_err;
    }

    return 0;
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/mon_client.c:

int ceph_monc_open_session(struct ceph_mon_client *monc)
{
    mutex_lock(&amp;monc-&gt;mutex);
    __open_session(monc);
    __schedule_delayed(monc);
    mutex_unlock(&amp;monc-&gt;mutex);
    return 0;
}

/*
 * Open a session with a (new) monitor.
 */
static int __open_session(struct ceph_mon_client *monc)
{
    char r;
    int ret;

    if (monc-&gt;cur_mon &lt; 0) {/*åˆå§‹æ—¶cur_monä¸ºï¼1ï¼Œè¡¨ç¤ºæ²¡æœ‰å’Œä»»ä½•monitorå»ºç«‹è¿æ¥*/

        /*é€šè¿‡éšæœºæ•°rï¼Œä»åˆå§‹åŒ–æ—¶ç”Ÿæˆçš„mon_mapä¸­éšæœºé€‰ä¸€ä¸ªè¿›è¡Œä¼šè¯è¿æ¥çš„monitor*/
        get_random_bytes(&amp;r, 1);
        monc-&gt;cur_mon = r % monc-&gt;monmap-&gt;num_mon;
        monc-&gt;sub_sent = 0;
        monc-&gt;sub_renew_after = jiffies;  /* i.e., expired */
        monc-&gt;want_next_osdmap = !!monc-&gt;want_next_osdmap;

        /*ä¸é€‰å®šçš„monitorå»ºç«‹ç½‘ç»œè¿æ¥ï¼Œè¿™é‡Œä½¿ç”¨çš„messengeræ¨¡å—æä¾›çš„æ¥å£*/
        ceph_con_open(&amp;monc-&gt;con,
            CEPH_ENTITY_TYPE_MON, monc-&gt;cur_mon,
            &amp;monc-&gt;monmap-&gt;mon_inst[monc-&gt;cur_mon].addr);

        /*åˆå§‹åŒ–å‘é€ç»™monitorçš„é¦–ä¸ªhelloæ¶ˆæ¯*/
        /* initiatiate authentication handshake */
        ret = ceph_auth_build_hello(monc-&gt;auth,
                monc-&gt;m_auth-&gt;front.iov_base,
                monc-&gt;m_auth-&gt;front_alloc_len);

        /*è¿™é‡Œé€šè¿‡messengeræ¨¡å—çš„ceph_con_sendæ¥å£å°†æ¶ˆæ¯å‘é€ç»™monitor*/
        __send_prepared_auth_request(monc, ret);
    } else {
        dout("open_session mon%d already open\n", monc-&gt;cur_mon);
    }
    return 0;
}
</code></pre></div></div>

<h5 id="213-messengeræ¨¡å—ä½¿ç”¨æ–¹æ³•å°ç»“"><strong>2.1.3. messengeræ¨¡å—ä½¿ç”¨æ–¹æ³•å°ç»“</strong></h5>

<p>â€ƒâ€ƒé€šè¿‡å‰æ–‡å¯¹mon_clientçš„åˆ†æï¼Œæˆ‘ä»¬æ¥æ€»ç»“ä¸€ä¸‹mon_clientæ˜¯å¦‚ä½•ä½¿ç”¨åº•å±‚çš„messengeræ¨¡å—çš„ï¼š</p>

<blockquote>
  <ul>
    <li>(1) é€šè¿‡ceph_messenger_initåœ¨ceph_clientä¸­åˆå§‹åŒ–ä¸€ä¸ªmessengerå¯¹è±¡ï¼Œå®šä¹‰å…¨å±€ç½‘ç»œé€šä¿¡ä¿¡æ¯ï¼›è¯¥å¯¹è±¡è¢«mon_clientå’Œosd_clientå…±äº«ï¼›</li>
    <li>(2) ceph_con_init(&amp;monc-&gt;con, monc, &amp;mon_con_ops, &amp;monc-&gt;client-&gt;msgr)ï¼Œç½‘ç»œè¿æ¥å¯¹è±¡åˆå§‹åŒ–ï¼Œå¹¶æŒ‡æ˜è¯¥è¿æ¥æ”¶åˆ°æ¶ˆæ¯æ—¶çš„å›è°ƒå¤„ç†å‡½æ•°(æ¶ˆæ¯å°†åœ¨å†…æ ¸å·¥ä½œé˜Ÿåˆ—ä¸Šä¸‹æ–‡è¢«å¤„ç†)ï¼›</li>
    <li>(3) ceph_con_openæ‰“å¼€ä¸é€‰å®šmonitorçš„ç½‘ç»œè¿æ¥ï¼›å¹¶æ‹‰èµ·ä¸€ä¸ªä¸å½“å‰è¿æ¥å…³è”çš„å·¥ä½œä»»åŠ¡(connection worker)ï¼Œè¯¥ä»»åŠ¡è´Ÿè´£è¯¥è¿æ¥ä¸Šç½‘ç»œæ¶ˆæ¯çš„æ”¶å‘ï¼›</li>
    <li>(4) å‘é€æ¶ˆæ¯æ—¶ï¼Œå…ˆä½¿ç”¨ceph_msg_newè¿›è¡Œæ¶ˆæ¯çš„å†…å­˜åˆ†é…ï¼Œå†å¡«å…¥æ¶ˆæ¯å†…å®¹ï¼Œç„¶åä½¿ç”¨ceph_con_sendè¿›è¡Œæ¶ˆæ¯å‘é€ï¼›ceph_con_sendä¼šå”¤é†’å·¥ä½œä»»åŠ¡æ‰§è¡Œæ¶ˆæ¯å‘é€ï¼›</li>
    <li>(5) æ¥æ”¶æ¶ˆæ¯æ—¶ï¼Œå†…æ ¸ç½‘ç»œåè®®æ ˆåœ¨æ”¶åˆ°ç½‘å¡æ¶ˆæ¯åï¼Œä¼šé€šè¿‡cephæ³¨å†Œçš„å›è°ƒå”¤é†’å¯¹åº”çš„connection workerè¿›è¡Œæ”¶åŒ…ï¼Œå¹¶è°ƒç”¨åˆå§‹åŒ–æ—¶ç»‘å®šçš„æ¶ˆæ¯å¤„ç†å›è°ƒå‡½æ•°ï¼›</li>
    <li>(6) mon_clientå…³é—­ä¼šè¯æ—¶ä½¿ç”¨ceph_con_closeå…³é—­è¿æ¥ï¼›</li>
  </ul>
</blockquote>

<h5 id="214-æ‰“å¼€ä¼šè¯æ—¶å®¢æˆ·ç«¯ä¸monitorçš„äº¤äº’æ¶ˆæ¯å¤„ç†å›è°ƒmon_con_opsåˆ†æ"><strong>2.1.4. æ‰“å¼€ä¼šè¯æ—¶å®¢æˆ·ç«¯ä¸monitorçš„äº¤äº’(æ¶ˆæ¯å¤„ç†å›è°ƒmon_con_opsåˆ†æ)</strong></h5>

<p>â€ƒâ€ƒç›®å‰monitorå¯¹æˆ‘ä»¬æ¥è¯´è¿˜æ˜¯ä¸€ä¸ªé»‘ç›’ï¼Œå› æ­¤æ— æ³•åˆ†æå…¶å†…éƒ¨æ˜¯å¦‚ä½•å¤„ç†å®¢æˆ·ç«¯å‘é€çš„helloæ¶ˆæ¯çš„ã€‚é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•æ‰èƒ½è·çŸ¥å®¢æˆ·ç«¯æ˜¯å¦‚ä½•ä¸monitorè¿›è¡Œäº¤äº’çš„ï¼Ÿè¿™é‡Œæˆ‘ä»¬å¯ä»¥æ‰“å¼€å†…æ ¸åŠ¨æ€æ—¥å¿—å¼€å…³(ä»£ç ä¸­æœ‰å¾ˆå¤šdoutè¯­å¥)ï¼Œå¹¶é€šè¿‡åˆ†ææ—¥å¿—æ¥è·çŸ¥æ•´ä¸ªäº¤äº’è¿‡ç¨‹ã€‚é€šè¿‡æ‰“å¼€libcephçš„messengeræ¨¡å—æ—¥å¿—ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å¦‚ä¸‹å›¾æ‰€ç¤ºçš„æ¶ˆæ¯äº¤äº’è¿‡ç¨‹ï¼š</p>

<div align="center">
<img src="/images/posts/ceph/rbd_5.jpg" height="550" width="400" />  
</div>

<p>â€ƒâ€ƒä»ä¸Šå›¾å¯è§ï¼ŒTCPè¿æ¥å»ºç«‹åçš„å‰å‡ æ¬¡æ¶ˆæ¯äº¤äº’ä¸»è¦æ˜¯messengeræ¨¡å—å¯¹è¿æ¥è¿›è¡Œåˆå§‹åŒ–ï¼Œæˆ‘ä»¬åœ¨å°†åœ¨æ·±å…¥åˆ†æmessengeræ¨¡å—æ—¶åˆ†æã€‚ceph connectionåˆå§‹åŒ–å®Œæˆåï¼Œå®¢æˆ·ç«¯é¦–å…ˆä¾¿æ˜¯å‘monitorå‘é€Auth(hello)è®¤è¯æ¶ˆæ¯ï¼Œå…³äºè®¤è¯çš„å®ç°ç»†èŠ‚æˆ‘ä»¬è¿™é‡Œæš‚ä¸æ·±å…¥åˆ†æï¼Œé€šè¿‡æ—¥å¿—å¯çŸ¥ï¼Œæ•´ä¸ªè®¤è¯ä¼šæœ‰ä¸‰æ¬¡Authæ¶ˆæ¯çš„äº¤äº’ï¼šç¬¬ä¸€æ¬¡Auth_replyè¿”å›å‰ï¼Œmonitorä¼šå‘å®¢æˆ·ç«¯è¿”å›monmapï¼›ç¬¬ä¸‰æ¬¡Auth_replyè¿”å›åï¼Œè¡¨ç¤ºè®¤è¯æˆåŠŸã€‚è®¤è¯æˆåŠŸä¹‹åå®¢æˆ·ç«¯ä¼šå‘monitorå‘é€Subscribeè®¢é˜…æ¶ˆæ¯ï¼Œè¡¨ç¤ºå…³æ³¨osdmapçš„æ›´æ–°ã€‚ç”±äºæ˜¯é¦–æ¬¡è®¤è¯ï¼Œmonitorä¼šå‘clientè¿”å›åˆå§‹çš„osdmapï¼Œåç»­åªæœ‰åœ¨osdmapæœ‰æ›´æ–°æ—¶ï¼Œmonitoræ‰å›è¿”å›æ›´æ–°åçš„mapã€‚</p>

<p>â€ƒâ€ƒä¸‹é¢æˆ‘ä»¬æ‰“å¼€mon_con_opsçœ‹çœ‹å®¢æˆ·ç«¯æ”¶åˆ°å„ç±»æ¶ˆæ¯çš„å¤„ç†è¿‡ç¨‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/mon_client.c:

static const struct ceph_connection_operations mon_con_ops = {
    ...
    .dispatch = dispatch, /*æ”¶åˆ°monitorçš„æ¶ˆæ¯æ—¶ä¼šè°ƒç”¨è¯¥å‡½æ•°*/
    ...
};

/*
 * handle incoming message
 */
static void dispatch(struct ceph_connection *con, struct ceph_msg *msg)
{
    struct ceph_mon_client *monc = con-&gt;private;
    int type = le16_to_cpu(msg-&gt;hdr.type);

    if (!monc)
        return;

    /*è¿™é‡Œé’ˆå¯¹ä¸åŒæ¶ˆæ¯è¿›è¡Œä¸åŒå¤„ç†*/
    switch (type) {
    case CEPH_MSG_AUTH_REPLY:
        handle_auth_reply(monc, msg);
        break;

    case CEPH_MSG_MON_SUBSCRIBE_ACK:
        handle_subscribe_ack(monc, msg);
        break;

    case CEPH_MSG_STATFS_REPLY:
        handle_statfs_reply(monc, msg);
        break;

    case CEPH_MSG_POOLOP_REPLY:
        handle_poolop_reply(monc, msg);
        break;

    case CEPH_MSG_MON_MAP:
        ceph_monc_handle_map(monc, msg);
        break;

    case CEPH_MSG_OSD_MAP:
        ceph_osdc_handle_map(&amp;monc-&gt;client-&gt;osdc, msg);
        break;

    default:
        /* can the chained handler handle it? */
        if (monc-&gt;client-&gt;extra_mon_dispatch &amp;&amp;
                monc-&gt;client-&gt;extra_mon_dispatch(monc-&gt;client, msg) == 0)
            break;

        pr_err("received unknown message type %d %s\n", type,
        ceph_msg_type_name(type));
    }
    ceph_msg_put(msg);
}

/*å¤„ç†monmapæ¶ˆæ¯ï¼Œæ¥æ”¶æœ€æ–°çš„monitorä¿¡æ¯*/
static void ceph_monc_handle_map(struct ceph_mon_client *monc, struct ceph_msg *msg)
{
    struct ceph_client *client = monc-&gt;client;
    struct ceph_monmap *monmap = NULL, *old = monc-&gt;monmap;
    void *p, *end;
    ...

    dout("handle_monmap\n");
    p = msg-&gt;front.iov_base;
    end = p + msg-&gt;front.iov_len;

    /*ä»æ”¶åˆ°çš„æ¶ˆæ¯ä¸­è§£æå‡ºmonmapå†…å®¹ï¼Œå®ƒåŒ…å«æ‰€æœ‰monitorèŠ‚ç‚¹çš„IPä¿¡æ¯*/
    monmap = ceph_monmap_decode(p, end);
    ...

    /*æ›´æ–°monmap*/
    client-&gt;monc.monmap = monmap;
    kfree(old);
    ...

out_unlocked:
    /*å”¤é†’æ‰€æœ‰åœ¨auth_wqä¸­ç­‰å¾…çš„ä»»åŠ¡*/
    wake_up_all(&amp;client-&gt;auth_wq);
}

/*å¤„ç†osdmapæ¶ˆæ¯ï¼Œæ•´ä½“æ€è·¯å’Œmonmapç±»ä¼¼ï¼›è¿™é‡Œåˆ†äº†å¢é‡å’Œå…¨é‡ä¸¤ç§æ¨¡å¼ï¼›
  osdmapä¸­è®°å½•äº†æ‰€æœ‰osdçš„IPå’ŒçŠ¶æ€ä¿¡æ¯*/
/*
* Process updated osd map.
*
* The message contains any number of incremental and full maps, normally
* indicating some sort of topology change in the cluster.  Kick requests
* off to different OSDs as needed.
*/
void ceph_osdc_handle_map(struct ceph_osd_client *osdc, struct ceph_msg *msg)
{
    ...
}

static void handle_auth_reply(struct ceph_mon_client *monc, struct ceph_msg *msg)
{
    int ret;
    int was_auth = 0;

    ...
    /*å¤„ç†auth_replyæ¶ˆæ¯*/
    ret = ceph_handle_auth_reply(monc-&gt;auth, msg-&gt;front.iov_base,
                msg-&gt;front.iov_len,
                monc-&gt;m_auth-&gt;front.iov_base,
                monc-&gt;m_auth-&gt;front_alloc_len);
    if (ret &lt; 0) {
        /*å¦‚æœè®¤è¯å‡ºé”™ï¼Œåˆ™å”¤é†’ç­‰å¾…ä»»åŠ¡å¹¶è¿”å›é”™è¯¯ä¿¡æ¯*/
        monc-&gt;client-&gt;auth_err = ret;
        wake_up_all(&amp;monc-&gt;client-&gt;auth_wq);
    } else if (ret &gt; 0) {
        /*ç»§ç»­å‘é€è®¤è¯è¯·æ±‚ï¼Œä»æ—¥å¿—åˆ†æå…±ä¼šå‘é€ä¸‰æ¬¡*/
        __send_prepared_auth_request(monc, ret);
    } else if (!was_auth &amp;&amp; ceph_auth_is_authenticated(monc-&gt;auth)) {
        /*è®¤è¯æˆåŠŸï¼Œå‘é€é’ˆå¯¹osdmapçš„è®¢é˜…æ¶ˆæ¯*/
        dout("authenticated, starting session\n");

        monc-&gt;client-&gt;msgr.inst.name.type = CEPH_ENTITY_TYPE_CLIENT;
        monc-&gt;client-&gt;msgr.inst.name.num =
        cpu_to_le64(monc-&gt;auth-&gt;global_id);

        __send_subscribe(monc);
        __resend_generic_request(monc);
    }
    ...

}
</code></pre></div></div>

<h4 id="22-rbd_dev_image_probe"><strong>2.2. rbd_dev_image_probe</strong></h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbd_dev_image_probe[*]
    |-rbd_dev_image_id
    |   \-rbd_obj_method_sync -&gt; rbd.get_id
    |-rbd_dev_header_name
    \-rbd_dev_v2_header_info
        |-rbd_dev_v2_image_size
        |   \-rbd_obj_method_sync -&gt; rbd.get_size
        \-rbd_dev_v2_header_onetime
            |-rbd_dev_v2_object_prefix
            |   \-rbd_obj_method_sync -&gt; rbd.get_object_prefix
            \-rbd_dev_v2_features
                \-rbd_obj_method_sync -&gt; rbd.get_features
</code></pre></div></div>

<p>â€ƒâ€ƒé€šè¿‡å‰æ–‡çš„åˆ†ææˆ‘ä»¬å¯çŸ¥ï¼Œå½“monitorè¿”å›monmapå’Œosdmapåï¼Œrbdè¿›ç¨‹å°†ç»§ç»­å¾€ä¸‹æ‰§è¡Œåˆ°rbd_dev_image_probeï¼Œè¿™é‡Œå°†ä»å­˜æ”¾å¯¹è±¡çš„OSDä¸­è·å–ä¸å½“å‰RBDè®¾å¤‡ç›¸å…³çš„ä¿¡æ¯ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

/*rbd_devå·²åˆ†é…å†…å­˜ç©ºé—´ï¼Œmappingä¸ºtrue*/
static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)
{
    int ret;
    int tmp;

    /*ä»rados OSDæ± ä¸­è·å–å½“å‰RBDè®¾å¤‡çš„image idï¼Œå³å¯¹è±¡"rbd_id.[RBDè®¾å¤‡åç§°]"çš„å†…å®¹*/
    ret = rbd_dev_image_id(rbd_dev);
    ...

    /*æ„é€ å½“å‰RBDè®¾å¤‡å…ƒæ•°æ®å¯¹è±¡çš„åç§°ï¼Œå³"rbd_header.[image id]"*/
    ret = rbd_dev_header_name(rbd_dev);
    ...

    if (mapping) {
        ret = rbd_dev_header_watch_sync(rbd_dev, true);
        ...
    }

    if (rbd_dev-&gt;image_format == 1)
        ret = rbd_dev_v1_header_info(rbd_dev);
    else
        /*ä»rados OSDæ± ä¸­è·å–å½“å‰RBDè®¾å¤‡å…ƒæ•°æ®å¯¹è±¡çš„omapä¿¡æ¯*/
        ret = rbd_dev_v2_header_info(rbd_dev);
    ...

    return 0;

    ...
}
</code></pre></div></div>

<h5 id="221-rbd_dev_image_probe---rbd_dev_image_id"><strong>2.2.1. rbd_dev_image_probe -&gt; rbd_dev_image_id</strong></h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbd_dev_image_probe
    |-rbd_dev_image_id[*]
    |   \-rbd_obj_method_sync -&gt; rbd.get_id
    |-rbd_dev_header_name
    \-rbd_dev_v2_header_info
        |-rbd_dev_v2_image_size
        |   \-rbd_obj_method_sync -&gt; rbd.get_size
        \-rbd_dev_v2_header_onetime
            |-rbd_dev_v2_object_prefix
            |   \-rbd_obj_method_sync -&gt; rbd.get_object_prefix
            \-rbd_dev_v2_features
                \-rbd_obj_method_sync -&gt; rbd.get_features
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

static int rbd_dev_image_id(struct rbd_device *rbd_dev)
{
    int ret;
    size_t size;
    char *object_name;
    void *response;
    char *image_id;

    ...

    /*å¯¹è±¡åç§°ä¸ºRBD_ID_PREFIX("rbd_id.")+image_name*/
    size = sizeof (RBD_ID_PREFIX) + strlen(rbd_dev-&gt;spec-&gt;image_name);
    object_name = kmalloc(size, GFP_NOIO);
    ...

    /*è¿”å›çš„å¯¹è±¡å†…å®¹æ˜¯ä¸€ä¸ªç»è¿‡ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œå‰å››ä¸ªå­—èŠ‚ä»£è¡¨åç»­å†…å®¹çš„å­—èŠ‚é•¿åº¦*/
    size = sizeof (__le32) + RBD_IMAGE_ID_LEN_MAX;
    response = kzalloc(size, GFP_NOIO);
    ...

    /*è°ƒç”¨rbdåŒæ­¥å¯¹è±¡è°ƒç”¨(call)æ¥å£(ä»¥é¢å‘å¯¹è±¡class.methodçš„æ–¹å¼æ¥è®¿é—®å­˜å‚¨ï¼Œå³å¯¹è±¡æ¥å£)ï¼Œè¿™é‡Œæœ¬è´¨å°±æ˜¯è·å–"rbd_id.RBDåç§°"å¯¹è±¡çš„å†…å®¹ï¼š
      (1)rbd_deviceä¸ºrbd_devï¼Œå³å½“å‰RBDè®¾å¤‡ï¼›
      (2)æ¥å£è®¿é—®å¯¹è±¡åç§°ä¸ºobject_nameï¼Œå³"rbd_id.RBDåç§°"ï¼›
      (3)æ¥å£è®¿é—®ç±»(class)åç§°ä¸º"rbd"ï¼›
      (4)æ¥å£è®¿é—®æ–¹æ³•(method)åç§°ä¸º"get_id"ï¼›
      (5)æ¥å£è®¿é—®è¾“å…¥å‚æ•°ä¸ºç©ºï¼›
      (6)æ¥å£è®¿é—®è¾“å…¥å‚æ•°é•¿åº¦ä¸º0ï¼›
      (7)æ¥å£è®¿é—®è¾“å‡ºç»“æœä¿å­˜å†…å­˜ä½ç½®ä¸ºresponseï¼›
      (8)æ¥å£è®¿é—®è¾“å‡ºç»“æœä¿å­˜å†…å­˜æœ€å¤§é•¿åº¦ä¸º64ã€‚*/
    ret = rbd_obj_method_sync(rbd_dev, object_name,
                "rbd", "get_id", NULL, 0,
                response, RBD_IMAGE_ID_LEN_MAX);

    if (ret == -ENOENT) {
        ...
    } else if (ret &gt; sizeof (__le32)) {
        void *p = response;

        /*ä»è¿”å›ç»“æœä¸­è§£æå‡ºå¯¹è±¡å†…å®¹ï¼Œå³image_id*/
        image_id = ceph_extract_encoded_string(&amp;p, p + ret, NULL, GFP_NOIO);
        ret = IS_ERR(image_id) ? PTR_ERR(image_id) : 0;
        if (!ret)
            rbd_dev-&gt;image_format = 2;
    } else {
        ret = -EINVAL;
    }

    if (!ret) {
        rbd_dev-&gt;spec-&gt;image_id = image_id;
        dout("image_id is %s\n", image_id);
    }
    ...
    return ret;
}
</code></pre></div></div>

<h5 id="222-rbd_dev_image_probe---rbd_dev_header_name"><strong>2.2.2. rbd_dev_image_probe -&gt; rbd_dev_header_name</strong></h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbd_dev_image_probe
    |-rbd_dev_image_id
    |   \-rbd_obj_method_sync -&gt; rbd.get_id
    |-rbd_dev_header_name[*]
    \-rbd_dev_v2_header_info
        |-rbd_dev_v2_image_size
        |   \-rbd_obj_method_sync -&gt; rbd.get_size
        \-rbd_dev_v2_header_onetime
            |-rbd_dev_v2_object_prefix
            |   \-rbd_obj_method_sync -&gt; rbd.get_object_prefix
            \-rbd_dev_v2_features
                \-rbd_obj_method_sync -&gt; rbd.get_features
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

static int rbd_dev_header_name(struct rbd_device *rbd_dev)
{
    struct rbd_spec *spec = rbd_dev-&gt;spec;
    size_t size;

    ...
    /*header_nameè¡¨ç¤ºRBDè®¾å¤‡å¯¹åº”å¤´éƒ¨å¯¹è±¡(å…¶omapä¿å­˜äº†RBDè®¾å¤‡å…ƒæ•°æ®ä¿¡æ¯)åç§°
      å³"rbd_header."+image_id*/
    size = sizeof (RBD_HEADER_PREFIX) + strlen(spec-&gt;image_id);

    rbd_dev-&gt;header_name = kmalloc(size, GFP_KERNEL);
    ...
    sprintf(rbd_dev-&gt;header_name, "%s%s", RBD_HEADER_PREFIX, spec-&gt;image_id);
    return 0;
}
</code></pre></div></div>

<h5 id="223-rbd_dev_image_probe---rbd_dev_v2_header_info"><strong>2.2.3. rbd_dev_image_probe -&gt; rbd_dev_v2_header_info</strong></h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbd_dev_image_probe
    |-rbd_dev_image_id
    |   \-rbd_obj_method_sync -&gt; rbd.get_id
    |-rbd_dev_header_name
    \-rbd_dev_v2_header_info[*]
        |-rbd_dev_v2_image_size
        |   \-rbd_obj_method_sync -&gt; rbd.get_size
        \-rbd_dev_v2_header_onetime
            |-rbd_dev_v2_object_prefix
            |   \-rbd_obj_method_sync -&gt; rbd.get_object_prefix
            \-rbd_dev_v2_features
                \-rbd_obj_method_sync -&gt; rbd.get_features
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

/*è¿™é‡Œæˆ‘ä»¬å¿½ç•¥ä¸å¿«ç…§ç‰¹æ€§(snapshot)ç›¸å…³ä»£ç */
static int rbd_dev_v2_header_info(struct rbd_device *rbd_dev)
{
    bool first_time = rbd_dev-&gt;header.object_prefix == NULL;
    int ret;

    down_write(&amp;rbd_dev-&gt;header_rwsem);

    ret = rbd_dev_v2_image_size(rbd_dev);
    ...

    if (first_time) {
        ret = rbd_dev_v2_header_onetime(rbd_dev);
        ...
    }
    
    ...
    up_write(&amp;rbd_dev-&gt;header_rwsem);

    return ret;
}

static int rbd_dev_v2_image_size(struct rbd_device *rbd_dev)
{
    return _rbd_dev_v2_snap_size(rbd_dev, CEPH_NOSNAP,
            &amp;rbd_dev-&gt;header.obj_order,
            &amp;rbd_dev-&gt;header.image_size);
}

static int _rbd_dev_v2_snap_size(struct rbd_device *rbd_dev, u64 snap_id,
        u8 *order, u64 *snap_size)
{
    __le64 snapid = cpu_to_le64(snap_id);
    int ret;
    struct {
        u8 order;
        __le64 size;
    } __attribute__ ((packed)) size_buf = { 0 };

    /*è°ƒç”¨rbdåŒæ­¥å¯¹è±¡è®¿é—®æ¥å£ï¼Œè¿™é‡Œæœ¬è´¨å°±æ˜¯è·å–â€œrbd_header.image_id"å¯¹è±¡ä¸­omapå¯¹åº”keyçš„å†…å®¹ï¼š
      (1)rbd_deviceä¸ºrbd_devï¼Œå³å½“å‰RBDè®¾å¤‡ï¼›
      (2)æ¥å£è®¿é—®å¯¹è±¡åç§°ä¸ºâ€œrbd_header.image_id"ï¼›
      (3)æ¥å£è®¿é—®ç±»(class)åç§°ä¸º"rbd"ï¼›
      (4)æ¥å£è®¿é—®æ–¹æ³•(method)åç§°ä¸º"get_size"ï¼Œå¯¹åº”omapä¸­çš„keyä¸º"size"ï¼›
      (5)æ¥å£è®¿é—®è¾“å…¥å‚æ•°ä¸ºsnapidï¼›
      (6)æ¥å£è®¿é—®è¾“å…¥å‚æ•°é•¿åº¦ä¸ºsnapidçš„å­—èŠ‚é•¿åº¦ï¼›
      (7)æ¥å£è®¿é—®è¾“å‡ºç»“æœä¿å­˜å†…å­˜ä½ç½®ä¸ºsize_bufï¼›
      (8)æ¥å£è®¿é—®è¾“å‡ºç»“æœä¿å­˜å†…å­˜æœ€å¤§é•¿åº¦ä¸ºsize_bufç©ºé—´å¤§å°ã€‚*/
    ret = rbd_obj_method_sync(rbd_dev, rbd_dev-&gt;header_name,
            "rbd", "get_size",
            &amp;snapid, sizeof (snapid),
            &amp;size_buf, sizeof (size_buf));
    dout("%s: rbd_obj_method_sync returned %d\n", __func__, ret);
    ...

    if (order) {
        *order = size_buf.order;
        dout("  order %u", (unsigned int)*order);
    }
    *snap_size = le64_to_cpu(size_buf.size);

    ...

    return 0;
}

static int rbd_dev_v2_header_onetime(struct rbd_device *rbd_dev)
{
    int ret;

    /*é€šè¿‡rbd_obj_method_syncè·å–å¤´éƒ¨å¯¹è±¡omapä¸­çš„"object_prefix"keyçš„å†…å®¹*/
    ret = rbd_dev_v2_object_prefix(rbd_dev);
    if (ret)
        goto out_err;

    /*é€šè¿‡rbd_obj_method_syncè·å–å¤´éƒ¨å¯¹è±¡omapä¸­çš„"features"keyçš„å†…å®¹*/
    ret = rbd_dev_v2_features(rbd_dev);
    if (ret)
        goto out_err;

    ...

    return ret;
}
</code></pre></div></div>

<h5 id="224-rbd_obj_method_sync"><strong>2.2.4. rbd_obj_method_sync</strong></h5>

<p>â€ƒâ€ƒé€šè¿‡å‰æ–‡åˆ†æï¼Œæˆ‘ä»¬çœ‹åˆ°å¤šä¸ªå­å‡½æ•°ä¸­å‡ä½¿ç”¨äº†rbd_obj_method_syncå‡½æ•°æ¥è®¿é—®radoså¯¹è±¡å†…å®¹ã€‚è¯¥å‡½æ•°æ˜¯å¯¹è¿œç¨‹radoså¯¹è±¡çš„åŒæ­¥è°ƒç”¨æ¥å£ï¼Œæ˜¯å¯¹åº•å±‚libcephæ¥å£(osd_client)çš„å°è£…ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

/*
 * Synchronous osd object method call.  Returns the number of bytes
 * returned in the outbound buffer, or a negative error code.
 */
/*osdå¯¹è±¡çš„åŒæ­¥æ–¹æ³•è°ƒç”¨ï¼Œè¿”å›ç»“æœåœ¨inboundä¸­ã€‚æ³¨ï¼šä¸Šæ–‡çš„æ³¨é‡Šæœ‰é—®é¢˜*/
static int rbd_obj_method_sync(struct rbd_device *rbd_dev,  /*å½“å‰RBDè®¾å¤‡*/
                        const char *object_name,            /*è®¿é—®å¯¹è±¡åç§°*/
                        const char *class_name,             /*è®¿é—®ç±»åç§°*/
                        const char *method_name,            /*è®¿é—®æ–¹æ³•åç§°*/
                        const void *outbound,               /*è¾“å…¥å‚æ•°å†…å­˜ä½ç½®*/
                        size_t outbound_size,               /*è¾“å…¥å‚æ•°å¤§å°*/
                        void *inbound,                      /*è¿”å›ç»“æœå†…å­˜ä½ç½®*/
                        size_t inbound_size)                /*è¿”å›ç»“æœå¤§å°*/
{
    struct ceph_osd_client *osdc = &amp;rbd_dev-&gt;rbd_client-&gt;client-&gt;osdc; /*osd_clientæ˜¯åº•å±‚libcephæ¥å£å¯¹è±¡*/
    struct rbd_obj_request *obj_request;
    struct page **pages;
    u32 page_count;
    int ret;

    /*
     * Method calls are ultimately read operations.  The result
     * should placed into the inbound buffer provided.  They
     * also supply outbound data--parameters for the object
     * method.  Currently if this is present it will be a
     * snapshot id.
     */
    /*ä¸Šé¢è¿™æ®µæ³¨é‡Šçš„æ„æ€æ˜¯è¯´é’ˆå¯¹å¯¹è±¡çš„method callæœ€ç»ˆå…¶å®æ˜¯å¯¹è±¡çš„è¯»æ“ä½œã€‚
      outboundè¡¨ç¤ºmethodè¾“å…¥å‚æ•°ï¼Œå½“å‰åªæ”¯æŒsnapidï¼›
      inboundè¡¨ç¤ºè¿”å›ç»“æœã€‚*/

    /*ä¸ºè¿”å›ç»“æœinboundåˆ†é…æ–°çš„å†…å­˜é¡µï¼Œ ä¸ºä½•è¦é‡æ–°åˆ†é…å†…å­˜ï¼Ÿ*/
    page_count = (u32)calc_pages_for(0, inbound_size);
    pages = ceph_alloc_page_vector(page_count, GFP_KERNEL);
    if (IS_ERR(pages))
        return PTR_ERR(pages);

    ret = -ENOMEM;
    /*åˆ›å»ºæ–°çš„rbd_obj_requestå¯¹è±¡å¹¶åˆå§‹åŒ–*/
    obj_request = rbd_obj_request_create(object_name, 0, inbound_size, OBJ_REQUEST_PAGES);
    if (!obj_request)
        goto out;

    obj_request-&gt;pages = pages;
    obj_request-&gt;page_count = page_count;

    /*åˆ›å»ºrbd_obj_requeståœ¨libcephå¯¹åº”çš„osd_requestå¯¹è±¡*/
    obj_request-&gt;osd_req = rbd_osd_req_create(rbd_dev, false, obj_request);
    if (!obj_request-&gt;osd_req)
        goto out;
    
    /*åˆå§‹åŒ–osd_requestä¸­çš„opå¯¹è±¡ï¼Œå®ƒçš„ç±»å‹ä¸ºCEPH_OSD_OP_CALLï¼Œè¡¨ç¤ºè°ƒç”¨è¿œç«¯OSDä¸­å¯¹è±¡çš„æ–¹æ³•*/
    osd_req_op_cls_init(obj_request-&gt;osd_req, 0, CEPH_OSD_OP_CALL, class_name, method_name);
    if (outbound_size) {
        /*å¦‚æœå­˜åœ¨è¾“å…¥å‚æ•°outboundï¼Œåˆ™ä¸ºå…¶åˆ†é…æ–°çš„å†…å­˜é¡µå¹¶å¤åˆ¶å…¶å†…å®¹*/

        struct ceph_pagelist *pagelist;

        pagelist = kmalloc(sizeof (*pagelist), GFP_NOFS);
        if (!pagelist)
            goto out;

        ceph_pagelist_init(pagelist);
        ceph_pagelist_append(pagelist, outbound, outbound_size); /*å°†outboundä¸­å†…å®¹å¤åˆ¶åˆ°pagelist*/
        osd_req_op_cls_request_data_pagelist(obj_request-&gt;osd_req, 0,pagelist); /*å°†pagelistä½œä¸ºopçš„è¾“å…¥å‚æ•°(request_data)*/
    }
    osd_req_op_cls_response_data_pages(obj_request-&gt;osd_req, 0,
            obj_request-&gt;pages, inbound_size, 0, false, false);/*å°†obj_request-&gt;pagesä½œä¸ºopçš„è¾“å‡ºç»“æœ(response_data)*/
    rbd_osd_req_format_read(obj_request);

    /*å°†rbd_object_requestå¯¹è±¡æäº¤ç»™åº•å±‚libcephå‘é€ç»™è¿œç«¯osdèŠ‚ç‚¹*/
    ret = rbd_obj_request_submit(osdc, obj_request);
    if (ret)
        goto out;

    /*ç­‰å¾…è¿œç«¯osdèŠ‚ç‚¹è¿”å›å“åº”*/
    ret = rbd_obj_request_wait(obj_request);
    if (ret)
        goto out;

    /*è¿œç«¯osdèŠ‚ç‚¹è¿”å›å“åº”åï¼Œresultä¸­ä¿å­˜è¿”å›ç»“æœ*/
    ret = obj_request-&gt;result;
    if (ret &lt; 0)
        goto out;

    rbd_assert(obj_request-&gt;xferred &lt; (u64)INT_MAX);
    ret = (int)obj_request-&gt;xferred;
    /*æ ¹æ®è¿œç«¯osdè¿”å›çš„æ•°æ®é‡xferredï¼Œå°†æ•°æ®æ‹·è´åˆ°inboundä¸­*/
    ceph_copy_from_page_vector(pages, inbound, 0, obj_request-&gt;xferred);
out:
    if (obj_request)
        rbd_obj_request_put(obj_request);
    else
        ceph_release_page_vector(pages, page_count);

return ret;
}
</code></pre></div></div>

<h4 id="23-rbd_dev_device_setup"><strong>2.3. rbd_dev_device_setup</strong></h4>

<p>â€ƒâ€ƒåŸºäºä¹‹å‰è·å–çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å†…æ ¸å—å±‚æä¾›çš„ç›¸å…³æ¥å£åˆ›å»ºä¸€ä¸ªæ–°çš„RBDå—è®¾å¤‡å¯¹è±¡ä¾›åº”ç”¨ä½¿ç”¨ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/drivers/block/rbd.c:

static int rbd_dev_device_setup(struct rbd_device *rbd_dev)
{
    int ret;

    /*é¦–å…ˆæ ¹æ®å…¨å±€å˜é‡rbd_dev_id_maxç”Ÿæˆä¸€ä¸ªæ–°çš„æœ€å¤§idå·*/
    /* generate unique id: find highest unique id, add one */
    rbd_dev_id_get(rbd_dev);

    /*æ ¹æ®idå·ç”Ÿæˆè®¾å¤‡åç§°*/
    /* Fill in the device name, now that we have its id. */
    BUILD_BUG_ON(DEV_NAME_LEN &lt; sizeof (RBD_DRV_NAME) + MAX_INT_FORMAT_WIDTH);
    sprintf(rbd_dev-&gt;name, "%s%d", RBD_DRV_NAME, rbd_dev-&gt;dev_id);

    /* Get our block major device number. */

    /*é€šè¿‡å—å±‚æ¥å£register_blkdevæ³¨å†Œä¸€ä¸ªæ–°çš„å—è®¾å¤‡*/
    ret = register_blkdev(0, rbd_dev-&gt;name);
    if (ret &lt; 0)
        goto err_out_id;
    rbd_dev-&gt;major = ret;

    /* Set up the blkdev mapping. */

    /*è°ƒç”¨å—å±‚æ¥å£åˆå§‹åŒ–gendiskå¯¹è±¡ï¼Œç»‘å®šå…¶IOå¤„ç†å‡½æ•°ä¸ºrbd_request_fn(æˆ‘ä»¬å°†ä»¥æ­¤ä¸ºå…¥å£æ¥åˆ†æIOæµç¨‹)*/
    ret = rbd_init_disk(rbd_dev);
    if (ret)
        goto err_out_blkdev;

    /*å¿«ç…§ç›¸å…³ï¼Œæš‚ä¸å…³å¿ƒ*/
    ret = rbd_dev_mapping_set(rbd_dev);
    if (ret)
        goto err_out_disk;
    /*è®¾å¤‡å®¹é‡*/
    set_capacity(rbd_dev-&gt;disk, rbd_dev-&gt;mapping.size / SECTOR_SIZE);

    /*åœ¨sysç›®å½•ä¸‹æ·»åŠ è®¾å¤‡*/
    ret = rbd_bus_add_dev(rbd_dev);
    if (ret)
        goto err_out_mapping;

    /* Everything's ready.  Announce the disk to the world. */

    /*é€šè¿‡add_diskæ¥å£åœ¨ç³»ç»Ÿä¸­å‘ˆç°ä¸€ä¸ªæ–°çš„å—è®¾å¤‡*/
    set_bit(RBD_DEV_FLAG_EXISTS, &amp;rbd_dev-&gt;flags);
    add_disk(rbd_dev-&gt;disk);

    pr_info("%s: added with size 0x%llx\n", rbd_dev-&gt;disk-&gt;disk_name,
        (unsigned long long) rbd_dev-&gt;mapping.size);

    return ret;

err_out_mapping:
    rbd_dev_mapping_clear(rbd_dev);
err_out_disk:
    rbd_free_disk(rbd_dev);
err_out_blkdev:
    unregister_blkdev(rbd_dev-&gt;major, rbd_dev-&gt;name);
err_out_id:
    rbd_dev_id_put(rbd_dev);
    rbd_dev_mapping_clear(rbd_dev);

    return ret;
}
</code></pre></div></div>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2018/01/RBD-client-2/">ã€Rados Block Deviceã€‘ä¸‰ã€Clientå†…æ ¸RBDé©±åŠ¨åˆ†æï¼è®¾å¤‡æ˜ å°„æµç¨‹</a></p>
:ET