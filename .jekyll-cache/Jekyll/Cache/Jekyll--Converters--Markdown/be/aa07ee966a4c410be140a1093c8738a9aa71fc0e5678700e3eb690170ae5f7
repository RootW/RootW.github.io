I"‘Y<h3 id="4-libcephkoä¸­messengeræ¨¡å—åˆ†æ">4. libceph.koä¸­messengeræ¨¡å—åˆ†æ</h3>

<p>â€ƒâ€ƒmessengeræ¨¡å—(ä¿¡ä½¿)æ˜¯libcephä¸­ç›¸å¯¹æ¯”è¾ƒç‹¬ç«‹çš„éƒ¨åˆ†ï¼Œæ—¨åœ¨ä¸ºä¸Šå±‚å„ç§ç½‘ç»œå®¢æˆ·ç«¯(å¦‚mon_clientã€osd_client)æä¾›ç¨³å®šå¯é ã€æœ‰åºçš„ç½‘ç»œæœåŠ¡ã€‚messengeræ„å»ºåœ¨ç½‘ç»œTCPåè®®ä¹‹ä¸Šï¼Œè™½ç„¶TCPåè®®æœ¬èº«æ˜¯é¢å‘è¿æ¥ä¸”å¯é çš„ç½‘ç»œåè®®ï¼Œä½†æ˜¯TCPè¿æ¥æœ‰å¯èƒ½æ–­å¼€(brokenï¼Œéé•¿è¿æ¥æƒ…å†µä¸‹ä¼šå‘ç”Ÿï¼›é•¿è¿æ¥å­˜åœ¨åº•å±‚ç½‘ç»œæ•…éšœæ’é™¤åä¸Šå±‚åº”ç”¨æ„ŸçŸ¥ä¸åŠæ—¶çš„é—®é¢˜)ã€‚ä¸ºè§£å†³TCPçŸ­è¿æ¥ä¸å¯é çš„é—®é¢˜ï¼Œmessengeré€šè¿‡é—´éš”æ€§åœ°é‡è¿æ–¹æ¡ˆ(back offï¼Œå½“æœ‰æ¶ˆæ¯è¦å‘é€æ—¶)æˆ–è€…ç­‰å¾…æ–¹æ¡ˆ(stand byï¼Œå½“æ— æ¶ˆæ¯è¦å‘é€æ—¶)æ¥è§£å†³ã€‚åŒæ—¶ä¼šç»™æ¯ä¸ªå‘é€çš„æ¶ˆæ¯å¸¦ä¸Šå”¯ä¸€çš„åºåˆ—å·(seq)ï¼Œç”¨ä»¥åŒºåˆ†æ˜¯å¦ä¸ºé‡å¤æ¶ˆæ¯ã€‚</p>

<p>â€ƒâ€ƒmessengeræ¨¡å—å†…éƒ¨æ¶æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p>

<div align="center">
<img src="/images/posts/ceph/rbd_6.jpg" height="400" width="700" />  
</div>

<blockquote>
  <ul>
    <li>ä»å‘é€æµç¨‹æ¥çœ‹(å›¾ä¸­å®çº¿)ï¼Œåº”ç”¨ç¨‹åº(å¦‚rbdå‘½ä»¤)è°ƒç”¨ceph_con_sendè¿›è¡Œæ¶ˆæ¯å‘é€ï¼›è¯¥å‡½æ•°ä¼šå”¤é†’å‘é€è¿æ¥å¯¹åº”çš„å·¥ä½œä»»åŠ¡ï¼›åœ¨å·¥ä½œä»»åŠ¡è¿›ç¨‹ä¸­ï¼Œé€šè¿‡try_writeå‡½æ•°è°ƒç”¨kernel_sendmsgè®¿é—®åº•å±‚ç½‘ç»œåè®®æ ˆï¼Œæœ€ç»ˆè§¦å‘ç½‘å¡å‘åŒ…ï¼›</li>
    <li>ä»æ¥æ”¶æµç¨‹æ¥çœ‹(å›¾ä¸­è™šçº¿)ï¼Œç½‘å¡æ”¶åŒ…åé€šè¿‡ä¸­æ–­å’Œåè®®æ ˆå›è°ƒå”¤é†’å·¥ä½œä»»åŠ¡ï¼›å·¥ä½œä»»åŠ¡é€šè¿‡try_readè°ƒç”¨kernel_recvmsgä»ç½‘ç»œåè®®æ ˆä¸­è¯»å–æ¶ˆæ¯å†…å®¹ï¼›æœ€åè°ƒç”¨è¿æ¥åˆå§‹åŒ–æ—¶æŒ‡å®šçš„æ¶ˆæ¯å›è°ƒå‡½æ•°å¯¹æ¶ˆæ¯è¿›è¡Œå¤„ç†ã€‚</li>
  </ul>
</blockquote>

<h4 id="41-æ­£å¸¸ç½‘ç»œæ”¶å‘çš„å¤„ç†"><strong>4.1. æ­£å¸¸ç½‘ç»œæ”¶å‘çš„å¤„ç†</strong></h4>

<h5 id="411-socketè¿æ¥é˜¶æ®µ"><strong>4.1.1 socketè¿æ¥é˜¶æ®µ</strong></h5>

<p>â€ƒâ€ƒæ¯å½“ä¸Šå±‚é€šè¿‡ceph_con_initåˆ›å»ºä¸€ä¸ªceph_connectionå¯¹è±¡(å¯¹åº•å±‚TCPè¿æ¥çš„å°è£…ï¼Œå«æœ‰è‡ªèº«çš„çŠ¶æ€å˜åŒ–)å¹¶è°ƒç”¨ceph_con_openæ‰“å¼€è¯¥è¿æ¥å(è¿æ¥çŠ¶æ€å˜ä¸ºPREOPEN)ï¼Œå°±ä¼šåœ¨å†…æ ¸å·¥ä½œé˜Ÿåˆ—ä¸­æ·»åŠ ä¸€é¡¹æ–°çš„ä»»åŠ¡ï¼Œå¹¶å¯¹è¯¥ä»»åŠ¡è¿›è¡Œä¸€æ¬¡è°ƒåº¦ï¼Œå…¶å…¥å£å‡½æ•°ä¸ºcon_workï¼Œä»£ç æ¡†æ¶å¦‚ä¸‹æ‰€ç¤ºï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/messenger.c:

static void con_work(struct work_struct *work)
{
    struct ceph_connection *con = container_of(work, struct ceph_connection,
        work.work);

    ...
    while (true) {
        ...
        ret = try_read(con); /*socketè¿æ¥åˆå§‹åŒ–é˜¶æ®µä¸è¿›è¡Œä»»ä½•å·¥ä½œ*/
        ...
        ret = try_write(con); /*å»ºç«‹socketè¿æ¥å¹¶è®¾å®šsocketå›è°ƒå‡½æ•°*/
        ...
        break;
    }
    ...
}
</code></pre></div></div>

<p>â€ƒâ€ƒconection workeré¦–æ¬¡è¢«è°ƒåº¦æ—¶è¿›å…¥socketè¿æ¥é˜¶æ®µï¼Œå®Œæˆçš„ä¸»è¦å·¥ä½œæ˜¯å»ºç«‹TCP socketè¿æ¥ï¼Œå¹¶å°†ceph_connectionçš„çŠ¶æ€ç½®ä¸ºCONNECTINGï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/messenger.c:

static int try_write(struct ceph_connection *con)
{
    ...

    if (con-&gt;state == CON_STATE_PREOPEN) { /*é¦–æ¬¡è¢«è°ƒåº¦æ—¶ï¼Œè¿æ¥çŠ¶æ€ä¸ºPREOPEN*/
        BUG_ON(con-&gt;sock);
        con-&gt;state = CON_STATE_CONNECTING; /*æ‰§è¡Œå®Œä¸‹é¢è¿™äº›åŠ¨ä½œåçŠ¶æ€æ›´æ–°ä¸ºCONNECTING*/

        con_out_kvec_reset(con); /*é‡ç½®å½“å‰è¿æ¥conçš„å‘é€ç¼“å†²åŒºï¼Œå¯¹åº”con-&gt;out_kvec_* */
        prepare_write_banner(con); /*å°†å®¢æˆ·ç«¯çš„bannerå†…å®¹æ”¾å…¥å‘é€ç¼“å†²åŒº*/
        prepare_read_banner(con); /*å‡†å¤‡æ¥æ”¶æœåŠ¡ç«¯çš„bannerå†…å®¹*/

        BUG_ON(con-&gt;in_msg);
        con-&gt;in_tag = CEPH_MSGR_TAG_READY; /*é‡ç½®æ¶ˆæ¯æ¥æ”¶çŠ¶æ€ä¸ºREADYï¼Œè¡¨ç¤ºå¯æ¥æ”¶ä»»æ„æ¶ˆæ¯ç±»åˆ«ï¼Œä¸åŒç±»åˆ«ç”±CEPH_MSGR_TAG_*è¿›è¡ŒåŒºåˆ† */
        ret = ceph_tcp_connect(con); /*åˆ›å»ºå¹¶è¿æ¥socketï¼ŒåŒæ—¶æŒ‡å®šåè®®æ ˆçš„å›è°ƒå‡½æ•°*/
        if (ret &lt; 0) {
            con-&gt;error_msg = "connect error";
            goto out;
        }
    }

more_kvec:
    ...
    if (con-&gt;out_kvec_left) { 
        /*è°ƒç”¨åº•å±‚kernel_sendmsgå°†å½“å‰è¿æ¥conå‘é€ç¼“å†²ä¸­çš„å†…å®¹è¿›è¡Œå‘é€*/
        ret = write_partial_kvec(con);
        if (ret &lt;= 0)
            goto out;
    }
    ...
}

static int ceph_tcp_connect(struct ceph_connection *con)
{
    struct sockaddr_storage *paddr = &amp;con-&gt;peer_addr.in_addr;
    struct socket *sock;
    int ret;

    BUG_ON(con-&gt;sock);
    ret = sock_create_kern(con-&gt;peer_addr.in_addr.ss_family, SOCK_STREAM,
        IPPROTO_TCP, &amp;sock);
    ...
    sock-&gt;sk-&gt;sk_allocation = GFP_NOFS;

    set_sock_callbacks(sock, con);

    con_sock_state_connecting(con);
    ret = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)paddr, sizeof(*paddr),
        O_NONBLOCK);
    ...
    con-&gt;sock = sock;
    return 0;
}

static void set_sock_callbacks(struct socket *sock,
    struct ceph_connection *con)
{
    struct sock *sk = sock-&gt;sk;
    sk-&gt;sk_user_data = con;
    sk-&gt;sk_data_ready = ceph_sock_data_ready; /*åè®®æ ˆæ”¶åˆ°åŒ…åä¼šå›è°ƒè¯¥å‡½æ•°*/
    sk-&gt;sk_write_space = ceph_sock_write_space;
    sk-&gt;sk_state_change = ceph_sock_state_change; /*åè®®æ ˆæ”¹å˜socketçŠ¶æ€æ—¶ä¼šå›è°ƒè¯¥å‡½æ•°*/
}

static void ceph_sock_data_ready(struct sock *sk, int count_unused)
{
    struct ceph_connection *con = sk-&gt;sk_user_data;

    ...
    queue_con(con); /*å†æ¬¡å”¤é†’å·¥ä½œä»»åŠ¡*/
    ...
}
</code></pre></div></div>

<h5 id="412-åå•†é˜¶æ®µ"><strong>4.1.2 åå•†é˜¶æ®µ</strong></h5>

<p>â€ƒâ€ƒsocketè¿æ¥é˜¶æ®µæœ€åï¼Œå‘æœåŠ¡ç«¯å‘é€äº†å®¢æˆ·ç«¯çš„bannerï¼Œå¹¶ç­‰å¾…æœåŠ¡ç«¯å›å¤bannerã€‚å½“æ”¶åˆ°æœåŠ¡ç«¯å›å¤banneråï¼Œconnection workerå†æ¬¡è¢«å”¤é†’ï¼Œæ­¤æ—¶ä¸»è¦å®Œæˆå®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯çš„ä¿¡æ¯åå•†ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/messenger.c:

static void con_work(struct work_struct *work)
{
    struct ceph_connection *con = container_of(work, struct ceph_connection,
        work.work);

    ...
    while (true) {
        ...
        ret = try_read(con); /*è¯»å–æœåŠ¡ç«¯è¿”å›çš„bannerå¹¶è¿›å…¥åå•†é˜¶æ®µ*/
        ...
        ret = try_write(con); /*å‘æœåŠ¡ç«¯å‘é€åå•†ä¿¡æ¯*/
        ...
        break;
    }
    ...
}

static int try_read(struct ceph_connection *con)
{
    ...
    if (con-&gt;state == CON_STATE_CONNECTING) {
        ret = read_partial_banner(con); /*è¯»å–æœåŠ¡ç«¯çš„bannerä¿¡æ¯*/
        if (ret &lt;= 0)
            goto out;
        ret = process_banner(con); /*å¯¹bannerè¿›è¡Œæ ¡éªŒ*/
        if (ret &lt; 0)
            goto out;

        con-&gt;state = CON_STATE_NEGOTIATING; /*æ ¡éªŒé€šè¿‡åè¿›å…¥åå•†é˜¶æ®µ*/

        /*
         * Received banner is good, exchange connection info.
         * Do not reset out_kvec, as sending our banner raced
         * with receiving peer banner after connect completed.
         */
        ret = prepare_write_connect(con); /*å‡†å¤‡å…¨å±€è¿æ¥å·ç­‰åå•†ä¿¡æ¯*/
        if (ret &lt; 0)
            goto out;
        prepare_read_connect(con); /*å‡†å¤‡æ¥æ”¶æœåŠ¡ç«¯è¿”å›çš„åå•†ä¿¡æ¯*/

        /* Send connection info before awaiting response */
        goto out;
    }
    ...
ï½
</code></pre></div></div>

<h5 id="413-æ­£å¸¸æ‰“å¼€é˜¶æ®µ"><strong>4.1.3 æ­£å¸¸æ‰“å¼€é˜¶æ®µ</strong></h5>

<p>â€ƒâ€ƒæ”¶åˆ°æœåŠ¡ç«¯çš„åå•†æ¶ˆæ¯åï¼Œconnection workerå†æ¬¡è¢«å”¤é†’ï¼Œè¿›è¡ŒæœåŠ¡ç«¯åå•†æ¶ˆæ¯çš„å¤„ç†å¹¶è¿›å…¥æ­£å¸¸æ‰“å¼€é˜¶æ®µå¯æ”¶å‘æ¶ˆæ¯ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/messenger.c:

static void con_work(struct work_struct *work)
{
    struct ceph_connection *con = container_of(work, struct ceph_connection,
        work.work);

    ...
    while (true) {
        ...
        ret = try_read(con); /*è¯»å–æœåŠ¡ç«¯åå•†ä¿¡æ¯å¹¶è¿›å…¥æ­£å¸¸æ‰“å¼€é˜¶æ®µï¼Œå¯æ­£å¸¸æ¥æ”¶æ¶ˆæ¯*/
        ...
        ret = try_write(con); /*å¯æ­£å¸¸å‘é€æ¶ˆæ¯*/
        ...
        break;
    }
    ...
}

static int try_read(struct ceph_connection *con)
{
    ...
    if (con-&gt;state == CON_STATE_NEGOTIATING) {
        ret = read_partial_connect(con); /*è¯»å–æœåŠ¡ç«¯åå•†ä¿¡æ¯åˆ°in_replyä¸­*/
        if (ret &lt;= 0)
            goto out;
        ret = process_connect(con); /*å¤„ç†åå•†æ¶ˆæ¯å¹¶è¿›å…¥æ­£å¸¸æ‰“å¼€é˜¶æ®µ*/
        if (ret &lt; 0)
            goto out;
        goto more;
    }
    ...
}

static int process_connect(struct ceph_connection *con)
{
    ...
    switch (con-&gt;in_reply.tag) { /*in_replyä¸­è®°å½•æœåŠ¡ç«¯è¿”å›çš„åå•†ä¿¡æ¯*/
        ...
    case CEPH_MSGR_TAG_SEQ:
    case CEPH_MSGR_TAG_READY:
        ...

        /*è®°å½•æœåŠ¡ç«¯è¿”å›çš„åå•†æ¶ˆæ¯å¹¶å°†è¿æ¥çŠ¶æ€ç½®ä¸ºOPEN*/
    
        con-&gt;state = CON_STATE_OPEN;
        con-&gt;auth_retry = 0;    /* we authenticated; clear flag */
        con-&gt;peer_global_seq = le32_to_cpu(con-&gt;in_reply.global_seq);
        con-&gt;connect_seq++;
        con-&gt;peer_features = server_feat;
        ...
        con-&gt;delay = 0;      /* reset backoff memory */

        if (con-&gt;in_reply.tag == CEPH_MSGR_TAG_SEQ) {
            prepare_write_seq(con);
            prepare_read_seq(con);
        } else {
            prepare_read_tag(con);
        }
        break;
    }
}
</code></pre></div></div>

<h5 id="414-æ¶ˆæ¯æ”¶å‘è¿‡ç¨‹"><strong>4.1.4 æ¶ˆæ¯æ”¶å‘è¿‡ç¨‹</strong></h5>

<p>â€ƒâ€ƒå®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯è¿›è¡Œæ­£å¸¸æ¶ˆæ¯æ”¶å‘æ—¶ï¼Œæ€»æ˜¯å…ˆåœ¨ç½‘ç»œè¿æ¥ä¸Šå‘é€ä¸€ä¸ªå­—èŠ‚çš„tagï¼Œå†å‘é€å®é™…çš„æ¶ˆæ¯ã€‚åŸå› æ˜¯ä¸¤è€…å¯ä»¥é€šè¿‡tagæ¥æ˜ç¡®æ¶ˆæ¯çš„å…·ä½“ç±»åˆ«å’Œè§£ææ ¼å¼ã€‚ç½‘ç»œæµä¸Šçš„æ•°æ®å¤§ä½“å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p>

<div align="center">
<img src="/images/posts/ceph/rbd_message.jpg" height="100" width="700" />  
</div>

<p>â€ƒâ€ƒæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹æ¶ˆæ¯çš„æ¥æ”¶ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/messenger.c:

static int try_read(struct ceph_connection *con)
{
    ...

    if (con-&gt;in_tag == CEPH_MSGR_TAG_READY) { /*READYä»£è¡¨å‡†å¤‡å¥½æ¥æ”¶å…·ä½“çš„tagå†…å®¹*/
        /*
         * what's next?
         */
        ret = ceph_tcp_recvmsg(con-&gt;sock, &amp;con-&gt;in_tag, 1); /*ä»ç½‘ç»œä¸­æ¥æ”¶ä¸€ä¸ªå­—èŠ‚çš„tag*/
        if (ret &lt;= 0)
            goto out;

        /*æ ¹æ®tagå†…å®¹å‡†å¤‡æ¥æ”¶åç»­çš„æ¶ˆæ¯*/
        switch (con-&gt;in_tag) {
        case CEPH_MSGR_TAG_MSG:
            prepare_read_message(con);
            break;
        case CEPH_MSGR_TAG_ACK:
            prepare_read_ack(con);
            break;
        case CEPH_MSGR_TAG_CLOSE:
            con_close_socket(con);
            con-&gt;state = CON_STATE_CLOSED;
            goto out;
        default:
            goto bad_tag;
        }
    }

    /*å¦‚æœtagä¸ºMSGï¼Œåˆ™è¡¨ç¤ºåç»­ä¸ºä¸€ä¸ªå®é™…çš„messageæ¶ˆæ¯ï¼Œå¼€å§‹æ¥æ”¶æ¶ˆæ¯å†…å®¹å¹¶è°ƒç”¨å›è°ƒå‡½æ•°*/
    if (con-&gt;in_tag == CEPH_MSGR_TAG_MSG) {
        ret = read_partial_message(con); /*æ³¨æ„ï¼Œè¿™é‡Œé€šè¿‡å›è°ƒalloc_msgæ‰¾åˆ°ceph_osd_requestä¸­åˆ†é…å¥½çš„r_reply*/
        ...
        if (con-&gt;in_tag == CEPH_MSGR_TAG_READY)
            goto more;
        process_message(con);
        if (con-&gt;state == CON_STATE_OPEN)
            prepare_read_tag(con);
        goto more;
    }

    /*å¦‚æœtagä¸ºACKæˆ–SEQï¼Œåˆ™è¡¨ç¤ºåç»­ä¸ºä¸€ä¸ªæœåŠ¡ç«¯è¿”å›çš„ç¡®è®¤å·ï¼Œå¯ä»¥é‡Šæ”¾å·²ç¡®è®¤çš„å‘é€æ¶ˆæ¯*/
    if (con-&gt;in_tag == CEPH_MSGR_TAG_ACK ||
        con-&gt;in_tag == CEPH_MSGR_TAG_SEQ) {
        /*
         * the final handshake seq exchange is semantically
         * equivalent to an ACK
         */
        ret = read_partial_ack(con);
        ...
        process_ack(con);
        goto more;
    }
    ...
}
</code></pre></div></div>

<p>â€ƒâ€ƒæ¥ä¸‹æ¥å†æ¥çœ‹çœ‹æ¶ˆæ¯çš„å‘é€ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/messenger.c:

static int try_write(struct ceph_connection *con)
{
more:
    ...
more_kvec:    
    if (con-&gt;out_kvec_left) { /*å°†å‘é€ç¼“å†²åŒºä¸­çš„å†…å®¹é€šè¿‡ç½‘ç»œè¿›è¡Œå‘é€*/
        ret = write_partial_kvec(con);
        if (ret &lt;= 0)
            goto out;
    }

    /* msg pages? */
    if (con-&gt;out_msg) { /*å¦‚æœå·²é€‰å®šå½“å‰å‘é€æ¶ˆæ¯out_msgä¸”è¿˜æœªå®Œæˆå‘é€ï¼Œåˆ™å‘é€æ¶ˆæ¯åŒ…å«çš„æ•°æ®*/
        if (con-&gt;out_msg_done) {
            ceph_msg_put(con-&gt;out_msg);
            con-&gt;out_msg = NULL;   /* we're done with this one */
            goto do_next;
        }

        ret = write_partial_message_data(con);
        if (ret == 1)
            goto more_kvec;  /* we need to send the footer, too! */
        if (ret == 0)
            goto out;
        if (ret &lt; 0) {
            dout("try_write write_partial_message_data err %d\n", ret);
            goto out;
        }
    }

do_next:
    if (con-&gt;state == CON_STATE_OPEN) {
        /* is anything else pending? */
        if (!list_empty(&amp;con-&gt;out_queue)) {
            /*å¦‚æœå‘é€é˜Ÿåˆ—out_queueä¸­æœ‰å¾…å‘é€çš„æ¶ˆæ¯ï¼Œåˆ™å–å‡ºä¸€ä¸ªæ¶ˆæ¯æ”¾åˆ°out_msgä¸­å¹¶å‘é€å…¶å¤´éƒ¨å†…å®¹(æ¶ˆæ¯ä¸­åŒ…å«çš„æ•°æ®åœ¨å‰é¢ä»£ç ä¸­å‘é€)*/
            prepare_write_message(con);
            goto more;
        }
        if (con-&gt;in_seq &gt; con-&gt;in_seq_acked) {
            /*å¦‚æœå½“å‰æ”¶åˆ°æ¶ˆæ¯çš„åºåˆ—å·å¤§äºå·²ç»ç¡®è®¤çš„åºåˆ—å·ï¼Œåˆ™å‡†å¤‡å‘é€æ–°çš„ç¡®è®¤å·*/
            prepare_write_ack(con);
            goto more;
        }
        ...
    }
    ...
}
</code></pre></div></div>

<p>â€ƒâ€ƒæœ€åæˆ‘ä»¬æ¥çœ‹çœ‹ceph_msgçš„ç»“æ„å®šä¹‰ï¼Œå‘é€è€…è´Ÿè´£å°†è¯·æ±‚å†…å®¹å¡«å…¥ceph_msgä»¥ä¾›ç½‘ç»œå±‚å‘é€ï¼›ç½‘ç»œå±‚æ¥æ”¶æ¶ˆæ¯åä¹Ÿå…ˆå¡«å…¥ceph_msgå†äº¤ç”±ä¸Šå±‚åº”ç”¨å¤„ç†å“åº”ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/ceph/messenger.h:

struct ceph_msg {
    struct ceph_msg_header hdr;	/* header */
    struct ceph_msg_footer footer;	/* footer */
    struct kvec front;              /* unaligned blobs of message */
    struct ceph_buffer *middle;

    size_t				data_length;
    struct list_head		data;
    struct ceph_msg_data_cursor	cursor;

    struct ceph_connection *con;
    struct list_head list_head;	/* links for connection lists */

    struct kref kref;
    bool front_is_vmalloc;
    bool more_to_follow;
    bool needs_out_seq;
    int front_alloc_len;
    unsigned long ack_stamp;        /* tx: when we were acked */

    struct ceph_msgpool *pool;
};
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/ceph/msgr.h:

struct ceph_msg_header {
    __le64 seq;       /* message seq# for this session */
    __le64 tid;       /* transaction id */
    __le16 type;      /* message type */
    __le16 priority;  /* priority.  higher value == higher priority */
    __le16 version;   /* version of message encoding */

    __le32 front_len; /* bytes in main payload */
    __le32 middle_len;/* bytes in middle payload */
    __le32 data_len;  /* bytes of data payload */
    __le16 data_off;  /* sender: include full offset;
                        receiver: mask against ~PAGE_MASK */

    struct ceph_entity_name src;
    __le32 reserved;
    __le32 crc;       /* header crc32c */
} __attribute__ ((packed));
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/ceph/ceph_fs.h:

/*
 * message types
 */

/* misc */
#define CEPH_MSG_SHUTDOWN               1
#define CEPH_MSG_PING                   2

/* client &lt;-&gt; monitor */
#define CEPH_MSG_MON_MAP                4
#define CEPH_MSG_MON_GET_MAP            5
#define CEPH_MSG_STATFS                 13
#define CEPH_MSG_STATFS_REPLY           14
#define CEPH_MSG_MON_SUBSCRIBE          15
#define CEPH_MSG_MON_SUBSCRIBE_ACK      16
#define CEPH_MSG_AUTH			17
#define CEPH_MSG_AUTH_REPLY		18
#define CEPH_MSG_MON_GET_VERSION        19
#define CEPH_MSG_MON_GET_VERSION_REPLY  20

/* client &lt;-&gt; mds */
#define CEPH_MSG_MDS_MAP                21

#define CEPH_MSG_CLIENT_SESSION         22
#define CEPH_MSG_CLIENT_RECONNECT       23

#define CEPH_MSG_CLIENT_REQUEST         24
#define CEPH_MSG_CLIENT_REQUEST_FORWARD 25
#define CEPH_MSG_CLIENT_REPLY           26
#define CEPH_MSG_CLIENT_CAPS            0x310
#define CEPH_MSG_CLIENT_LEASE           0x311
#define CEPH_MSG_CLIENT_SNAP            0x312
#define CEPH_MSG_CLIENT_CAPRELEASE      0x313

/* pool ops */
#define CEPH_MSG_POOLOP_REPLY           48
#define CEPH_MSG_POOLOP                 49


/* osd */
#define CEPH_MSG_OSD_MAP                41
#define CEPH_MSG_OSD_OP                 42
#define CEPH_MSG_OSD_OPREPLY            43
#define CEPH_MSG_WATCH_NOTIFY           44
</code></pre></div></div>

<h4 id="42-tcpè¿æ¥æ•…éšœåçš„å¤„ç†"><strong>4.2. TCPè¿æ¥æ•…éšœåçš„å¤„ç†</strong></h4>

<p>â€ƒâ€ƒmessengeræ¨¡å—åœ¨ä¸¤ç§æƒ…å†µä¸‹å¯ä»¥è·çŸ¥TCPè¿æ¥æ•…éšœï¼šä¸€ç§æ˜¯åº•å±‚ç½‘ç»œåè®®æ ˆé€šçŸ¥socketçŠ¶æ€æ”¹å˜ï¼›å¦å¤–ä¸€ç§æ˜¯åœ¨é€šè¿‡socketè¿›è¡Œç½‘ç»œæ”¶å‘åŒ…æ—¶ï¼Œè¿”å›é”™è¯¯ä¿¡æ¯ã€‚</p>

<h5 id="421-ç½‘ç»œåè®®æ ˆé€šè¿‡å›è°ƒä¸ŠæŠ¥æ•…éšœ"><strong>4.2.1 ç½‘ç»œåè®®æ ˆé€šè¿‡å›è°ƒä¸ŠæŠ¥æ•…éšœ</strong></h5>

<p>â€ƒâ€ƒåœ¨ç¬¬ä¸€ç§æƒ…å†µä¸‹ï¼Œç½‘ç»œåè®®æ ˆåœ¨å‘ç°TCPè¿æ¥æ•…éšœåï¼Œé€šè¿‡è°ƒç”¨å›è°ƒceph_sock_state_changeå‡½æ•°é€šçŸ¥messengeråº•å±‚socketå¤„äºå…³é—­çŠ¶æ€ã€‚ceph_sock_state_changeå‡½æ•°åœ¨æ›´æ–°socketçŠ¶æ€åä¼šé‡æ–°è°ƒåº¦connection workï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/messenger.c:

static void ceph_sock_state_change(struct sock *sk)
{
    struct ceph_connection *con = sk-&gt;sk_user_data;

    switch (sk-&gt;sk_state) {
    case TCP_CLOSE: /*å‘ç°åº•å±‚socketå·²å…³é—­*/
        dout("%s TCP_CLOSE\n", __func__);
    case TCP_CLOSE_WAIT:
        dout("%s TCP_CLOSE_WAIT\n", __func__);
        con_sock_state_closing(con);
        con_flag_set(con, CON_FLAG_SOCK_CLOSED); /*å°†è¿æ¥çŠ¶æ€ç½®ä¸ºå…³é—­*/
        queue_con(con); /*é‡æ–°å”¤é†’å·¥ä½œä»»åŠ¡*/
        break;
    case TCP_ESTABLISHED:
        ...
        break;
    default:	/* Everything else is uninteresting */
        break;
    }
}
</code></pre></div></div>

<p>â€ƒâ€ƒå·¥ä½œä»»åŠ¡è¢«è°ƒåº¦åï¼Œå‘ç°è¿æ¥çŠ¶æ€è¢«å…³é—­ï¼Œè¿›å…¥æ•…éšœå¤„ç†æµç¨‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/messenger.c:

static void con_work(struct work_struct *work)
{
    struct ceph_connection *con = container_of(work, struct ceph_connection,
        work.work);

    ...
    while (true) {
        if ((fault = con_sock_closed(con))) {
            /*å·¥ä½œä»»åŠ¡è¢«è°ƒåº¦æ—¶é¦–å…ˆåˆ¤æ–­è¿æ¥æ˜¯å¦å¤„äºå…³é—­çŠ¶æ€ï¼Œå¦‚æœå·²å…³åˆ™è·³è½¬å‡ºå¾ªç¯è¿›è¡Œæ•…éšœå¤„ç†*/
            dout("%s: con %p SOCK_CLOSED\n", __func__, con);
            break;
        }
        ...
        ret = try_read(con); 
        ...
        ret = try_write(con); 
        ...
        break;
    }

    /*ä¸‹é¢æ˜¯æ•…éšœå¤„ç†é€»è¾‘*/
    if (fault)
        con_fault(con);
    ...
}
</code></pre></div></div>

<h5 id="422-é€šè¿‡ç½‘ç»œæ”¶å‘å‡½æ•°è¿”å›ç»“æœè·çŸ¥è¿æ¥æ•…éšœ"><strong>4.2.2 é€šè¿‡ç½‘ç»œæ”¶å‘å‡½æ•°è¿”å›ç»“æœè·çŸ¥è¿æ¥æ•…éšœ</strong></h5>

<p>â€ƒâ€ƒæ¯ä¸ªè¿æ¥çš„å·¥ä½œä»»åŠ¡åœ¨æ”¶å‘è¿‡ç¨‹ä¸­ï¼Œå¦‚æœåº•å±‚å‡½æ•°è¿”å›é”™è¯¯ï¼Œä¹Ÿå¯è·çŸ¥ç½‘ç»œè¿æ¥æ•…éšœï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/net/ceph/messenger.c:

static void con_work(struct work_struct *work)
{
    struct ceph_connection *con = container_of(work, struct ceph_connection,
        work.work);

    ...
    while (true) {
        ...
        ret = try_read(con);
        if (ret &lt; 0) { /*æ”¶åŒ…æ—¶åº•å±‚è¿”å›é”™è¯¯*/
            if (ret == -EAGAIN)
                continue;
            con-&gt;error_msg = "socket error on read";
            fault = true;
            break;
        }
        
        ret = try_write(con); 
        if (ret &lt; 0) { /*å‘åŒ…æ—¶åº•å±‚è¿”å›é”™è¯¯*/
            if (ret == -EAGAIN)
                continue;
            con-&gt;error_msg = "socket error on write";
            fault = true;
        }

        break;
    }

    /*ä¸‹é¢æ˜¯æ•…éšœå¤„ç†é€»è¾‘*/
    if (fault)
        con_fault(con);
    ...
}
</code></pre></div></div>

<h5 id="423-socketè¿æ¥æ•…éšœå¤„ç†é€»è¾‘"><strong>4.2.3 socketè¿æ¥æ•…éšœå¤„ç†é€»è¾‘</strong></h5>

<p>â€ƒâ€ƒè¿æ¥æ•…éšœçš„å¤„ç†æœ‰ä¸¤ç§æ–¹å¼ï¼šä¸€ç§æ˜¯back offï¼Œå³å»¶æ—¶é‡è¿ï¼›åˆ«ä¸€ç§æ˜¯stand byï¼Œå³ç­‰å¾…æœ‰æ–°æ¶ˆæ¯æ—¶å†é‡è¯•ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
static void con_fault(struct ceph_connection *con)
{
    ...
    con_close_socket(con); /*å…³é—­åº•å±‚socket*/

    ...
    if (con-&gt;in_msg) {
        /*å¦‚æœæœ‰æ–°æ¥æ”¶åˆ°æ¶ˆæ¯ï¼Œåˆ™é‡Šæ”¾è¯¥æ¶ˆæ¯*/
        BUG_ON(con-&gt;in_msg-&gt;con != con);
        con-&gt;in_msg-&gt;con = NULL;
        ceph_msg_put(con-&gt;in_msg);
        con-&gt;in_msg = NULL;
        con-&gt;ops-&gt;put(con);
    }

    /*å¯¹äºå·²ç»å‘é€ä½†è¿˜æœªæ”¶åˆ°å¯¹æ–¹ç¡®è®¤çš„æ¶ˆæ¯ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ç½‘ç»œé‡è¿åå¯¹å®ƒä»¬è¿›è¡Œé‡å‘*/
    /* Requeue anything that hasn't been acked */
    list_splice_init(&amp;con-&gt;out_sent, &amp;con-&gt;out_queue);

    /* If there are no messages queued or keepalive pending, place
     * the connection in a STANDBY state */
    if (list_empty(&amp;con-&gt;out_queue) &amp;&amp;
            !con_flag_test(con, CON_FLAG_KEEPALIVE_PENDING)) {

        /*å¦‚æœå‘é€é˜Ÿåˆ—ä¸ºç©ºä¸”ä¸éœ€è¦å‘é€å¿ƒè·³æ¶ˆæ¯æ—¶ï¼Œå°†å½“å‰è¿æ¥ç½®ä¸ºstand byçŠ¶æ€*/

        dout("fault %p setting STANDBY clearing WRITE_PENDING\n", con);
        con_flag_clear(con, CON_FLAG_WRITE_PENDING);
        con-&gt;state = CON_STATE_STANDBY;
    } else {
        
        /*å¦‚æœè¿˜æœ‰å¾…å‘é€çš„æ¶ˆæ¯ï¼Œé‚£ä¹ˆå¿è¯•ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¿ï¼›ç­‰å¾…æ—¶é—´æ¯æ¬¡ç¿»å€*/

        /* retry after a delay. */
        con-&gt;state = CON_STATE_PREOPEN;
        if (con-&gt;delay == 0)
            con-&gt;delay = BASE_DELAY_INTERVAL;
        else if (con-&gt;delay &lt; MAX_DELAY_INTERVAL)
            con-&gt;delay *= 2;
        con_flag_set(con, CON_FLAG_BACKOFF);
        queue_con(con);
    }
}
</code></pre></div></div>

<p>â€ƒâ€ƒå½“è¿æ¥å¤„ç†stand byçŠ¶æ€æ—¶ï¼Œå¦‚æœæœ‰æ–°çš„æ¶ˆæ¯é€šè¿‡ceph_con_sendå‘é€ï¼Œå…¶å†…éƒ¨ä¼šæ¸…é™¤stand byçŠ¶æ€å¹¶é‡ç½®ä¸ºPREOPENä»¥å¿è¯•è¿›è¡Œé‡è¿ã€‚</p>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2018/01/RBD-client-4/">ã€Rados Block Deviceã€‘äº”ã€Clientå†…æ ¸RBDé©±åŠ¨åˆ†æï¼ç½‘ç»œä¿¡ä½¿messenger</a></p>
:ET