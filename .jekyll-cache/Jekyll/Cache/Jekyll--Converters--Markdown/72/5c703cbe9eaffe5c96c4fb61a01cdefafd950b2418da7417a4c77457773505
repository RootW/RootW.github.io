I"Ïp<p>â€ƒâ€ƒåœ°å€æ˜ å°„æ˜¯CPUæ ¸å¿ƒå’ŒMMUå…±åŒå®Œæˆçš„å†…å­˜ç®¡ç†åŠŸèƒ½ä¹‹ä¸€ï¼Œæœ¬èŠ‚å°†å¯¹æ­¤å±•å¼€æ·±å…¥è®¨è®ºã€‚è®¡ç®—å­ç³»ç»Ÿç›¸å…³å†…å®¹ç›®å½•<a href="https://rootw.github.io/2017/02/è®¡ç®—å­ç³»ç»Ÿ/">ç‚¹æ­¤è¿›å…¥</a>ã€‚</p>

<h3 id="ä»€ä¹ˆæ˜¯åœ°å€æ˜ å°„ä¸ºä»€ä¹ˆéœ€è¦å®ƒ">ä»€ä¹ˆæ˜¯åœ°å€æ˜ å°„ï¼Ÿä¸ºä»€ä¹ˆéœ€è¦å®ƒï¼Ÿ</h3>

<p>â€ƒâ€ƒæ­£å¦‚åœ¨<a href="https://rootw.github.io/2017/02/è®¡ç®—æœº/">è®¡ç®—æœºç³»ç»Ÿ</a>æ•´ä½“ä»‹ç»ä¸­æ‰€è¯´æ˜çš„ä¸€æ ·ï¼ŒMMUåœ¨CPUçš„é…åˆä¸‹(é€šè¿‡é¡µå¼‚å¸¸è§¦å‘)ï¼Œå®ç°äº†çº¿æ€§åœ°å€åˆ°ç‰©ç†åœ°å€çš„åŠ¨æ€æ˜ å°„ï¼Œä¸ºæ­£åœ¨CPUä¸Šè¿è¡Œçš„åº”ç”¨ç¨‹åº(è¿›ç¨‹)æä¾›äº†ä¸€ä¸ªç‹¬ç«‹çš„è¿ç»­å†…å­˜ç©ºé—´(çº¿æ€§åœ°å€ç©ºé—´ï¼Œæˆ–ç§°è™šæ‹Ÿå†…å­˜ç©ºé—´ï¼Œå…¶ä¸­æ”¾ç½®äº†ä»£ç æ®µã€æ•°æ®æ®µå’Œå †æ ˆæ®µ)ï¼Œå±è”½äº†åœ°å€åˆ†é…ã€å†…å­˜åˆ†é…å’Œå†…å­˜å›æ”¶ç­‰ä¸€ç³»åˆ—å¤æ‚çš„ç³»ç»Ÿè¡Œä¸ºï¼Œä¸ä»…æå‡äº†å†…å­˜èµ„æºçš„åˆ©ç”¨æ•ˆç‡ï¼Œè€Œä¸”å¤§å¤§é™ä½äº†åº”ç”¨å¼€å‘éš¾åº¦ï¼Œä½¿ç¨‹åºçŒ¿å¯ä»¥æ›´èšç„¦ä¸šåŠ¡é€»è¾‘ã€‚ç»“åˆCPUçš„è¿›ç¨‹ç®¡ç†åŠŸèƒ½ï¼Œå¯ä»¥å®ç°ä¸€ä¸ªå¤šä»»åŠ¡å¹¶è¡Œç³»ç»Ÿï¼Œæå‡ç³»ç»Ÿçš„å¯ç”¨æ€§å’Œæ€§èƒ½ã€‚</p>

<h3 id="å¦‚ä½•å®ç°">å¦‚ä½•å®ç°ï¼Ÿ</h3>

<h4 id="1çº¿æ€§åœ°å€"><strong>1.çº¿æ€§åœ°å€</strong></h4>

<p>â€ƒâ€ƒx86_64æ¶æ„ä¸‹Linuxä¸­æ¯ä¸ªåº”ç”¨ç¨‹åº(è¿›ç¨‹)å¯è§çš„çº¿æ€§åœ°å€ç©ºé—´å¦‚ä¸‹(æ³¨ï¼šåˆ†æ®µæœºåˆ¶åœ¨64ä½æ¨¡å¼ä¸‹å·²ä¸äº§ç”Ÿå®é™…ä½œç”¨)ï¼š</p>

<div align="center">
<img src="/images/posts/i440fx/memory1_1.jpg" height="200" width="500" />  
</div>

<p>â€ƒâ€ƒè¯¥æ¶æ„æ”¯æŒ48ä½çº¿æ€§åœ°å€(é«˜16ä½ä»…åšç¬¦å·æ‰©å±•ï¼Œä¸å‚ä¸åœ°å€è½¬æ¢)åˆ°40ä½ç‰©ç†åœ°å€(æœ€å¤š52ä½ï¼Œç”±CPUå®ç°å†³å®š)çš„æ˜ å°„ã€‚48ä½çº¿æ€§ç©ºé—´å…±256Tï¼Œåˆ†ä¸ºä¸¤ä¸ª128TåŒºé—´ï¼Œåˆ†åˆ«åˆ†å¸ƒåœ¨å®Œæ•´çš„64ä½ç©ºé—´çš„ä¸¤ç«¯ã€‚å…¶ä¸­ï¼Œä½128Tä¸ºç”¨æˆ·ç©ºé—´ï¼Œæ˜ å°„ç”¨æˆ·ç¨‹åºä»£ç ã€æ•°æ®ã€å †æ ˆå’Œå…±äº«åº“ï¼Œç‰©ç†å†…å­˜éšç€ç¨‹åºçš„è¿è¡Œç”±å†…æ ¸åŠ¨æ€åˆ†é…ã€‚è€Œé«˜128Tåˆ™ä¸ºå†…æ ¸ç©ºé—´ï¼šdirect mappingåŒºæ˜ å°„æ•´ä¸ªç‰©ç†å†…å­˜ç©ºé—´ï¼Œä¾¿äºå†…æ ¸è®¿é—®æ‰€æœ‰ç‰©ç†å†…å­˜ï¼›vmalloc spaceåŒºé—´ä¸ºå†…æ ¸è°ƒç”¨vmallocæ—¶ä½¿ç”¨çš„çº¿æ€§ç©ºé—´ï¼Œç‰©ç†å†…å­˜åŠ¨æ€åˆ†é…ä¸”ç‰©ç†ä¸Šä¸ä¿è¯è¿ç»­ï¼›virtual memory mapæ˜¯å†…æ ¸æ ‡è¯†å†…å­˜é¡µä¿¡æ¯çš„æ•°ç»„ï¼Œä¾›å†…å­˜ç®¡ç†åŠŸèƒ½ä½¿ç”¨ï¼›kernel text &amp; moduleåŒºå­˜æ”¾å†…æ ¸å’Œæ¨¡å—çš„ä»£ç åŠæ•°æ®ã€‚æ­¤å¤–ï¼Œä¹Ÿå¯ä»¥å‚è€ƒå†…æ ¸ä»£ç çš„è¯´æ˜ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/Documentation/x86/x86_64/mm.txt:

0000000000000000 - 00007fffffffffff (=47 bits) user space, different per mm
hole caused by [48:63] sign extension
ffff800000000000 - ffff80ffffffffff (=40 bits) guard hole
ffff880000000000 - ffffc7ffffffffff (=64 TB) direct mapping of all phys. memory
ffffc80000000000 - ffffc8ffffffffff (=40 bits) hole
ffffc90000000000 - ffffe8ffffffffff (=45 bits) vmalloc/ioremap space
ffffe90000000000 - ffffe9ffffffffff (=40 bits) hole
ffffea0000000000 - ffffeaffffffffff (=40 bits) virtual memory map (1TB)
... unused hole ...
ffffff0000000000 - ffffff7fffffffff (=39 bits) %esp fixup stacks
... unused hole ...
ffffffff80000000 - ffffffffa0000000 (=512 MB)  kernel text mapping, from phys 0
ffffffffa0000000 - ffffffffff5fffff (=1525 MB) module mapping space
ffffffffff600000 - ffffffffffdfffff (=8 MB) vsyscalls
ffffffffffe00000 - ffffffffffffffff (=2 MB) unused hole

</code></pre></div></div>

<h4 id="2åœ°å€è½¬æ¢"><strong>2.åœ°å€è½¬æ¢</strong></h4>

<p>â€ƒâ€ƒMMUçš„çº¿æ€§åœ°å€è½¬æ¢æ˜¯é€šè¿‡é¡µè¡¨è¿›è¡Œçš„ï¼Œå…·ä½“è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤º(æ‘˜è‡ªintelç¨‹åºå‘˜æ‰‹å†Œå·3)ï¼š</p>

<div align="center">
<img src="/images/posts/i440fx/memory1_3.jpg" height="500" width="750" />  
</div>

<p>â€ƒâ€ƒå…¶å®æœ€ç®€å•æ˜äº†çš„æ–¹æ³•æ˜¯é€šè¿‡ä¸€ä¸ªä¸€ç»´æ•°ç»„æ¥è®°å½•æ˜ å°„å…³ç³»:ä¸‹æ ‡ä»£è¡¨çº¿æ€§åœ°å€ï¼Œæ•°ç»„å…ƒç´ å†…å®¹ä»£è¡¨ç‰©ç†åœ°å€ã€‚å¯æ˜¯å¦‚æ­¤ä¸€æ¥ï¼Œç”¨æ¥è¡¨ç¤ºæ˜ å°„å…³ç³»çš„å†…å­˜ç©ºé—´æ¯”è¢«è¡¨ç¤ºçš„ç‰©ç†ç©ºé—´è¿˜è¦å¤§ï¼Œæ˜¾ç„¶è¿™ä¸æ˜¯ä¸€ä¸ªå¯è¡Œçš„æ–¹æ¡ˆã€‚</p>

<p>â€ƒâ€ƒå·¥ç¨‹å¸ˆä»¬é‡‡ç”¨äº†åˆ†æ®µåˆ†çº§çš„æ€è·¯æ¥è¡¨ç¤ºè¿™ç§æ˜ å°„å…³ç³»ï¼šå…ˆæŠŠçº¿æ€§ç©ºé—´ä»¥4Kå¤§å°ä¸ºå•ä½è¿›è¡Œåˆ’åˆ†(é¡µ)ï¼Œç„¶åå†ä»¥å¤§æ®µè¿ç»­ç©ºé—´è¿›è¡Œè½¬æ¢ï¼Œåœ¨æ¯ä¸ªå¤§æ®µç©ºé—´å†…éƒ¨å†æ¬¡åˆ’åˆ†æˆå°æ®µè¿›è¡Œè½¬æ¢ï¼Œç›´åˆ°æ®µå¤§å°å˜ä¸º4Ké¡µå¤§å°ã€‚ç”¨ä»¥è¡¨ç¤ºå’Œæ®µç©ºé—´æ˜ å°„å…³ç³»çš„ç»“æ„ç§°ä¸ºé¡µè¡¨ï¼Œå…¶å¤§å°ä¹Ÿæ˜¯ä¸€ä¸ªé¡µé¢ã€‚ç”±äºé‡‡ç”¨äº†åˆ†æ®µçš„æ–¹æ³•ï¼Œé¡µè¡¨ç©ºé—´å¤§å¤§å‡å°ï¼›åŒæ—¶æœªæ˜ å°„çš„ç©ºé—´ä¸å¿…åˆ†é…é¡µè¡¨ï¼Œè¿™ä¹Ÿè¿›ä¸€æ­¥é™ä½äº†é¡µè¡¨å ç”¨ç©ºé—´ã€‚</p>

<p>â€ƒâ€ƒx86_64æ¶æ„ä¸‹Linuxç”¨äº†å››çº§é¡µè¡¨æ¥è¡¨ç¤ºä¸€ä¸ªæ˜ å°„å…³ç³»ï¼Œä¾æ¬¡ä¸ºPGDã€PUDã€PMDã€PTã€‚æ¯çº§é¡µè¡¨4Kå¤§å°ï¼Œå†…éƒ¨å…ƒç´ å¤§å°ä¸º8å­—èŠ‚ï¼Œé«˜ä½æŒ‡å‘äº†ä¸‹ä¸€çº§é¡µè¡¨çš„ç‰©ç†åœ°å€ï¼Œä½ä½è¡¨ç¤ºé¡µè¡¨å±æ€§(æ˜¯å¦å­˜åœ¨ã€è¯»å†™æƒé™ã€æ˜¯å¦è„ç­‰ç­‰)ã€‚é¡¶å±‚é¡µè¡¨PGDçš„ç‰©ç†åœ°å€å­˜æ”¾åœ¨CPUçš„CR3å¯„å­˜å™¨ä¸­ï¼Œä¾›MMUè®¿é—®ã€‚48ä½çº¿æ€§åœ°å€ä¹Ÿç›¸åº”åœ°åˆ†æˆäº†äº”æ®µï¼šå‰å››æ®µï¼Œæ¯æ®µé•¿9ä½ï¼Œç”¨æ¥ç´¢å¼•å¯¹åº”é¡µè¡¨çš„å…ƒç´ ï¼›æœ€åä¸€æ®µé•¿12ä½ï¼Œç”¨æ¥åœ¨é¡µé¢ä¸­ç´¢å¼•ç‰©ç†åœ°å€ã€‚å„çº§é¡µè¡¨çš„è¯¦ç»†å†…å®¹å‚è€ƒä¸‹è¡¨ï¼š</p>

<div align="center">
<img src="/images/posts/i440fx/memory1_4.jpg" height="650" width="800" />  
</div>

<h4 id="3é¡µå¼‚å¸¸å¤„ç†"><strong>3.é¡µå¼‚å¸¸å¤„ç†</strong></h4>

<p>â€ƒâ€ƒä¸€ä¸ªè¿›ç¨‹åˆå§‹è¿è¡Œæ—¶ï¼Œå¯¹åº”çš„é¡µè¡¨é¡¹å¤§å¤šéƒ½æ˜¯ç©ºçš„ã€‚ä¸€æ—¦MMUåœ¨åœ°å€è½¬æ¢è¿‡ç¨‹ä¸­å‡ºç°ç¼ºé¡µæˆ–è€…è¯»å†™æƒé™é—®é¢˜æ—¶ï¼ŒMMUä¼šè§¦å‘é¡µå¼‚å¸¸ï¼Œæ‰“æ–­CPUå½“å‰æ­£åœ¨æ‰§è¡Œçš„ç¨‹åºï¼Œè½¬è€Œè¿›è¡Œé¡µå¼‚å¸¸å¤„ç†(ç¼ºé¡µä¼šåˆ†é…æ–°é¡µ)ã€‚å½“é¡µå¼‚å¸¸å¤„ç†å®Œæ¯•åï¼ŒCPUä¼šé‡æ–°æ‰§è¡Œå¼•å‘ç¼ºé¡µçš„æŒ‡ä»¤ï¼Œæ­¤æ—¶MMUä¾¿å¯æ­£å¸¸å®Œæˆåœ°å€è½¬æ¢ã€‚</p>

<p>â€ƒâ€ƒä¸‹é¢ï¼Œæˆ‘ä»¬è¿›ä¸€æ­¥æ·±å…¥åˆ†ææ•´ä¸ªé¡µå¼‚å¸¸å¤„ç†è¿‡ç¨‹ï¼Œå…³é”®æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p>

<div align="center">
<img src="/images/posts/i440fx/memory1_2.jpg" height="600" width="500" />  
</div>

<p>â€ƒâ€ƒCPUæ”¶åˆ°é¡µå¼‚å¸¸åï¼Œé¦–å…ˆè¿›è¡Œçš„æ˜¯ä¸Šä¸‹æ–‡åˆ‡æ¢çš„ç¡¬ä»¶è¿‡ç¨‹ï¼Œè¯¥è¿‡ç¨‹ä¸»è¦å®Œæˆæ ˆçš„åˆ‡æ¢(è¿›å…¥å†…æ ¸æ ˆ)ã€å…³é”®å¯„å­˜å™¨çš„ä¿å­˜å’Œæ‰§è¡Œå‡½æ•°çš„åˆ‡æ¢(è½¬å…¥é¡µå¼‚å¸¸å¤„ç†å‡½æ•°page_fault)ã€‚æœ‰å…³ä¸­æ–­å’Œå¼‚å¸¸å¤„ç†çš„è¯¦ç»†åˆ†æè¯·å‚è€ƒ<a href="https://rootw.github.io/2017/03/ä¸­æ–­/">ä¸­æ–­åˆ†æ</a>ã€‚</p>

<p>â€ƒâ€ƒCPUè¢«é¡µå¼‚å¸¸ä¸­æ–­åæœ€å…ˆæ‰§è¡Œçš„æ˜¯ä¸€æ®µæ±‡ç¼–ä»£ç (page_faultä½äºlinux/arch/x86/kernel/entry_64.Sï¼Œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥è‡ªè¡Œåˆ†æ)ï¼Œå®ƒå®Œæˆäº†å…¶ä»–ä¸Šä¸‹æ–‡å¯„å­˜å™¨çš„ä¿å­˜ï¼Œå¹¶è¿›å…¥æ ¸å¿ƒå¤„ç†é€»è¾‘do_page_faultã€‚</p>

<p>â€ƒâ€ƒåœ¨ç†è§£MMUçš„å·¥ä½œåŸç†ä¹‹åï¼Œæˆ‘æƒ³å¤§å®¶å¯¹ç¼ºé¡µå¼‚å¸¸çš„æ ¸å¿ƒå¤„ç†é€»è¾‘åº”è¯¥å¾ˆå¿«èƒ½æƒ³æ˜ç™½ï¼Œæ— éå°±æ˜¯åˆ†é…é¡µã€å¡«å……é¡µå†…å®¹ã€ä¿®æ”¹é¡µè¡¨ã€‚ç„¶è€Œï¼Œå›é¡¾ä¸€ä¸‹å‰é¢çº¿æ€§åœ°å€ç« èŠ‚æç»˜çš„åœ°å€ç©ºé—´åˆ†é…å›¾ï¼Œæˆ‘ä»¬ä¼šå‘ç°å…¶ä¸­æœ‰ä»£ç ã€æœ‰æ•°æ®ã€æœ‰å †å’Œæ ˆï¼Œä¸åŒç±»å‹çš„åŒºæ®µçš„å¯¹äºé¡µå¼‚å¸¸çš„å¤„ç†é€»è¾‘æ˜¯æœ‰åŒºåˆ«çš„ï¼Œä¾‹å¦‚ä»£ç æ®µçš„é¡µå†…å®¹æ¥è‡ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ˜¯åªè¯»ç±»å‹çš„ï¼›æ•°æ®æ®µåˆå§‹å†…å®¹ä¹Ÿæ¥è‡ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œä½†åç»­çš„ä¿®æ”¹ä¸å½±å“å¯æ‰§è¡Œæ‰§è¡Œæ–‡ä»¶ï¼›å †å’Œæ ˆçš„å†…å®¹ä¸æ¥è‡ªä»»ä½•æ–‡ä»¶ï¼Œåªåœ¨å½“å‰è¿›ç¨‹å†…éƒ¨å¯è§ã€‚å› æ­¤ï¼Œé’ˆå¯¹ä¸åŒç±»å‹çš„å†…å­˜åŒºæ®µéœ€è¦æœ‰ä¸åŒçš„å¤„ç†æ–¹å¼ã€‚Linuxå†…æ ¸ä»¥è™šæ‹Ÿå†…å­˜æ®µ(vma, virtual memory area)æ¥è¡¨è¾¾ä¸åŒç¨‹åºåŒºæ®µï¼Œä¸åŒæ®µå¯ä»¥å…·æœ‰ä¸åŒçš„è¯»å†™æƒé™å’Œå±æ€§ï¼›ä¸åœ¨ä»»ä½•å†…å­˜æ®µçš„åœ°å€åˆ™è®¤ä¸ºæ˜¯éæ³•åœ°å€ã€‚æœ‰å…³å†…å­˜æ®µçš„æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/mm_types.h:

/*
 * This struct defines a memory VMM memory area. There is one of these
 * per VM-area/task.  A VM area is any part of the process virtual memory
 * space that has a special rule for the page-fault handlers (ie a shared
 * library, the executable area etc).
 */
struct vm_area_struct {
    /* The first cache line has the info for VMA tree walking. */

    unsigned long vm_start;		/* Our start address within vm_mm. */
    unsigned long vm_end;		/* The first byte after our end address within vm_mm. */

    /* linked list of VM areas per task, sorted by address */
    struct vm_area_struct *vm_next, *vm_prev;

    struct rb_node vm_rb;

    ...

    /* Second cache line starts here. */

    struct mm_struct *vm_mm;	/* The address space we belong to. */
    pgprot_t vm_page_prot;		/* Access permissions of this VMA. */
    unsigned long vm_flags;		/* Flags, see mm.h. */

    ...

    /* Function pointers to deal with this struct. */
    const struct vm_operations_struct *vm_ops;

    /* Information about our backing store: */
    unsigned long vm_pgoff;		/* Offset (within vm_file) in PAGE_SIZE units, *not* PAGE_CACHE_SIZE */
    struct file * vm_file;		/* File we map to (can be NULL). */
    void * vm_private_data;		/* was vm_pte (shared mem) */

    ...
};

</code></pre></div></div>

<p>â€ƒâ€ƒæ‰€æœ‰vmaä¼šä»¥é“¾è¡¨å½¢å¼ç»Ÿä¸€åˆ°mm_structä¸­ï¼Œè¯¥ç»“æ„æ¯ä¸ªè¿›ç¨‹æ‹¥æœ‰ä¸€ä¸ªï¼Œè¢«è¿›ç¨‹æ§åˆ¶å—ä½¿ç”¨ï¼Œæè¿°äº†æ¯ä¸ªè¿›ç¨‹çš„æœ‰æ•ˆå†…å­˜åŒºæ®µå’Œåœ°å€æ˜ å°„å…³ç³»ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/mm_types.h:

struct mm_struct {
    struct vm_area_struct * mmap;		/* list of VMAs */
    struct rb_root mm_rb;
    struct vm_area_struct * mmap_cache;	/* last find_vma result */
#ifdef CONFIG_MMU
    unsigned long (*get_unmapped_area) (struct file *filp,
    unsigned long addr, unsigned long len,
    unsigned long pgoff, unsigned long flags);
    void (*unmap_area) (struct mm_struct *mm, unsigned long addr);
#endif
    unsigned long mmap_base;            /* base of mmap area */
    unsigned long mmap_legacy_base;     /* base of mmap area in bottom-up allocations */
    unsigned long task_size;            /* size of task vm space */
    unsigned long cached_hole_size; 	/* if non-zero, the largest hole below free_area_cache */
    unsigned long free_area_cache;		/* first hole of size cached_hole_size or larger */
    unsigned long highest_vm_end;		/* highest vma end address */
    pgd_t * pgd;                        /* æŒ‡å‘PGDè¡¨ï¼Œownerè¿›ç¨‹è¿è¡Œæ—¶è¯¥å€¼è¢«åŠ è½½åˆ°CR3å¯„å­˜å™¨ä¸­*/
    atomic_t mm_users;			/* How many users with user space? */
    atomic_t mm_count;			/* How many references to "struct mm_struct" (users count as 1) */
    int map_count;				/* number of VMAs */

    spinlock_t page_table_lock;		/* Protects page tables and some counters */
    struct rw_semaphore mmap_sem;

    struct list_head mmlist;        /* List of maybe swapped mm's.	These are globally strung
                                     * together off init_mm.mmlist, and are protected
                                     * by mmlist_lock
                                     */

    ...

}
</code></pre></div></div>

<p>â€ƒâ€ƒæˆ‘ä»¬å›åˆ°do_page_faultå‡½æ•°ï¼Œå®ƒé€šè¿‡è¯»å–CPUçš„CR2å¯„å­˜å™¨å¯ä»¥è·çŸ¥å‘ç”Ÿé¡µå¼‚å¸¸çš„çº¿æ€§åœ°å€ï¼Œå¹¶åœ¨å½“å‰è¿›ç¨‹å¯¹åº”çš„mm_structä¸­æŸ¥æ‰¾è¯¥çº¿æ€§åœ°å€å¯¹åº”çš„vmaè™šæ‹Ÿåœ°å€å†…å­˜æ®µï¼Œæœ€åæ ¹æ®vmaçš„å±æ€§æ¥è¿›ä¸€æ­¥å¤„ç†é¡µå¼‚å¸¸ã€‚å½“ç„¶ï¼Œå¦‚æœæ‰¾ä¸åˆ°çº¿æ€§åœ°å€å¯¹åº”çš„vmaï¼Œå†…æ ¸å°±ä¼šè®¤ä¸ºå‘ç”Ÿäº†ä¸€æ¬¡éæ³•å†…å­˜è®¿é—®(è®©ç¨‹åºçŒ¿é—»é£ä¸§èƒ†çš„segfaultç”±æ­¤äº§ç”Ÿ)ã€‚ä»£ç ç‰‡æ–­åˆ†æå¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/arch/x86/mm/fault.c:

/*
 * This routine handles page faults.  It determines the address,
 * and the problem, and then passes it off to one of the appropriate
 * routines.
 */
static void __kprobes
__do_page_fault(struct pt_regs *regs, unsigned long error_code)
{
    struct vm_area_struct *vma;
    struct task_struct *tsk;
    unsigned long address;
    struct mm_struct *mm;
    int fault;
    unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;

    tsk = current;  /*è·å–å½“å‰è¿›ç¨‹*/
    mm = tsk-&gt;mm;   /*å½“å‰è¿›ç¨‹å¯¹åº”çš„mm_struct*/

    /* Get the faulting address: */
    address = read_cr2();   /*x86æ¶æ„ä¸‹ï¼Œé¡µå¼‚å¸¸å‘ç”Ÿæ—¶ï¼ŒCR2å¯„å­˜å™¨ä¸­ä¼šè®°å½•å‘ç”Ÿå¼‚å¸¸çš„çº¿æ€§åœ°å€*/

    if (unlikely(fault_in_kernel_space(address))) {
        /*é€šè¿‡å¼‚å¸¸åœ°å€èŒƒå›´ï¼Œåˆ¤æ–­å¼‚å¸¸åœ°å€æ˜¯å¦åœ¨å†…æ ¸æ€ã€‚
          å¦‚æœå‘ç”Ÿåœ¨å†…æ ¸æ€ï¼Œé€šå¸¸æ˜¯ç”±äºvmallocå¯¼è‡´çš„ï¼Œè¿™é‡Œä¼šå¤„ç†é¡µè¡¨æ˜ å°„å…³ç³»*/
        ...
        return;
    }

    ...

    /*å¦‚æœæ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜é¡µå¼‚å¸¸åœ°å€å¤„åœ¨ç”¨æˆ·æ€èŒƒå›´*/
    /*å¦‚æœä»£ç æ®µä¹Ÿåœ¨ç”¨æˆ·æ€ï¼Œåˆ™æ‰“å¼€ä¸­æ–­ï¼Œå¹¶è®°å½•æ ‡å¿—ï¼›
      å¦‚æœä»£ç æ®µåœ¨å†…æ ¸æ€ï¼Œåˆ™æ ¹æ®é¡µå¼‚å¸¸å‘ç”Ÿå‰çš„IFæ ‡è®°å€¼æ¥å†³å®šæ˜¯å¦æ‰“å¼€ä¸­æ–­*/
    if (user_mode_vm(regs)) {
        local_irq_enable();
        error_code |= PF_USER;
        flags |= FAULT_FLAG_USER;
    } else {
        if (regs-&gt;flags &amp; X86_EFLAGS_IF)
            local_irq_enable();
    }

    ...

    /*
     * If we're in an interrupt, have no user context or are running
     * in an atomic region then we must not take the fault:
     */
    /*è¿™é‡Œæ³¨æ„ä¸€ç‚¹ï¼šé¡µå¼‚å¸¸å¤„ç†å±äºè¿›ç¨‹ä¸Šä¸‹æ–‡ï¼Œä¸æ˜¯ä¸­æ–­ä¸Šä¸‹æ–‡ï¼Œå¯ç¡çœ */
    if (unlikely(in_atomic() || !mm)) {
        bad_area_nosemaphore(regs, error_code, address);
        return;
    }

    if (error_code &amp; PF_WRITE)
        flags |= FAULT_FLAG_WRITE;

    /*
     * When running in the kernel we expect faults to occur only to
     * addresses in user space.  All other faults represent errors in
     * the kernel and should generate an OOPS.  Unfortunately, in the
     * case of an erroneous fault occurring in a code path which already
     * holds mmap_sem we will deadlock attempting to validate the fault
     * against the address space.  Luckily the kernel only validly
     * references user space from well defined areas of code, which are
     * listed in the exceptions table.
     * ...
     */
    /*è·å–å½“å‰mm_structçš„è¯»ä¿¡å·é‡ï¼Œé¿å…åç»­å¤„ç†è¿‡ç¨‹ä¸­æœ‰å…¶å®ƒæµç¨‹ä¿®æ”¹mm_structç»“æ„*/
    if (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) {
        if ((error_code &amp; PF_USER) == 0 &amp;&amp;
                !search_exception_tables(regs-&gt;ip)) {
            bad_area_nosemaphore(regs, error_code, address);
            return;
        }
retry:
        down_read(&amp;mm-&gt;mmap_sem);
    } else {
    /*
     * The above down_read_trylock() might have succeeded in
     * which case we'll have missed the might_sleep() from
     * down_read():
     */
        might_sleep();
    }

    /*æŸ¥æ‰¾é¡µå¼‚å¸¸åœ°å€å¯¹åº”çš„vmaåŒºæ®µ*/
    vma = find_vma(mm, address);
    if (unlikely(!vma)) {
        bad_area(regs, error_code, address);
        return;
    }
    /*å¦‚æœé¡µå¼‚å¸¸åœ°å€åœ¨åˆç†çš„vmaæ®µåœ°å€èŒƒå›´å†…ï¼Œåˆ™è¿›è¡Œåç»­çš„å¼‚å¸¸å¤„ç†*/
    if (likely(vma-&gt;vm_start &lt;= address))
        goto good_area;
    if (unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) {
        /*å¦‚æœé¡µå¼‚å¸¸åœ°å€å°äºvmaèµ·å§‹åœ°å€ï¼Œä½†vmaåˆä¸æ˜¯å¾€ä½åœ°å€æ–¹å‘å¢é•¿(æ ˆæ˜¯å¾€ä½åœ°å€æ–¹å‘å¢é•¿çš„)ï¼Œåˆ™å‡ºç°é”™è¯¯*/
        bad_area(regs, error_code, address);
        return;
    }

    ...

    /*å¾€ä½åœ°å€æ–¹å‘å¢é•¿æ ˆ*/
    if (unlikely(expand_stack(vma, address))) {
        bad_area(regs, error_code, address);
        return;
    }

    /*
     * Ok, we have a good vm_area for this memory access, so
     * we can handle it..
     */
    /*å¦‚æœæ‰§è¡Œåˆ°è¿™é‡Œï¼Œåç»­ä¾¿å¼€å§‹é’ˆå¯¹vmaçš„å±æ€§è¿›è¡Œä¸åŒçš„é¡µå¼‚å¸¸å¤„ç†*/
good_area:
    if (unlikely(access_error(error_code, vma))) {
        bad_area_access_error(regs, error_code, address);
        return;
    }

    /*
     * If for any reason at all we couldn't handle the fault,
     * make sure we exit gracefully rather than endlessly redo
     * the fault:
     */
    fault = handle_mm_fault(mm, vma, address, flags);

    ...

}


/*ä¸‹é¢è¡¥å……ä¸€äº›å…³äºé¡µå¼‚å¸¸é”™è¯¯ç çš„å†…å®¹ï¼Œé€šå¸¸åœ¨å‘ç”Ÿæ®µé”™è¯¯æ—¶æˆ‘ä»¬åœ¨ç³»ç»Ÿæ—¥å¿—ä¸­å¯ä»¥çœ‹åˆ°é”™è¯¯ç ï¼Œ
  é€šè¿‡é”™è¯¯ç æˆ‘ä»¬å¤§è‡´å¯ä»¥å¾—çŸ¥å¼‚å¸¸å‘ç”Ÿçš„åŸå› */
/*
 * Page fault error code bits:
 *
 *   bit 0 ==	 0: no page found	1: protection fault
 *   bit 1 ==	 0: read access		1: write access
 *   bit 2 ==	 0: kernel-mode access	1: user-mode access
 *   bit 3 ==				1: use of reserved bit detected
 *   bit 4 ==				1: fault was an instruction fetch
 */
enum x86_pf_error_code {
    PF_PROT     =       1 &lt;&lt; 0,
    PF_WRITE    =       1 &lt;&lt; 1,
    PF_USER     =       1 &lt;&lt; 2,
    PF_RSVD     =       1 &lt;&lt; 3,
    PF_INSTR    =       1 &lt;&lt; 4,
};
</code></pre></div></div>

<p>â€ƒâ€ƒhandle_mm_faultå‡½æ•°åŸºäºå½“å‰è¿›ç¨‹çš„mm_structã€å¼‚å¸¸åœ°å€æ‰€åœ¨vmaå’Œå¼‚å¸¸å¤„ç†æ§åˆ¶æ ‡å¿—flagsè¿›è¡Œè¿›ä¸€æ­¥å¼‚å¸¸å¤„ç†ã€‚æˆ‘ä»¬çŸ¥é“ï¼Œé¡µè¡¨å…±æœ‰å››çº§ï¼Œè¿™é‡Œä¾æ¬¡å¯¹å„çº§é¡µè¡¨è¿›è¡Œå¤„ç†ï¼šPGDæ˜¯åœ¨è¿›ç¨‹åˆ›å»ºçš„æ—¶å€™å°±åˆ†é…å¥½çš„ï¼Œä¸éœ€è¦åŠ¨æ€åˆ†é…ï¼Œå…¶å€¼ä¿å­˜åœ¨mm_structçš„pgdåŸŸä¸­ï¼›ä»PUDåˆ°PTï¼Œå¦‚æœé¡µè¡¨ä¸å­˜åœ¨ä¼šåŠ¨æ€åˆ†é…é¡µå¹¶ä½¿é¡µè¡¨æŒ‡å‘æ–°åˆ†é…çš„é¡µã€‚é¡µè¡¨å¤„ç†å®Œæˆåï¼Œè¿›å…¥handle_pte_faultå¤„ç†æœ€åçš„ç‰©ç†é¡µã€‚handle_mm_faultä»£ç æ³¨è§£å¦‚ä¸‹(è¿™é‡Œæš‚ä¸è€ƒè™‘å¤§é¡µç­‰å¤æ‚ç‰¹æ€§)ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/mm/memory.c:

/*
 * By the time we get here, we already hold the mm semaphore
 */
static int __handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,
unsigned long address, unsigned int flags)
{
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd;
    pte_t *pte;

    ...

retry:
    pgd = pgd_offset(mm, address); /*ç›´æ¥è·å–å½“å‰è¿›ç¨‹ä¸­é¡µå¼‚å¸¸çº¿æ€§åœ°å€åœ¨PGDè¡¨ä¸­å¯¹åº”çš„é¡¹ï¼Œæ— é¡»åˆ†é…*/
    pud = pud_alloc(mm, pgd, address); /*è·å–PUDè¡¨ä¸­å¯¹åº”çš„é¡¹ï¼Œå¦‚æœPUDè¡¨ä¸å­˜åœ¨åˆ™åŠ¨æ€åˆ†é…*/
    if (!pud)
        return VM_FAULT_OOM;
    pmd = pmd_alloc(mm, pud, address); /*è·å–PMDè¡¨ä¸­å¯¹åº”çš„é¡¹ï¼Œå¦‚æœPMDä¸å­˜åœ¨åˆ™åŠ¨æ€åˆ†é…*/
    if (!pmd)
        return VM_FAULT_OOM;

    ...
    if (unlikely(pmd_none(*pmd)) &amp;&amp;
        unlikely(__pte_alloc(mm, vma, pmd, address))) /*åŠ¨æ€åˆ†é…PTE*/
    return VM_FAULT_OOM;
    ...

    pte = pte_offset_map(pmd, address);

    /*å„çº§é¡µè¡¨åˆ†é…å®Œæ¯•åï¼ŒçœŸæ­£å¼€å§‹å¤„ç†é¡µå¼‚å¸¸*/
    return handle_pte_fault(mm, vma, address, pte, pmd, flags);
}
</code></pre></div></div>

<p>â€ƒâ€ƒé¢˜å¤–è¯ï¼Œé¡µè¡¨æ“ä½œçš„åŒæ­¥ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œä¸€ä¸ªç¡®å®šçš„æ˜ å°„å…³ç³»mm_structåªè¢«ä¸€ä¸ªè¿›ç¨‹å¼•ç”¨ï¼ŒåŒä¸€è¿›ç¨‹åœ¨ç¡®å®šæ—¶åˆ»åªä¼šè¿è¡Œåœ¨ä¸€ä¸ªæ ¸ä¸Šï¼Œå› æ­¤è¯¥è¿›ç¨‹çš„é¡µå¼‚å¸¸å¤„ç†ä¹Ÿåªåœ¨ä¸€ä¸ªæ ¸ä¸Šå‘ç”Ÿï¼Œæ­¤æ—¶ä¸å­˜åœ¨å¯¹è¿›ç¨‹é¡µè¡¨åšå¹¶å‘æ“ä½œçš„å¯èƒ½ã€‚ç„¶è€Œï¼Œå¦‚æœä¸€ä¸ªè¿›ç¨‹æœ‰å¤šä¸ªçº¿ç¨‹ï¼Œé‚£ä¹ˆè¿™äº›çº¿ç¨‹å°†å¼•ç”¨ç›¸åŒçš„mm_struct(ä»£ç æ®µã€æ•°æ®æ®µã€å †ç©ºé—´å®Œå…¨ç›¸åŒï¼Œæ ˆç©ºé—´å„ä¸ç›¸åŒ)ï¼Œæ­¤æ—¶å¯¹mm_structæ‰€æ¶‰åŠçš„å„çº§é¡µè¡¨æ“ä½œæ—¶å°±éœ€è¦è€ƒè™‘åŒæ­¥é—®é¢˜ã€‚</p>

<p>â€ƒâ€ƒä¸€ç§ç®€å•çš„æ–¹æ³•æ˜¯åœ¨å¼€å§‹é¡µè¡¨æ“ä½œå‰ï¼Œå¯¹mm_structå…ˆä¸Šä¸€æŠŠå¤§é”ï¼Œå¾…å„çº§é¡µè¡¨å‡æ“ä½œå®Œæ¯•åå†è§£é”ã€‚ä½†å­˜åœ¨çš„é—®é¢˜æ˜¯é¡µè¡¨æ“ä½œè¿‡ç¨‹ä¸­ä¼šæ¶‰åŠé¡µåˆ†é…ï¼Œè¿™æ˜¯ä¸€ä¸ªæå…¶å¤æ‚çš„è¿‡ç¨‹ï¼Œå¯èƒ½è¿˜ä¼šç¡çœ ï¼Œè¿™æ ·ä¸€æ¥æœ‰å¯èƒ½å‡ºç°æˆåŠŸåŠ åˆ°é”çš„çº¿ç¨‹è¿›å…¥ç¡çœ æ€åå¯¼è‡´å…¶ä»–çº¿ç¨‹ç¼ºé¡µå´åŠ ä¸åˆ°é”çš„æƒ…å†µã€‚å³ä¾¿ä¸åŒçº¿ç¨‹è®¿é—®çš„æ˜¯ä¸åŒå†…å­˜æ®µï¼Œä½†æ˜¯å´æœ‰å¯èƒ½å‡ºç°å› ä¸ºä¸€ä¸ªçº¿ç¨‹çš„é¡µå¼‚å¸¸å¤„ç†ä¸åŠæ—¶å¯¼è‡´æ‰€æœ‰çº¿ç¨‹æ— æ³•æ­£å¸¸å¤„ç†é¡µå¼‚å¸¸çš„æƒ…å†µã€‚</p>

<p>â€ƒâ€ƒlinuxå†…æ ¸é’ˆå¯¹æ­¤ç§é—®é¢˜é‡‡ç”¨äº†æœ€å°åŒ–åŠ é”èŒƒå›´çš„æ–¹æ³•ã€‚æ¯æ¬¡æ“ä½œé¡µè¡¨å‰ï¼Œå¦‚æœé¡µè¡¨é¡¹ä¸å­˜åœ¨åˆ™å…ˆåˆ†é…é¡µï¼Œç„¶ååŠ mm_structé”ã€‚åŠ é”æˆåŠŸåï¼Œå¦‚æœå‘ç°é¡µè¡¨é¡¹å·²ç»è¢«èµ‹å€¼ï¼Œè¯´æ˜æœ‰å…¶ä»–CPUå…ˆäºå½“å‰CPUå®Œæˆäº†é¡µè¡¨åˆ†é…ï¼Œåˆ™é‡Šæ”¾å…ˆå‰åˆ†é…é¡µå¹¶è§£é”ï¼›å¦‚æœæœªè¢«èµ‹å€¼ï¼Œåˆ™å°†åˆ†é…é¡µèµ‹å€¼ç»™é¡µè¡¨é¡¹ï¼Œæœ€åè§£é”ã€‚è¿™ç§æ–¹æ³•è™½ç„¶ä¼šå¯¼è‡´ä¸€äº›å¤šä½™çš„é¡µåˆ†é…å’Œé‡Šæ”¾åŠ¨ä½œï¼Œä½†åŠ é”åŒºé—´å’ŒæŒé”æ—¶é—´å¤§å¤§ç¼©çŸ­ï¼Œç³»ç»Ÿæ•´ä½“å¹¶å‘æ€§å¤§å¤§æå‡ã€‚æ­¤å¤–ï¼Œå¯¹äºæœ€åä¸€çº§PTé¡µè¡¨çš„æ“ä½œæ¯”å‰å‡ çº§é¡µè¡¨å¤æ‚æ€§è¦é«˜å¾—å¤šï¼Œå› æ­¤å†…æ ¸å¯¹PTé¡µè¡¨ä½¿ç”¨äº†ä¸€æŠŠç‹¬ç«‹çš„é”ï¼Œè¿›ä¸€æ­¥æå‡ç³»ç»Ÿå¹¶è¡Œæ•ˆç‡ã€‚ä»£ç æ³¨è§£å¦‚ä¸‹ï¼š</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int __pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)
{
    pud_t *new = pud_alloc_one(mm, address); /*å…ˆå¿è¯•åˆ†é…ä¸€é¡µï¼Œè¯¥è¿‡ç¨‹æ‰§è¡Œæ—¶é—´å¯èƒ½ä¼šæ¯”è¾ƒé•¿*/
    if (!new)
    return -ENOMEM;

    smp_wmb(); /* See comment in __pte_alloc */

    /*åŠ é”åˆ¤æ–­åŸæœ‰é¡µè¡¨é¡¹æ˜¯å¦æ”¹å˜ï¼Œå¦‚æœå‘ç”Ÿæ”¹å˜è¯´æ˜æœ‰å…¶å®ƒæµç¨‹å·²æˆåŠŸåˆ†é…é¡µè¡¨ï¼Œè¿™é‡Œå°±é‡Šæ”¾ä¹‹é—´åˆ†é…çš„é¡µ*/
    spin_lock(&amp;mm-&gt;page_table_lock); 
    if (pgd_present(*pgd))		/* Another has populated it */
        pud_free(mm, new);
    else
        pgd_populate(mm, pgd, new);
    spin_unlock(&amp;mm-&gt;page_table_lock);
    return 0;
}

</code></pre></div></div>

<p>â€ƒâ€ƒæˆ‘ä»¬å†å›åˆ°é¡µå¼‚å¸¸å¤„ç†ä¸»é€»è¾‘ï¼Œæ¥ä¸‹æ¥handle_pte_faultå‡½æ•°æ ¹æ®PTé¡µè¡¨ä¸­å¼‚å¸¸åœ°å€å¯¹åº”çš„é¡µè¡¨é¡¹è¿›è¡Œä¸åŒå¤„ç†ï¼šå¦‚æœé¡µè¡¨é¡¹PRESENTä½æœªè¢«ç½®ä½ï¼Œä»£è¡¨ç‰©ç†é¡µä¸å­˜åœ¨ï¼Œéœ€è¦è¿›è¡Œç¼ºé¡µå¤„ç†ï¼›å¦åˆ™ï¼Œä»£è¡¨è®¿é—®æƒé™ä¸å¤Ÿï¼Œéœ€è¦è°ƒç”¨do_wp_pageè¿›è¡Œå†™ä¿æŠ¤å¤„ç†ã€‚åœ¨ç¼ºé¡µçš„æƒ…å†µä¸‹ï¼Œå¦‚æœé¡µè¡¨é¡¹ä¸ä¸ºé›¶ï¼Œè¯´æ˜å‰æœŸæŠŠç‰©ç†é¡µäº¤æ¢åˆ°ç£ç›˜ä¸Šäº†ï¼Œè€Œé¡µè¡¨é¡¹çºªå½•äº†äº¤æ¢é¡µæ‰€åœ¨çš„ç£ç›˜ä½ç½®ä¿¡æ¯ï¼Œé‚£ä¹ˆæ­¤æ—¶éœ€è¦é€šè¿‡do_swap_pageå°†äº¤æ¢é¡µå–å›å†…å­˜(å†…å­˜äº¤æ¢å°†å•ç‹¬èµ·ä¸€ç¯‡åšæ–‡åˆ†æ)ï¼›é¡µè¡¨é¡¹ä¸ºé›¶åˆ™æ ¹æ®vmaæ˜¯å¦æœ‰æ–‡ä»¶å¯¹åº”è¿›è¡Œä¸åŒå¤„ç†ï¼Œæ–‡ä»¶æ˜ å°„ç”±do_linear_faultå¤„ç†ï¼ŒåŒ¿åæ˜ å°„ç”±do_anonymous_pageå¤„ç†ã€‚handle_pte_faultä»£ç æ³¨è§£å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/mm/memory.c:

int handle_pte_fault(struct mm_struct *mm,
            struct vm_area_struct *vma, unsigned long address,
            pte_t *pte, pmd_t *pmd, unsigned int flags)
{
    pte_t entry;
    spinlock_t *ptl;

    entry = *pte;
    if (!pte_present(entry)) { /*åˆ¤æ–­é¡µæ˜¯å¦ä¸å­˜åœ¨*/
        if (pte_none(entry)) { /*å¦‚æœä¸ä»…ä¸å­˜åœ¨ï¼Œè€Œä¸”é¡µè¡¨é¡¹å†…å®¹ä¸ºé›¶*/
            if (vma-&gt;vm_ops) /*æ–‡ä»¶æ˜ å°„*/
                return do_linear_fault(mm, vma, address, pte, pmd, flags, entry);
            return do_anonymous_page(mm, vma, address, pte, pmd, flags); /*åŒ¿åæ˜ å°„*/
        }
        ...
        /*é¡µä¸å­˜åœ¨ï¼Œä½†æ˜¯éé›¶ï¼Œè¡¨ç¤ºæŒ‡å‘ä¸€ä¸ªäº¤æ¢é¡µï¼Œåˆ™æ‰§è¡Œæ¢å…¥æ“ä½œ*/
        return do_swap_page(mm, vma, address, pte, pmd, flags, entry);
    }

    ...

    /*å¤„ç†é˜²é—®æƒé™å¼‚å¸¸ï¼Œå¦‚å†™ä¿æŠ¤å¼‚å¸¸*/
    ptl = pte_lockptr(mm, pmd);
    spin_lock(ptl);
    if (unlikely(!pte_same(*pte, entry)))
        goto unlock;
    if (flags &amp; FAULT_FLAG_WRITE) {
        if (!pte_write(entry))
            return do_wp_page(mm, vma, address, pte, pmd, ptl, entry);
        entry = pte_mkdirty(entry);
    }
    ...
}
</code></pre></div></div>

<p>â€ƒâ€ƒdo_linear_faultå‡½æ•°å¤„ç†çº¿æ€§æ–‡ä»¶æ˜ å°„å†…å­˜æ®µçš„ç¼ºé¡µé—®é¢˜ã€‚å¯¹äºè¯»ç¼ºé¡µï¼Œé€šè¿‡æŸ¥æ‰¾æ–‡ä»¶ç¼“å­˜é¡µåç›´æ¥é‡‡ç”¨ç¼“å­˜é¡µä½œä¸ºæ˜ å°„é¡µï¼›å¯¹äºå†™ç¼ºé¡µï¼Œå…ˆæŸ¥æ‰¾æ–‡ä»¶ç¼“å­˜é¡µï¼Œå¦‚æœä¸ºå…±äº«å†…å­˜æ®µåˆ™ç›´æ¥é‡‡ç”¨ç¼“å­˜é¡µæ˜ å°„ï¼Œå¦‚æœä¸ºç§æœ‰å†…å­˜æ®µåˆ™åˆ†é…æ–°é¡µã€æ‹·è´ç¼“å­˜é¡µå†…å®¹åå†æ˜ å°„æ–°é¡µã€‚ä»£ç æ³¨è§£å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/mm/memory.c:

static int do_linear_fault(struct mm_struct *mm, struct vm_area_struct *vma,
                        unsigned long address, pte_t *page_table, pmd_t *pmd,
                        unsigned int flags, pte_t orig_pte)
{
    pgoff_t pgoff = (((address &amp; PAGE_MASK)
                    - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff; /*è®¡ç®—å¼‚å¸¸åœ°å€å¯¹åº”å†…å®¹åœ¨æ–‡ä»¶ä¸­çš„åç§»*/

    return __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);
}


static int __do_fault(struct mm_struct *mm, struct vm_area_struct *vma,
                    unsigned long address, pmd_t *pmd,
                    pgoff_t pgoff, unsigned int flags, pte_t orig_pte)
{
    pte_t *page_table;
    spinlock_t *ptl;
    struct page *page;
    struct page *cow_page;
    pte_t entry;
    int anon = 0;
    struct page *dirty_page = NULL;
    struct vm_fault vmf;
    int ret;


    /*å¯¹äºå†™æ“ä½œï¼Œå¦‚æœé¡µå¼‚å¸¸åœ°å€æ‰€åœ¨vmaæ®µçš„å±æ€§æ˜¯ç§æœ‰çš„ï¼Œå³æ²¡æœ‰è®¾ç½®VM_SHAREDæ ‡è®°ï¼Œ
      åˆ™éœ€è¦åˆ†é…ä¸€ä¸ªåŒ¿åé¡µå¹¶å¤åˆ¶æ–‡ä»¶ä¸­çš„å†…å®¹*/
    if ((flags &amp; FAULT_FLAG_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_SHARED)) {

        if (unlikely(anon_vma_prepare(vma)))
            return VM_FAULT_OOM;

        cow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);
        if (!cow_page)
            return VM_FAULT_OOM;

        ...
    } else
        cow_page = NULL;

    vmf.virtual_address = (void __user *)(address &amp; PAGE_MASK);
    vmf.pgoff = pgoff;
    vmf.flags = flags;
    vmf.page = NULL;

    /*é€šè¿‡æ–‡ä»¶ç³»ç»Ÿä¸­çš„faultæ“ä½œï¼Œåœ¨vmf.pageä¸­è¿”å›é¡µå¼‚å¸¸åœ°å€å¯¹åº”æ–‡ä»¶å†…å®¹çš„ç¼“å­˜é¡µ*/
    ret = vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf);
    ...

    page = vmf.page;
    if (flags &amp; FAULT_FLAG_WRITE) {
        if (!(vma-&gt;vm_flags &amp; VM_SHARED)) {
            page = cow_page;
            anon = 1;
            copy_user_highpage(page, vmf.page, address, vma); /*å¤åˆ¶ç¼“å­˜é¡µä¸­çš„å†…å®¹åˆ°åŒ¿åé¡µ*/
            __SetPageUptodate(page);
        } else {
            ...
        }
    }

    page_table = pte_offset_map_lock(mm, pmd, address, &amp;ptl);

    if (likely(pte_same(*page_table, orig_pte))) { /*é€šå¸¸éƒ½ä¼šè¿›å…¥è¯¥åˆ†æ”¯ï¼Œæ˜¯ä¸€ç§é«˜æ•ˆçš„é¡µè¡¨è®¿é—®æ–¹å¼*/
        entry = mk_pte(page, vma-&gt;vm_page_prot); /*å°†é¡µåœ°å€å’ŒåŸºæœ¬å±æ€§å¡«å…¥é¡µè¡¨é¡¹*/
        if (flags &amp; FAULT_FLAG_WRITE)
            entry = maybe_mkwrite(pte_mkdirty(entry), vma); /*è®¾ç½®é¡µè¡¨é¡¹å†™æƒé™*/
        if (anon) { /*å¦‚æœæ˜¯åŒ¿åé¡µï¼Œåˆ™æ·»åŠ åå‘åŒ¿åæ˜ å°„*/
            inc_mm_counter_fast(mm, MM_ANONPAGES);
            page_add_new_anon_rmap(page, vma, address);
        } else { /*å¦‚æœæ˜¯æ–‡ä»¶æ˜ å°„ï¼Œåˆ™æ·»åŠ åå‘æ–‡ä»¶æ˜ å°„*/
            inc_mm_counter_fast(mm, MM_FILEPAGES);
            page_add_file_rmap(page);
            if (flags &amp; FAULT_FLAG_WRITE) {
                dirty_page = page;
                get_page(dirty_page);
            }
        }
        set_pte_at(mm, address, page_table, entry); /*æœ€ç»ˆä¿®æ”¹é¡µè¡¨é¡¹å†…å®¹*/

        ...
    } else {
        ...
    }

    pte_unmap_unlock(page_table, ptl);

    ...
}

</code></pre></div></div>

<p>â€ƒâ€ƒdo_anonymous_pageå‡½æ•°å¤„ç†åŒ¿åæ˜ å°„å†…å­˜æ®µçš„ç¼ºé¡µé—®é¢˜ã€‚ç”±äºåŒ¿åæ˜ å°„æ²¡æœ‰å¯¹åº”æ–‡ä»¶ï¼Œè¿™é‡Œç›´æ¥åˆ†é…æ–°é¡µè¿›è¡Œæ˜ å°„ã€‚ä»£ç æ³¨è§£å¦‚ä¸‹ï¼š</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,
                        unsigned long address, pte_t *page_table, pmd_t *pmd,
                        unsigned int flags)
{
    struct page *page;
    spinlock_t *ptl;
    pte_t entry;

    ...

    /* Allocate our own private page. */
    if (unlikely(anon_vma_prepare(vma)))
        goto oom;
    page = alloc_zeroed_user_highpage_movable(vma, address);
    if (!page)
        goto oom;
    /*
     * The memory barrier inside __SetPageUptodate makes sure that
     * preceeding stores to the page contents become visible before
     * the set_pte_at() write.
     */
    __SetPageUptodate(page);

    entry = mk_pte(page, vma-&gt;vm_page_prot);
    if (vma-&gt;vm_flags &amp; VM_WRITE)
        entry = pte_mkwrite(pte_mkdirty(entry));

    page_table = pte_offset_map_lock(mm, pmd, address, &amp;ptl);
    ...

    inc_mm_counter_fast(mm, MM_ANONPAGES);
    page_add_new_anon_rmap(page, vma, address);
setpte:
    set_pte_at(mm, address, page_table, entry);
    ...

unlock:
    pte_unmap_unlock(page_table, ptl);
    return 0;
...
}
</code></pre></div></div>

<p>â€ƒâ€ƒdo_wp_pageå‡½æ•°å¤„ç†å†™ä¿æŠ¤ï¼Œå³é’ˆå¯¹æ²¡æœ‰å†™æƒé™çš„æ˜ å°„é¡µè§¦å‘äº†å†™è¯·æ±‚ã€‚è¿™é‡Œçš„å¤„ç†æ€è·¯å’ŒåŒ¿åé¡µå¤„ç†æœ‰äº›ç±»ä¼¼ï¼Œä¹Ÿæ˜¯åˆ†é…æ–°é¡µåæ‹·è´åŸæœ‰é¡µçš„å†…å®¹ï¼Œä¹‹åè§£é™¤åŸæœ‰é¡µçš„æ˜ å°„ä¹‹åå†æ˜ å°„æ–°é¡µã€‚</p>

<p>â€ƒâ€ƒè‡³æ­¤ï¼ŒMMUå’ŒCPUçš„å†…å­˜åœ°å€æ˜ å°„åŠŸèƒ½å·²ç»æ•´ä½“åˆ†æå®Œæ¯•ã€‚CPUåœ¨é¡µå¼‚å¸¸è¿‡ç¨‹ä¸­å¤šæ¬¡æ¶‰åŠå†…å­˜é¡µåˆ†é…ï¼Œè€Œå†…å­˜åˆ†é…åˆç‰µæ‰¯åˆ°å†…å­˜å›æ”¶å’Œäº¤æ¢ï¼Œè¿™äº›éƒ½å†…å­˜ç®¡ç†ä¸­ä¸å¯ç¼ºå°‘çš„éƒ¨åˆ†ï¼Œåç»­å°†å¯¹è¿™äº›éƒ¨åˆ†è¿›è¡Œæ·±å…¥åˆ†æã€‚</p>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2017/08/åœ°å€æ˜ å°„/">ã€è®¡ç®—å­ç³»ç»Ÿã€‘å†…å­˜ç®¡ç†ä¹‹ä¸€ï¼šåœ°å€æ˜ å°„</a></p>
:ET