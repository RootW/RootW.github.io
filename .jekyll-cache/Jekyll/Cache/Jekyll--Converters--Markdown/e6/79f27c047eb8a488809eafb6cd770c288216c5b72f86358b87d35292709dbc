I"áS<p>â€ƒâ€ƒåœ¨åˆ†æå®Œfirecrackerè™šæ‹Ÿæœºä¸­å„ä¸ªå­ç³»ç»Ÿçš„è¿è¡Œæ—¶åŸç†å’Œåˆå§‹åŒ–æµç¨‹åï¼Œæœ€åæˆ‘ä»¬æ•´ä½“åˆ†æä¸€ä¸‹firecrackerçš„ç³»ç»Ÿå¯åŠ¨è¿‡ç¨‹ï¼Œå¹¶é‡ç‚¹åˆ†æIOçº¿ç¨‹(fc_vmm)æ‰€é‡‡ç”¨çš„epolläº‹ä»¶å¾ªç¯æ¡†æ¶ã€‚</p>

<p>â€ƒâ€ƒå›é¡¾é¦–æ–‡ä¸­ä»‹ç»çš„firecrackerè¿›ç¨‹çš„çº¿ç¨‹æ¨¡å‹ï¼Œä¸‹å›¾å±•ç¤ºäº†çº¿ç¨‹é—´çš„äº‹ä»¶é€šçŸ¥å…³ç³»ï¼š</p>

<div align="center">                                                             
    <img src="/images/posts/firecracker/thread_com.jpg" height="155" width="757" />  
</div>

<p>â€ƒâ€ƒfirecrackerè¿›ç¨‹çš„ä¸»çº¿ç¨‹åœ¨å¯åŠ¨å®Œæˆåä¼šæˆä¸ºAPI Server Threadï¼Œå®ƒé€šè¿‡è¿›ç¨‹é—´socketå¥æŸ„ä¸å¤–éƒ¨HTTP Clientè¿›è¡Œé€šä¿¡ï¼Œæ¥æ”¶å¤–éƒ¨ç¨‹åºå‘é€çš„é…ç½®æˆ–æ§åˆ¶å‘½ä»¤(å›é¡¾ä¸€ä¸‹ä½¿ç”¨æ–¹æ³•)ï¼›API Server Threadæ”¶åˆ°å¤–éƒ¨å‘½ä»¤åé€šè¿‡api_event_fdå‘IO Threadå‘é€è¯·æ±‚ï¼Œç”±IO Threadå®Œæˆå®é™…çš„å¤„ç†åŠ¨ä½œï¼›å½“è™šæ‹Ÿæœºæ­£å¸¸å¯åŠ¨åï¼ŒIO Threadä¸»è¦é€šè¿‡io_event_fdæ¥å—æ¥è‡ªè™šæ‹ŸCPUçš„IOè¯·æ±‚ï¼Œå¹¶åœ¨å®ŒæˆIOè¯·æ±‚åé€šè¿‡irq_fdé€šçŸ¥CPUå¤„ç†ç»“æœã€‚</p>

<p>â€ƒâ€ƒæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ä»mainå‡½æ•°å¼€å§‹ï¼Œé€æ­¥åˆ†æä¸€ä¸‹ç³»ç»Ÿçš„å¯åŠ¨è¿‡ç¨‹ã€‚</p>

<pre><code class="language-nohighlight">firecracker/src/main.rs:

fn main() {
    â€¦
    let shared_info = Arc::new(RwLock::new(InstanceInfo {      // InstanceInfoå¯¹è±¡æ˜¯ä¸»çº¿ç¨‹å’Œfc_vmmçº¿ç¨‹ä¹‹é—´çš„å…±äº«å¯¹è±¡
                                                               //     Arcæ˜¯Rustæ ‡å‡†åº“æä¾›çš„åŸå­å¼•ç”¨ç±»å‹ï¼Œè·Ÿè¸ªå¤šä¸ªçº¿ç¨‹å¯¹ç›¸åŒ
                                                               //     å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ï¼›RwLockæ˜¯Rustæ ‡å‡†åº“æä¾›çš„è¯»å†™é”                      
        state: InstanceState::Uninitialized,                                    
        id: instance_id,                                                        
        vmm_version: crate_version!().to_string(),                               
    }));                                                                        
    let mmds_info = MMDS.clone();                                               
    let (to_vmm, from_api) = channel();                        // è¯¥channelå¯¹è±¡ç”¨äºåœ¨ä¸»çº¿ç¨‹å’Œfc_vmmçº¿ç¨‹ä¹‹é—´ä¼ é€’å¯¹è±¡
                                                               //     to_vmmä¸ºå‘é€ç«¯å¯¹è±¡ï¼Œåœ¨ä¸»çº¿ç¨‹ä¸­ä½¿ç”¨ï¼›from_apiä¸ºæ¥æ”¶
                                                               //     ç«¯ï¼Œåœ¨fc_vmmçº¿ç¨‹ä¸­ä½¿ç”¨                    
    let server =                                                                
        ApiServer::new(mmds_info, shared_info.clone(), to_vmm) // åˆ›å»ºä¸€ä¸ªApiServerå¯¹è±¡ï¼Œç”¨äºæ¥æ”¶å¤–éƒ¨ç¨‹åºçš„HTTPè¯·æ±‚
        .expect("Cannot create API server");

    let api_event_fd = server                                  // ç”³è¯·ä¸€ä¸ªevent_fdï¼Œç”¨äºä¸»çº¿ç¨‹å’Œfc_vmmçº¿ç¨‹ä¹‹é—´çš„äº‹ä»¶é€šçŸ¥
        .get_event_fd_clone()                                                   
        .expect("Cannot clone API eventFD.");                                   

    let _vmm_thread_handle =                                                    
        vmm::start_vmm_thread(                                 // æ­£å¼æ‹‰èµ·fc_vmmçº¿ç¨‹ï¼Œä¸‹æ–‡å°†è¿›ä¸€æ­¥åˆ†æ
            shared_info,
            api_event_fd,
            from_api,
            seccomp_level);

    match server.bind_and_run(                                 // ä¸»çº¿ç¨‹å¼€å§‹ä½œä¸ºAPI Serverçº¿ç¨‹ï¼Œç›‘å¬socketè¯·æ±‚
        bind_path, start_time_us,
        start_time_cpu_us, seccomp_level) {
        â€¦                                                                      
    }                                                                           
}


firecracker/vmm/src/lib.rs:

pub fn start_vmm_thread(                                                        
    api_shared_info: Arc&lt;RwLock&lt;InstanceInfo&gt;&gt;,                                 
    api_event_fd: EventFd,                                                       
    from_api: Receiver&lt;Box&lt;VmmAction&gt;&gt;,                                         
    seccomp_level: u32,                                                         
    ) -&gt; thread::JoinHandle&lt;()&gt; {                                                    
    thread::Builder::new()                                                      
        .name("fc_vmm".to_string())                                                           // å°†æ–°çº¿ç¨‹å–åä¸ºfc_vmm                                     
        .spawn(move || {                                                                      // åˆ›å»ºæ–°çº¿ç¨‹ï¼Œå‚æ•°ä¸ºæ–°çº¿ç¨‹å…¥å£å‡½æ•°(é—­åŒ…)
            let mut vmm = Vmm::new(api_shared_info, api_event_fd, from_api, seccomp_level)    // æ–°çº¿ç¨‹é¦–å…ˆåˆ›å»ºå…¨å±€Vmmå¯¹è±¡
                .expect("Cannot create VMM");                                   
            match vmm.run_control() {                                                         // è¿›å…¥epolläº‹ä»¶å¾ªç¯
                â€¦                                                              
            }                                                                   
        })                                                                       
        .expect("VMM thread spawn failed.")                                     
}

struct Vmm {                                            // Vmmå…¨å±€å¯¹è±¡
    kvm: KvmContext,                                    // KVMæ“ä½œä¸Šä¸‹æ–‡

    vm_config: VmConfig,                                // è™šæ‹Ÿæœºé…ç½®ï¼Œå¦‚CPUæ•°ã€å†…å­˜å¤§å°ç­‰
    shared_info: Arc&lt;RwLock&lt;InstanceInfo&gt;&gt;,             // API Serverçº¿ç¨‹ä¸fc_vmmçº¿ç¨‹å…±äº«å¯¹è±¡            

    // Guest VM core resources.                                                  
    guest_memory: Option&lt;GuestMemory&gt;,                  // è™šæ‹Ÿæœºå†…å­˜å¯¹è±¡              
    kernel_config: Option&lt;KernelConfig&gt;,                // å†…æ ¸é…ç½®ï¼Œå¦‚å¯åŠ¨å‘½ä»¤è¡Œå‚æ•°     
    vcpus_handles: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,         // vCPUçº¿ç¨‹è¿”å›å¥æŸ„æ•°ç»„            
    exit_evt: Option&lt;EpollEvent&lt;EventFd&gt;&gt;,              // è™šæ‹Ÿæœºé€€å‡ºäº‹ä»¶eventfd        
    vm: Vm,                                             // è™šæ‹Ÿæœºå¯¹è±¡

    // Guest VM devices.                                                        
    mmio_device_manager: Option&lt;MMIODeviceManager&gt;,     // mmioæ€»çº¿ç®¡ç†å™¨                             
    legacy_device_manager: LegacyDeviceManager,         // legacyæ€»çº¿ç®¡ç†å™¨                

    // Device configurations.                                                    
    block_device_configs: BlockDeviceConfigs,           // åç«¯å­˜å‚¨å—è®¾å¤‡é…ç½®ï¼Œä¾›virtio-blkä½¿ç”¨      
    network_interface_configs: NetworkInterfaceConfigs, // åç«¯ç½‘ç»œæ¥å£é…ç½®ï¼Œä¾›virtio-netä½¿ç”¨                   
    â€¦                                    

    epoll_context: EpollContext,                        // epolläº‹ä»¶å¾ªç¯ä¸Šä¸‹æ–‡

    // API resources.                                                           
    api_event: EpollEvent&lt;EventFd&gt;,                     // æ¥æ”¶API Serverçº¿ç¨‹é€šçŸ¥çš„eventfd
    from_api: Receiver&lt;Box&lt;VmmAction&gt;&gt;,                 // channelæ¥æ”¶æ–¹ï¼Œå¯æ¥æ”¶æ¥å‘API Serverçº¿ç¨‹å¯¹è±¡         
    â€¦                                                       
}

impl Vmm {                                                                      
    fn new(                                                                      
        api_shared_info: Arc&lt;RwLock&lt;InstanceInfo&gt;&gt;,                             
        api_event_fd: EventFd,                                                  
        from_api: Receiver&lt;Box&lt;VmmAction&gt;&gt;,                                      
        seccomp_level: u32,                                                     
    ) -&gt; Result&lt;Self&gt; {                                                         
        let mut epoll_context = EpollContext::new()?;                  // åˆå§‹åŒ–epollä¸Šä¸‹æ–‡              
        let api_event = epoll_context                                           
            .add_event(api_event_fd, EpollDispatch::VmmActionRequest)  // å°†api_event_fdæ·»åŠ åˆ°epollä¸Šä¸‹ï¼Œå¯ç›‘å¬è¯¥å¥æŸ„          
            .expect("Cannot add API eventfd to epoll.");                                     

        let block_device_configs = BlockDeviceConfigs::new();          // åˆå§‹åŒ–å­˜å‚¨é…ç½®å¯¹è±¡           
        let kvm = KvmContext::new()?;                                  // åˆ›å»ºKVMä¸Šä¸‹æ–‡
        let vm = Vm::new(kvm.fd()).map_err(Error::Vm)?;                // åˆ›å»ºè™šæ‹Ÿæœºå¯¹è±¡

        Ok(Vmm {                                                                
            kvm,                                                                
            vm_config: VmConfig::default(),                                     
            shared_info: api_shared_info,                                       
            guest_memory: None,                                                 
            kernel_config: None,                                                 
            vcpus_handles: vec![],                                              
            exit_evt: None,                                                     
            vm,                                                                  
            mmio_device_manager: None,                                          
            legacy_device_manager: LegacyDeviceManager::new().map_err(Error::CreateLegacyDevice)?,
            block_device_configs,                                                
            network_interface_configs: NetworkInterfaceConfigs::new(),          
            â€¦
            epoll_context,                                                      
            api_event,                                                           
            from_api,                                                           
            â€¦                                                       
        })                                                                       
    } 

    fn run_control(&amp;mut self) -&gt; Result&lt;()&gt; {                                                       // äº‹ä»¶å¾ªç¯æ¡†æ¶                                
        const EPOLL_EVENTS_LEN: usize = 100;                                     

        let mut events = vec![epoll::Event::new(epoll::Events::empty(), 0); EPOLL_EVENTS_LEN];      // åˆ›å»ºä¸€ä¸ªeventsæ•°ç»„ï¼Œç”¨äºæ¥æ”¶äº‹ä»¶

        let epoll_raw_fd = self.epoll_context.epoll_raw_fd;                     

        'poll: loop {                                                                               // å¾ªç¯å…¥å£                                                     
            let num_events = epoll::wait(epoll_raw_fd, -1, &amp;mut events[..]).map_err(Error::Poll)?;  // é€šè¿‡epollè·çŸ¥å·²ç»å‘ç”Ÿçš„äº‹ä»¶

            for event in events.iter().take(num_events) {                                           // é’ˆå¯¹å·²ç»å‘ç”Ÿçš„äº‹ä»¶ä¾æ¬¡è¿›è¡Œå¤„ç†                       
                let dispatch_idx = event.data as usize;                                             // è·çŸ¥äº‹ä»¶dispatch_idxï¼Œæ³¨å†Œäº‹ä»¶æ—¶ä¼ å…¥                       
                let evset = match epoll::Events::from_bits(event.events) {                          // è·çŸ¥å…·ä½“äº‹ä»¶ï¼Œå¦‚POLLIN     
                    â€¦                                                            
            };                                                               

            if let Some(dispatch_type) = self.epoll_context.dispatch_table[dispatch_idx] {          // æ ¹æ®disptach_idxæ‰¾åˆ°äº‹ä»¶ç±»å‹ï¼Œæ³¨å†Œæ—¶å¡«å…¥
                match dispatch_type {                                       
                    EpollDispatch::Exit =&gt; {                                                        // ç¬¬ä¸€ç±»åˆ«ï¼Œé€€å‡ºï¼›VCPUçº¿ç¨‹é€€å‡ºæ—¶äº§ç”Ÿ
                        â€¦               
                    }                                                       
                    EpollDispatch::Stdin =&gt; {                                                       // ç¬¬äºŒç±»å‹ï¼Œæ ‡å‡†è¾“å…¥ï¼›ä½¿èƒ½ä¸²å£ä½¿æ³¨å†Œï¼Œæ¥
                                                                                                    // æ”¶æ ‡å‡†è¾“å…¥å¹¶ä½œä¸ºè™šæ‹Ÿæœºä¸²å£çš„è¾“å…¥                              
                        â€¦                     
                    }                                                       
                    EpollDispatch::DeviceHandler(device_idx, device_token) =&gt; {                     // ç¬¬ä¸‰ç±»å‹ï¼Œvirtioè®¾å¤‡IOå¤„ç†ï¼›VCPUé€šè¿‡io_event_fdäº§ç”Ÿ     
                        match self                                          
                            .epoll_context                                  
                            .get_device_handler_by_handler_id(device_idx)                            // é¦–æ¬¡å¤„ç†æ—¶é€šè¿‡channelè·å–EpollHandlerå¯¹è±¡ï¼Œå›é¡¾virtio
                        {                                                                            // è®¾å¤‡çš„activateæµç¨‹
                            Ok(handler) =&gt; match handler.handle_event(device_token, evset) {         // è°ƒç”¨EpollHandlerå¯¹è±¡çš„handle_eventå‡½æ•°
                                â€¦                                    
                            },                                              
                            â€¦                                               
                        }                                                    
                    }                                               
                    EpollDispatch::VmmActionRequest =&gt; {                                             // ç¬¬å››ç±»å‹ï¼Œç®¡ç†åŠ¨ä½œï¼›æ¥ä½œAPI Serverçº¿ç¨‹          
                        self.api_event.fd.read().map_err(Error::EventFd)?;  
                        self.run_vmm_action().unwrap_or_else(|_| {                                   // è°ƒç”¨run_vmm_action     
                            â€¦
                        });                                                 
                    }                                                       
                    â€¦                                                      
                }                                                           
            }                                                               
        }                                                                    
    }                                                                       
}
</code></pre>

<p>â€ƒâ€ƒfirecrackerå¯åŠ¨åˆæœŸï¼Œfc_vmmçº¿ç¨‹ä»…å¯¹api_event_fdè¿›è¡Œç›‘å¬ï¼Œå³ä»…èƒ½å¯¹ç¬¬å››ç±»å‹äº‹ä»¶è¿›è¡Œå¤„ç†ã€‚å›é¡¾é¦–ç¯‡å¯¹firecrackerä½¿ç”¨æµç¨‹çš„ä»‹ç»ï¼Œæˆ‘ä»¬é€šè¿‡curlå·¥å…·å¯¹firecrackerè¿›è¡Œkernelã€rootfså’Œè™šæ‹Ÿæœºçš„é…ç½®åï¼Œæœ€åé€šè¿‡InstanceStartå‘½ä»¤å¯åŠ¨è™šæ‹Ÿæœºã€‚è¿™é‡Œçš„é…ç½®å’Œå¯åŠ¨å‘½ä»¤æœ€åéƒ½äº¤ç”±fc_vmmçš„run_vmm_actionå‡½æ•°è¿›è¡Œå¤„ç†ï¼š</p>

<pre><code class="language-nohighlight">
    fn run_vmm_action(&amp;mut self) -&gt; Result&lt;()&gt; {                                                             
        let request = match self.from_api.try_recv() {                                    // ä»API Serverçº¿ç¨‹æ¥æ”¶ç”¨æˆ·è¯·æ±‚                      
            â€¦                                                                 
        };                                                                      

        match request {                                                                    // æ ¹æ®ç”¨æˆ·è¯·æ±‚ç±»åˆ«åˆ†åˆ«è¿›è¡Œå¤„ç†                                                      
            VmmAction::ConfigureBootSource(boot_source_body, sender) =&gt; {                  // å†…æ ¸å¯åŠ¨å‚æ•°é…ç½®     
                Vmm::send_response(                                             
                    self.configure_boot_source(                                 
                        boot_source_body.kernel_image_path,                     
                        boot_source_body.boot_args,                             
                    ),                                                          
                    sender,                                                      
                ); 

            }                                                                   
            â€¦                                                                
            VmmAction::InsertBlockDevice(block_device_config, sender) =&gt; {                 // é…ç½®å­˜å‚¨å—è®¾å¤‡
                Vmm::send_response(self.insert_block_device(block_device_config), sender);
            }                                                                    
            VmmAction::InsertNetworkDevice(netif_body, sender) =&gt; {                        // é…ç½®ç½‘ç»œæ¥å£è®¾å¤‡
                Vmm::send_response(self.insert_net_device(netif_body), sender); 
            }                                                                    
            â€¦                                                                 
            VmmAction::StartMicroVm(sender) =&gt; {                                           // é…ç½®å®Œæˆåï¼Œå¯åŠ¨ä¸€ä¸ªè™šæ‹Ÿæœº
                Vmm::send_response(self.start_microvm(), sender);               
            }                                                                                                                                    
            VmmAction::SetVmConfiguration(machine_config_body, sender) =&gt; {                // é…ç½®è™šæ‹ŸæœºCPUå’Œå†…å­˜ç­‰    
                Vmm::send_response(self.set_vm_configuration(machine_config_body), sender);
            }                                                                   
            â€¦                                                                    
        };                                                                      
       Ok(())                                                                  
    }
</code></pre>

<p>â€ƒâ€ƒæœ€åï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹firecrackerè™šæ‹Ÿæœºçš„å¯åŠ¨è¿‡ç¨‹ï¼Œå¯¹å„ä¸ªå­ç³»ç»Ÿåˆå§‹åŒ–è¿›è¡Œä¸€äº›ä¸²è”ï¼š</p>

<pre><code class="language-nohighlight">    fn start_microvm(&amp;mut self) -&gt; std::result::Result&lt;VmmData, VmmActionError&gt; {
        â€¦         
        self.shared_info                                                                       
            .write()                                               // å¯¹å…±äº«å¯¹è±¡åŠ å†™é”
            .expect("Failed to start microVM because shared info couldn't be written due to poisoned lock")
            .state = InstanceState::Starting;                      // å°†è™šæ‹ŸæœºçŠ¶æ€è®¾ä¸ºStartingï¼Œå®Œæˆåè‡ªåŠ¨è§£é”(Rustè¯­è¨€ç‰¹æ€§)

        self.init_guest_memory()?;                                 // è™šæ‹Ÿå†…å­˜åˆå§‹åŒ–ï¼Œå‚è€ƒCPUä¸å†…å­˜éƒ¨åˆ†

        let vcpus;                                                              

        #[cfg(target_arch = "x86_64")]                                          
        {                                                                       
            self.setup_interrupt_controller()?;                   // ä¸­æ–­æ§åˆ¶å™¨åˆå§‹åŒ–ï¼Œå‚è€ƒæ—¶é’Ÿä¸ä¸­æ–­éƒ¨åˆ†       
            self.attach_virtio_devices()?;                        // æ·»åŠ virito-blk/netï¼Œå†…éƒ¨å°†è°ƒç”¨register_virtio_deviceï¼Œå‚è€ƒvirtioè®¾å¤‡éƒ¨åˆ†
            self.attach_legacy_devices()?;                        // legacyè®¾å¤‡åˆå§‹åŒ–ï¼Œå‚è€ƒlegacyè®¾å¤‡éƒ¨åˆ†

            let entry_addr = self.load_kernel()?;                 // åŠ è½½ELFå†…æ ¸åˆ°entry_addr
            vcpus = self.create_vcpus(entry_addr, request_ts)?;   // åˆ›å»ºVCPUï¼Œå‚è€ƒCPUä¸å†…å­˜éƒ¨åˆ†             
        }
        â€¦                                                               
        self.configure_system()?;                                 // é…ç½®ç³»ç»Ÿï¼Œä¸»è¦æ˜¯ç”Ÿæˆmptableå’Œå¼•å¯¼æ•°æ®å¤´éƒ¨

        self.register_events()?;                                  // å‘epolläº‹ä»¶å¾ªç¯æ³¨å†Œé€€å‡ºäº‹ä»¶å’Œæ ‡å‡†è¾“å…¥äº‹ä»¶

        self.start_vcpus(vcpus)?;                                 // å¯åŠ¨è™šæ‹ŸCPUï¼Œå‚è€ƒCPUä¸å†…å­˜éƒ¨åˆ†                                               

        self.shared_info                                                         
            .write()                                              // é‡æ–°å¯¹å…±äº«å¯¹è±¡åŠ å†™é”
            .expect("Failed to start microVM because shared info couldn't be written due to poisoned lock")
            .state = InstanceState::Running;                      // å°†è™šæ‹ŸæœºçŠ¶æ€è®¾ä¸ºRunningï¼Œä»£è¡¨è™šæ‹Ÿæœºå·²æ­£å¸¸è¿è¡Œ!!!                                                                   
        â€¦                                                                                                                                          
        Ok(VmmData::Empty)                                                      
    }                
</code></pre>
<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2019/09/firecracker-startvm/">ã€firecrackerã€‘ç³»ç»Ÿå¯åŠ¨ä¸epolläº‹ä»¶å¾ªç¯</a></p>
:ET