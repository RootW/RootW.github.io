I"—N<p>â€ƒâ€ƒåœ¨åˆ†æSPDKæ•°æ®é¢ä»£ç ä¹‹å‰ï¼Œéœ€è¦æˆ‘ä»¬å¯¹qemuä¸­å®ç°çš„IOç¯ä»¥åŠvirtioå‰åç«¯é©±åŠ¨çš„å®ç°æœ‰æ‰€äº†è§£(åç»­æˆ‘è®¡åˆ’å‡ºä¸“é—¨çš„åšæ–‡æ¥ä»‹ç»qemu)ã€‚è¿™é‡Œæˆ‘ä»¬ä»ä»¥SPDKå‰ç«¯é…ç½®vhost-blkï¼Œåç«¯å¯¹æ¥NVMe SSDä¸ºä¾‹(æœ‰å…³NVMeé©±åŠ¨æ¶‰åŠè¾ƒå¤šè§„èŒƒç»†èŠ‚ï¼Œè¿™é‡Œä¹Ÿä¸ä½œè¿‡äºæ·±å…¥çš„è®¨è®ºï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥ç»“åˆNVMeè§„èŒƒå±•å¼€é˜…è¯»)è¿›è¡Œåˆ†æã€‚</p>

<h3 id="æ€»æµç¨‹">æ€»æµç¨‹</h3>

<p>â€ƒâ€ƒå‰æ–‡åœ¨åˆ†æSPDK IOæ ˆæ—¶å·²ç»å¤§è‡´åˆ†æäº†IOå¤„ç†çš„è°ƒç”¨å±‚æ¬¡ï¼Œåœ¨æ­¤æˆ‘ä»¬è¿›ä¸€æ­¥æ‰“å¼€å†…éƒ¨å®ç°ç»†èŠ‚ï¼Œæ›´ç»†è‡´åœ°åˆ†æä¸€ä¸‹IOå¤„ç†æµç¨‹ï¼š</p>

<div align="center">
<img src="/images/posts/spdk/ioanalyze.jpg" height="600" width="750" />  
</div>

<p>â€ƒâ€ƒé¦–å…ˆï¼Œä»è™šæ‹Ÿæœºè§†è§’æ¥è¯´ï¼Œå®ƒçœ‹åˆ°çš„æ˜¯ä¸€ä¸ªvirtio-blk-pciè®¾å¤‡ï¼Œè¯¥pciè®¾å¤‡å†…éƒ¨åŒ…å«ä¸€æ¡virtioæ€»çº¿ï¼Œå…¶ä¸Šåˆè¿æ¥äº†virtio-blkè®¾å¤‡ã€‚qemuåœ¨å¯¹è™šæ‹Ÿæœºç”¨æˆ·å‘ˆç°è¿™ä¸ªvirtio-blk-pciè®¾å¤‡æ—¶ï¼Œé‡‡ç”¨çš„å…·ä½“è®¾å¤‡ç±»å‹æ˜¯vhost-user-blk-pci(è¿™æ˜¯virtio-blk-pciè®¾å¤‡çš„ä¸€ç§åç«¯å®ç°æ–¹å¼ã€‚å¦å¤–ä¸¤ç§æ˜¯ï¼švhost-blk-pciï¼Œç”±å†…æ ¸å®ç°åç«¯ï¼›æ™®é€švirtio-blk-pciï¼Œç”±qemuå®ç°åç«¯å¤„ç†)ï¼Œè¿™æ ·ä¾¿å¯ä¸ç”¨æˆ·æ€çš„SPDK vhostè¿›ç¨‹å»ºç«‹è¿æ¥ã€‚SPDK vhostè¿›ç¨‹å†…éƒ¨å¯¹äºè™šæ‹Ÿæœºæ‰€è§çš„virtio-blk-pciè®¾å¤‡ä¹Ÿæœ‰ä¸€ä¸ªå¯¹è±¡æ¥è¡¨ç¤ºå®ƒï¼Œè¿™å°±æ˜¯spdk_vhost_blk_devã€‚è¯¥å¯¹è±¡æŒ‡å‘ä¸€ä¸ªbdevå¯¹è±¡å’Œä¸€ä¸ªio channelå¯¹è±¡ï¼Œbdevå¯¹è±¡ä»£è¡¨çœŸæ­£çš„åç«¯å—å­˜å‚¨(è¿™é‡Œå¯¹åº”NVMe SSDä¸Šçš„ä¸€ä¸ªnamespace)ï¼Œio channelä»£è¡¨å½“å‰çº¿ç¨‹è®¿é—®å­˜å‚¨çš„ç‹¬ç«‹é€šé“(å¯¹åº”NVMe SSDçš„ä¸€ä¸ªQueue Pair)ã€‚è¿™ä¸¤ä¸ªå¯¹è±¡åœ¨é©±åŠ¨å±‚ä¼šè¿›ä¸€æ­¥æ‰©å±•æ–°çš„æˆå‘˜å˜é‡ï¼Œç”¨æ¥è¡¨ç¤ºé©±åŠ¨å±‚å¯è§çš„ä¸€äº›è¯¦ç»†ä¿¡æ¯ã€‚</p>

<p>â€ƒâ€ƒå…¶æ¬¡ï¼Œå½“è™šæ‹Ÿæœºå¾€IOç¯ä¸­æ”¾å…¥IOè¯·æ±‚åï¼Œä¾¿ç«‹åˆ»è¢«vhostè¿›ç¨‹ä¸­çš„æŸä¸ªreactorçº¿ç¨‹è½®å¾ªåˆ°è¯¥è¯·æ±‚(è½®å¾ªè¿‡ç§ä¸­æ‰§è¡Œå‡½æ•°ä¸ºvdev_worker)ã€‚reactorçº¿ç¨‹å–å‡ºè¯·æ±‚åï¼Œä¼šå°†å…¶æ˜ æˆä¸€ä¸ªä»»åŠ¡(spdk_vhost_blk_task)ã€‚å¯¹äºè¯»å†™è¯·æ±‚ï¼Œä¼šè¿›ä¸€æ­¥èµ°åˆ°bdevå±‚ï¼Œå°†ä»»åŠ¡å°çŠ¶æˆä¸€ä¸ªbdev_ioå¯¹è±¡(ç±»ä¼¼å†…æ ¸çš„bio)ã€‚bdev_ioç»§ç»­å¾€é©±åŠ¨å±‚é€’äº¤ï¼Œå®ƒä¼šæ‰©å±•ä¸ºé€‚é…å…·ä½“é©±åŠ¨çš„ioå¯¹è±¡ï¼Œä¾‹å¦‚é’ˆå¯¹NVMeé©±åŠ¨ï¼Œbdev_ioå°†æ‰©å±•æˆnvme_bdev_ioå¯¹è±¡ã€‚NVMeé©±åŠ¨ä¼šæ ¹æ®nvme_bdev_ioå¯¹è±¡ä¸­çš„è¯·æ±‚å†…å®¹åœ¨å½“å‰reactorçº¿ç¨‹å¯¹åº”çš„QueuePairä¸­ç”Ÿæˆä¸€ä¸ªæ–°çš„è¯·æ±‚é¡¹ï¼Œå¹¶é€šçŸ¥NVMeæ§åˆ¶å™¨æœ‰æ–°çš„è¯·æ±‚äº§ç”Ÿã€‚</p>

<p>â€ƒâ€ƒæœ€åï¼Œå½“ç‰©ç†NVMeæ§åˆ¶å™¨å®ŒæˆIOè¯·æ±‚åï¼Œä¼šå¾€QueuePairä¸­æ·»åŠ IOå“åº”ã€‚è¯¥å“åº”ä¿¡æ¯ä¹Ÿä¼šå¾ˆå¿«è¢«reactorçº¿ç¨‹è½®å¾ªåˆ°(è½®å¾ªæ‰§è¡Œå‡½æ•°ä¸ºbdev_nvme_poll)ã€‚reactorå–å‡ºå“åº”åï¼Œæ ¹æ®å…¶idæ‰¾åˆ°å¯¹åº”çš„nvme_bdev_ioï¼Œè¿›ä¸€æ­¥å…³è”åˆ°å¯¹åº”çš„bdev_ioï¼Œå†è°ƒç”¨bdev_ioä¸­çš„è®°å½•çš„å›è°ƒå‡½æ•°ã€‚vhost-blkä¸‹å‘è¯·æ±‚æ—¶æ³¨å†Œçš„å›è°ƒå‡½æ•°ä¸ºblk_request_complete_cbï¼Œå›è°ƒå‚æ•°ä¸ºå½“å‰çš„spdk_vhost_blk_taskå¯¹è±¡ã€‚åœ¨blk_request_complete_cbä¸­ä¼šå¾€è™šæ‹ŸæœºIOç¯ä¸­æ”¾å…¥IOå“åº”ï¼Œå¹¶é€šè¿‡è™šæ‹Ÿä¸­æ–­é€šçŸ¥è™šæ‹ŸæœºIOå®Œæˆã€‚</p>

<h3 id="ioè¯·æ±‚ä¸‹å‘æµç¨‹ä»£ç è§£æ">IOè¯·æ±‚ä¸‹å‘æµç¨‹ä»£ç è§£æ</h3>

<p>â€ƒâ€ƒvhostè¿›ç¨‹é€šè¿‡vdev_workerå‡½æ•°ä»¥è½®å¾ªæ–¹å¼å¤„ç†è™šæ‹Ÿæœºä¸‹å‘çš„IOè¯·æ±‚ï¼Œè°ƒç”¨æ ˆå¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vdev_worker()
    \-process_vq()
        |-spdk_vhost_vq_avail_ring_get()
        \-process_blk_request()
            |-blk_iovs_setup()
            \-spdk_bdev_readv()/spdk_bdev_writev()
                \-spdk_bdev_io_submit()
                    \-bdev-&gt;fn_table-&gt;submit_request()
</code></pre></div></div>

<p>â€ƒâ€ƒä¸‹é¢æˆ‘ä»¬å…ˆæ¥åˆ†æä¸€ä¸‹vhost-blkå±‚çš„å…·ä½“ä»£ç å®ç°ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/vhost/vhost-blk.c:

/* reactorçº¿ç¨‹ä¼šé‡‡ç”¨è½®å¾ªæ–¹å¼å‘¨æœŸæ€§åœ°è°ƒç”¨vdev_workerå‡½æ•°æ¥å¤„ç†è™šæ‹Ÿæœºä¸‹å‘çš„è¯·æ±‚ */
static int
vdev_worker(void *arg)
{
    /* argåœ¨æ³¨å†Œè½®å¾ªå‡½æ•°æ—¶æŒ‡å®šï¼Œä»£è¡¨å½“å‰æ“ä½œçš„vhost-blkå¯¹è±¡ */
    struct spdk_vhost_blk_dev *bvdev = arg; 
    uint16_t q_idx;

    /* vhost-blkå¯¹è±¡bvdevä¸­å«æœ‰ä¸€ä¸ªæŠ½è±¡çš„spdk_vhost_devå¯¹è±¡ï¼Œå…¶å†…éƒ¨è®°å½•æ‰€æœ‰vhost_devç±»åˆ«å¯¹è±¡
        å‡å«æœ‰çš„å…¬å…±å†…å®¹ï¼Œmax_queuesä»£è¡¨å½“å‰vhost_devå¯¹è±¡å…±æœ‰å¤šå°‘ä¸ªIOç¯ï¼Œvirtqueue[]æ•°ç»„è®°å½•äº†
        æ‰€æœ‰çš„IOç¯ä¿¡æ¯ */
    for (q_idx = 0; q_idx &lt; bvdev-&gt;vdev.max_queues; q_idx++) {
        /* æ ¹æ®IOç¯çš„ä¸ªæ•°ï¼Œä¾æ¬¡å¤„ç†æ¯ä¸ªç¯ä¸­çš„è¯·æ±‚ */
        process_vq(bvdev, &amp;bvdev-&gt;vdev.virtqueue[q_idx]);
    }

    ...

}

/* å¤„ç†IOç¯ä¸­çš„æ‰€æœ‰è¯·æ±‚ */
static void
process_vq(struct spdk_vhost_blk_dev *bvdev, struct spdk_vhost_virtqueue *vq)
{
    struct spdk_vhost_blk_task *task;
    int rc;
    uint16_t reqs[32];
    uint16_t reqs_cnt, i;

    /* å…ˆç»™å‡ºä¸€äº›å…³äºIOç¯çš„çŸ¥è¯†ï¼š
            (1) ç®€å•æ¥è¯´ï¼Œæ¯ä¸ªIOç¯åˆ†æˆdescriptoræ•°ç»„ã€availæ•°ç»„å’Œusedæ•°ç»„ä¸‰ä¸ªéƒ¨åˆ†ï¼Œæ•°ç»„å…ƒç´ ä¸ªæ•°å‡ä¸ºç¯çš„æœ€å¤§è¯·æ±‚ä¸ªæ•°ã€‚
            (2) descriptoræ•°ç»„å…ƒç´ ä»£è¡¨ä¸€æ®µè™šæ‹Ÿæœºå†…å­˜ï¼Œæ¯ä¸ªIOè¯·æ±‚è‡³å°‘åŒ…å«ä¸‰æ®µï¼Œè¯·æ±‚å¤´éƒ¨æ®µã€æ•°æ®æ®µ(è‡³å°‘ä¸€ä¸ª)å’Œå“åº”æ®µã€‚
                è¯·æ±‚å¤´éƒ¨åŒ…å«è¯·æ±‚ç±»å‹(è¯»æˆ–å†™)ã€è®¿é—®åç§»ï¼Œæ•°æ®æ®µä»£è¡¨å®é™…çš„æ•°æ®å­˜æ”¾ä½ç½®ï¼Œå“åº”æ®µè®°å½•è¯·æ±‚å¤„ç†ç»“æœã€‚ä¸€èˆ¬æ¥è¯´ï¼Œ
                æ¯ä¸ªIOè¯·æ±‚åœ¨descriptorä¸­è‡³å°‘è¦å æ®ä¸‰ä¸ªå…ƒç´ ï¼›ä¸è¿‡å½“é…ç½®äº†indirectç‰¹æ€§åï¼Œä¸€ä¸ªIOè¯·æ±‚åªå ç”¨ä¸€é¡¹ï¼Œåªä¸è¿‡
                è¯¥é¡¹æŒ‡å‘çš„å†…å­˜æ®µåˆæ˜¯ä¸€ä¸ªdescriptoræ•°ç»„ï¼Œè¯¥æ•°ç»„å…ƒç´ ä¸ªæ•°ä¸ºIOè¯·æ±‚å®é™…æ‰€éœ€å†…å­˜æ®µã€‚
            (3) availæ•°ç»„ç”¨æ¥è®°å½•å·²ä¸‹å‘çš„IOè¯·æ±‚ï¼Œæ•°ç»„å…ƒç´ å†…å®¹ä¸ºIOè¯·æ±‚åœ¨descriptoræ•°ç»„ä¸­çš„ä¸‹æ ‡ï¼Œè¯¥ä¸‹æ ‡å¯ä½œä¸ºè¯·æ±‚çš„idã€‚
            (4) usedæ•°ç»„ç”¨æ¥è®°å½•å·²å®Œæˆçš„IOå“åº”ï¼Œæ•°ç»„å…ƒç´ å†…å®¹åŒæ ·ä¸ºIOåœ¨descritproræ•°ç»„ä¸­çš„ä¸‹æ ‡ã€‚
    */

    /* ä»IOç¯çš„availæ•°ç»„ä¸­ä¸­å–å‡ºä¸€æ‰¹è¯·æ±‚ï¼Œå°†è¯·æ±‚idæ”¾å…¥reqsæ•°ç»„ä¸­ï¼›æ¯æ¬¡å°†ç¯å–ç©ºæˆ–è€…æœ€å¤šå–32ä¸ªè¯·æ±‚ */
    reqs_cnt = spdk_vhost_vq_avail_ring_get(vq, reqs, SPDK_COUNTOF(reqs));
    ...

    /* ä¾æ¬¡å¯¹reqsæ•°ç»„ä¸­çš„è¯·æ±‚è¿›è¡Œå¤„ç† */
    for (i = 0; i &lt; reqs_cnt; i++) {
        ...
        
        /* ä»¥è¯·æ±‚idä½œä¸ºä¸‹æ ‡ï¼Œæ‰¾åˆ°å¯¹åº”çš„taskå¯¹è±¡ã€‚æ³¨ï¼Œåˆå§‹åŒ–æ—¶ï¼Œä¼šæŒ‰IOç¯çš„æœ€å¤§è¯·æ±‚ä¸ªæ•°æ¥ç”³è¯·tasksæ•°ç»„ */
        task = &amp;((struct spdk_vhost_blk_task *)vq-&gt;tasks)[reqs[i]];
        ...

        bvdev-&gt;vdev.task_cnt++; /* ä½œç»Ÿè®¡è®¡æ•° */

        task-&gt;used = true; /* ä»£è¡¨tasksæ•°ç»„ä¸­è¯¥é¡¹æ­£åœ¨è¢«ä½¿ç”¨ */
        task-&gt;iovcnt = SPDK_COUNTOF(task-&gt;iovs); /* iovsæ•°ç»„å°†æ¥ä¼šè®°å½•IOè¯·æ±‚ä¸­æ•°æ®æ®µçš„å†…å­˜æ˜ å°„ä¿¡æ¯ */
        task-&gt;status = NULL; /* å°†æ¥æŒ‡å‘IOå“åº”æ®µï¼Œç”¨æ¥ç»™è™šæ‹Ÿæœºè¿”å›IOå¤„ç†ç»“æœ */
        task-&gt;used_len = 0;

        /* å°†IOç¯ä¸­è¯·æ±‚çš„è¯¦ç»†ä¿¡æ¯è®°å½•åˆ°taskä¸­ï¼Œå¹¶é€’äº¤ç»™bdevå±‚å¤„ç† */
        rc = process_blk_request(task, bvdev, vq);
        ...
    }
}

static int
process_blk_request(struct spdk_vhost_blk_task *task, struct spdk_vhost_blk_dev *bvdev,
struct spdk_vhost_virtqueue *vq)
{
    const struct virtio_blk_outhdr *req;
    struct iovec *iov;
    uint32_t type;
    uint32_t payload_len;
    int rc;

    /* å°†IOç¯descriptoræ•°ç»„ä¸­è®°å½•çš„è¯·æ±‚å†…å­˜æ®µ(ä»¥gpaè¡¨ç¤ºï¼Œå³Guest Physical Address)æ˜ æˆvhostè¿›ç¨‹ä¸­çš„
        è™šæ‹Ÿåœ°å€(vva, vhost virtual address)ï¼Œå¹¶ä¿å­˜åˆ°taskçš„iovsæ•°ç»„ä¸­ */
    if (blk_iovs_setup(&amp;bvdev-&gt;vdev, vq, task-&gt;req_idx, task-&gt;iovs, &amp;task-&gt;iovcnt, &amp;payload_len)) {
        ...
    }

    /* ç¬¬ä¸€ä¸ªè¯·æ±‚å†…å­˜æ®µä¸ºè¯·æ±‚å¤´éƒ¨ï¼Œå³struct virtio_blk_outhdrï¼Œè®°å½•è¯·æ±‚ç±»å‹ã€è®¿é—®ä½ç½®ä¿¡æ¯ */
    iov = &amp;task-&gt;iovs[0];
    ...
    req = iov-&gt;iov_base;

    /* æœ€åä¸€ä¸ªè¯·æ±‚å†…å­˜æ®µç”¨æ¥ä¿å­˜è¯·æ±‚å¤„ç†ç»“æœ */
    iov = &amp;task-&gt;iovs[task-&gt;iovcnt - 1];
    ...
    task-&gt;status = iov-&gt;iov_base;

    /* é™¤å»ä¸€å¤´ä¸€å°¾ï¼Œä¸­é—´çš„è¯·æ±‚å†…å­˜æ®µä¸ºæ•°æ®æ®µ */
    payload_len -= sizeof(*req) + sizeof(*task-&gt;status);
    task-&gt;iovcnt -= 2;

    type = req-&gt;type;
    
    switch (type) {
    case VIRTIO_BLK_T_IN:
    case VIRTIO_BLK_T_OUT:

        /*  å¯¹äºè¯»å†™è¯·æ±‚ï¼Œè°ƒç”¨bdevè¯»å†™æ¥å£ï¼Œå¹¶æ³¨å†Œè¯·æ±‚å®Œæˆåçš„å›è°ƒå‡½æ•°ä¸ºblk_request_complete_cb */
        if (type == VIRTIO_BLK_T_IN) {
            task-&gt;used_len = payload_len + sizeof(*task-&gt;status);
            rc = spdk_bdev_readv(bvdev-&gt;bdev_desc, bvdev-&gt;bdev_io_channel,
                    &amp;task-&gt;iovs[1], task-&gt;iovcnt, req-&gt;sector * 512,
                    payload_len, blk_request_complete_cb, task);
        } else if (!bvdev-&gt;readonly) {
            task-&gt;used_len = sizeof(*task-&gt;status);
            rc = spdk_bdev_writev(bvdev-&gt;bdev_desc, bvdev-&gt;bdev_io_channel,
                    &amp;task-&gt;iovs[1], task-&gt;iovcnt, req-&gt;sector * 512,
                    payload_len, blk_request_complete_cb, task);
        } else {
            SPDK_DEBUGLOG(SPDK_LOG_VHOST_BLK, "Device is in read-only mode!\n");
            rc = -1;
        }
        break;
    case VIRTIO_BLK_T_GET_ID:
        ...
        break;
    default:
        ...
        return -1;
    }   

    return 0;
}

static int
blk_iovs_setup(struct spdk_vhost_dev *vdev, struct spdk_vhost_virtqueue *vq, uint16_t req_idx,
                struct iovec *iovs, uint16_t *iovs_cnt, uint32_t *length)
{
    struct vring_desc *desc, *desc_table;
    uint16_t out_cnt = 0, cnt = 0;
    uint32_t desc_table_size, len = 0;
    int rc;

    /* ä»IOç¯descriptoræ•°ç»„ä¸­è·å–è¯·æ±‚å¯¹åº”çš„æ‰€æœ‰å†…å­˜æ®µä¿¡æ¯ï¼Œå¹¶æ˜ å°„æˆvvaåœ°å€ */
    rc = spdk_vhost_vq_get_desc(vdev, vq, req_idx, &amp;desc, &amp;desc_table, &amp;desc_table_size);
    ...

    while (1) {
        ...
        len += desc-&gt;len;

        out_cnt += spdk_vhost_vring_desc_is_wr(desc);

        rc = spdk_vhost_vring_desc_get_next(&amp;desc, desc_table, desc_table_size);
        if (rc != 0) {
            ...
            return -1;
        } else if (desc == NULL) {
            break;
        }
    }

    ...

    *length = len;
    *iovs_cnt = cnt;
    return 0;
}

int
spdk_vhost_vq_get_desc(struct spdk_vhost_dev *vdev, struct spdk_vhost_virtqueue *virtqueue,
                    uint16_t req_idx, struct vring_desc **desc, struct vring_desc **desc_table,
                    uint32_t *desc_table_size)
{
    
    *desc = &amp;virtqueue-&gt;vring.desc[req_idx];

    if (spdk_vhost_vring_desc_is_indirect(*desc)) {
        assert(spdk_vhost_dev_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC));
        *desc_table_size = (*desc)-&gt;len / sizeof(**desc);
        
        /* å°†IOç¯ä¸­è®°å½•çš„gpaåœ°å€è½¬æ¢æˆvhostçš„è™šæ‹Ÿåœ°å€ï¼Œqemuå’Œvhostä¹‹é—´çš„å†…å­˜æ˜ å°„å…³ç³»ç®¡ç†æˆ‘ä»¬å°†åœ¨ç®¡ç†é¢åˆ†ææ—¶è®¨è®º */
        *desc_table = spdk_vhost_gpa_to_vva(vdev, (*desc)-&gt;addr, sizeof(**desc) * *desc_table_size);
        *desc = *desc_table;
        if (*desc == NULL) {
            return -1;
        }

        return 0;
    }

    *desc_table = virtqueue-&gt;vring.desc;
    *desc_table_size = virtqueue-&gt;vring.size;

    return 0;
}
</code></pre></div></div>

<p>â€ƒâ€ƒæ¥ç€ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹bdevå±‚å¯¹IOè¯·æ±‚çš„å¤„ç†ï¼Œä»¥è¯»è¯·æ±‚ä¸ºä¾‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/bdev/bdev.c:

int
spdk_bdev_readv(struct spdk_bdev_desc *desc, struct spdk_io_channel *ch,
                struct iovec *iov, int iovcnt,
                uint64_t offset, uint64_t nbytes,
                spdk_bdev_io_completion_cb cb, void *cb_arg)
{
    uint64_t offset_blocks, num_blocks;

    ...
    
    /* å°†å­—èŠ‚è½¬æ¢æˆå—è¿›è¡Œå®é™…çš„IOæ“ä½œ */
    return spdk_bdev_readv_blocks(desc, ch, iov, iovcnt, offset_blocks, num_blocks, cb, cb_arg);
}

int spdk_bdev_readv_blocks(struct spdk_bdev_desc *desc, struct spdk_io_channel *ch,
                            struct iovec *iov, int iovcnt,
                            uint64_t offset_blocks, uint64_t num_blocks,
                            spdk_bdev_io_completion_cb cb, void *cb_arg)
{
    struct spdk_bdev *bdev = desc-&gt;bdev;
    struct spdk_bdev_io *bdev_io;
    struct spdk_bdev_channel *channel = spdk_io_channel_get_ctx(ch);

    /* io channelæ˜¯ä¸€ä¸ªçº¿ç¨‹å¼ºç›¸å…³å¯¹è±¡ï¼Œä¸åŒçš„çº¿ç¨‹å¯¹åº”ä¸åŒçš„channelï¼Œ
        è¿™é‡Œspdk_bdev_channelåŒ…å«ä¸€ä¸ªçº¿ç¨‹ç‹¬ç«‹çš„ç¼“å­˜æ± ï¼Œå…ˆä»ä¸­ç”³è¯·bdev_ioå†…å­˜(å…é”)ï¼Œ
        å¦‚æœç”³è¯·ä¸åˆ°ï¼Œå†åˆ°å…¨å±€çš„mempoolä¸­ç”³è¯·å†…å­˜ */
    bdev_io = spdk_bdev_get_io(channel);
    ...

    /*  å°†æ¥å£å‚æ•°è®°å½•åˆ°bdev_ioä¸­ï¼Œå¹¶ç»§ç»­é€’äº¤ */
    bdev_io-&gt;ch = channel;
    bdev_io-&gt;type = SPDK_BDEV_IO_TYPE_READ;
    bdev_io-&gt;u.bdev.iovs = iov;
    bdev_io-&gt;u.bdev.iovcnt = iovcnt;
    bdev_io-&gt;u.bdev.num_blocks = num_blocks;
    bdev_io-&gt;u.bdev.offset_blocks = offset_blocks;
    spdk_bdev_io_init(bdev_io, bdev, cb_arg, cb);

    spdk_bdev_io_submit(bdev_io);
    return 0;
}

static void
spdk_bdev_io_submit(struct spdk_bdev_io *bdev_io)
{
    struct spdk_bdev *bdev = bdev_io-&gt;bdev;

    if (bdev_io-&gt;ch-&gt;flags &amp; BDEV_CH_QOS_ENABLED) { /* å¼€å¯äº†bdevçš„qosç‰¹æ€§æ—¶èµ°è¯¥æµç¨‹ */
        ...
    } else {
        _spdk_bdev_io_submit(bdev_io); /* ç›´æ¥é€’äº¤ */
    }
}

static void
_spdk_bdev_io_submit(void *ctx)
{
    struct spdk_bdev_io *bdev_io = ctx;
    struct spdk_bdev *bdev = bdev_io-&gt;bdev;
    struct spdk_bdev_channel *bdev_ch = bdev_io-&gt;ch;
    struct spdk_io_channel *ch = bdev_ch-&gt;channel; /* åº•å±‚é©±åŠ¨å¯¹åº”çš„io channel */
    struct spdk_bdev_module_channel	*module_ch = bdev_ch-&gt;module_ch;

    bdev_io-&gt;submit_tsc = spdk_get_ticks();
    bdev_ch-&gt;io_outstanding++;
    module_ch-&gt;io_outstanding++;
    bdev_io-&gt;in_submit_request = true;
    if (spdk_likely(bdev_ch-&gt;flags == 0)) {
        if (spdk_likely(TAILQ_EMPTY(&amp;module_ch-&gt;nomem_io))) {
            /* ä¸åŒçš„é©±åŠ¨åœ¨ç”Ÿæˆbdevå¯¹è±¡æ—¶ä¼šæ³¨å†Œä¸åŒçš„fn_tableï¼Œè¿™é‡Œå°†è°ƒç”¨é©±åŠ¨æ³¨å†Œçš„submit_requestå‡½æ•° */
            bdev-&gt;fn_table-&gt;submit_request(ch, bdev_io);
        } else {
            bdev_ch-&gt;io_outstanding--;
            module_ch-&gt;io_outstanding--;
            TAILQ_INSERT_TAIL(&amp;module_ch-&gt;nomem_io, bdev_io, link);
        }
    } else if (bdev_ch-&gt;flags &amp; BDEV_CH_RESET_IN_PROGRESS) {
        ...
    } else if (bdev_ch-&gt;flags &amp; BDEV_CH_QOS_ENABLED) {
        ...
    } else {
        ...
    }
    bdev_io-&gt;in_submit_request = false;
}
</code></pre></div></div>

<p>â€ƒâ€ƒæœ€åï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹bdevçš„NVMeé©±åŠ¨çš„å¤„ç†é€»è¾‘ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/bdev/bdev_nvme.c:

static const struct spdk_bdev_fn_table nvmelib_fn_table = {
    .destruct           = bdev_nvme_destruct,
    .submit_request		= bdev_nvme_submit_request,
    .io_type_supported	= bdev_nvme_io_type_supported,
    .get_io_channel		= bdev_nvme_get_io_channel,
    .dump_info_json		= bdev_nvme_dump_info_json,
    .write_config_json	= bdev_nvme_write_config_json,
    .get_spin_time		= bdev_nvme_get_spin_time,
};

static void
bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
{
    int rc = _bdev_nvme_submit_request(ch, bdev_io);

    if (spdk_unlikely(rc != 0)) {
        if (rc == -ENOMEM) {
            spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_NOMEM);
        } else {
            spdk_bdev_io_complete(bdev_io, SPDK_BDEV_IO_STATUS_FAILED);
        }
    }
}

static int
_bdev_nvme_submit_request(struct spdk_io_channel *ch, struct spdk_bdev_io *bdev_io)
{
    /* å°†chæ‰©å±•æˆå…·ä½“çš„nvme_io_channelï¼Œå…¶å¯¹åº”ä¸€ä¸ªqueue parir */
    struct nvme_io_channel *nvme_ch = spdk_io_channel_get_ctx(ch);
    if (nvme_ch-&gt;qpair == NULL) {
        /* The device is currently resetting */
        return -1;
    }

    switch (bdev_io-&gt;type) {

    /* é’ˆå¯¹è¯»å†™è¯·æ±‚ï¼Œä¼šå°†bdev_ioæ‰©å±•æˆnvme_bdev_ioè¯·æ±‚åï¼Œå†å°†è¯·æ±‚å†…å®¹å¡«å…¥io channel
        å¯¹åº”çš„queue pairä¸­ï¼Œå¹¶é€šçŸ¥ç‰©ç†ç¡¬ä»¶å¤„ç† */
    case SPDK_BDEV_IO_TYPE_READ:
        spdk_bdev_io_get_buf(bdev_io, bdev_nvme_get_buf_cb,
                        bdev_io-&gt;u.bdev.num_blocks * bdev_io-&gt;bdev-&gt;blocklen);
        return 0;

    case SPDK_BDEV_IO_TYPE_WRITE:
        return bdev_nvme_writev((struct nvme_bdev *)bdev_io-&gt;bdev-&gt;ctxt,
                                ch,
                                (struct nvme_bdev_io *)bdev_io-&gt;driver_ctx,
                                bdev_io-&gt;u.bdev.iovs,
                                bdev_io-&gt;u.bdev.iovcnt,
                                bdev_io-&gt;u.bdev.num_blocks,
                                bdev_io-&gt;u.bdev.offset_blocks);
    ...
    default:
        return -EINVAL;
    }

    return 0;
}
</code></pre></div></div>
<p>â€ƒâ€ƒè¯¦ç»†çš„NVMeè¯·æ±‚å¤„ç†ä¸åœ¨æœ¬æ–‡çš„è®¨è®ºèŒƒå›´å†…ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥è‡ªè¡Œæ·±å…¥åˆ†æã€‚</p>

<h3 id="ioå“åº”è¿”å›æµç¨‹ä»£ç è§£æ">IOå“åº”è¿”å›æµç¨‹ä»£ç è§£æ</h3>

<p>â€ƒâ€ƒreactorçº¿ç¨‹é€šè¿‡bdev_nvme_pollå‡½æ•°è·çŸ¥å·²å®Œæˆçš„NVMeå“åº”ï¼Œæœ€ç»ˆä¼šè°ƒç”¨bdevå±‚çš„spdk_bdev_io_completeæ¥å¤„ç†å“åº”ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/bdev/bdev.c:

void
spdk_bdev_io_complete(struct spdk_bdev_io *bdev_io, enum spdk_bdev_io_status status)
{
    ...
    bdev_io-&gt;status = status;

    ...
    _spdk_bdev_io_complete(bdev_io);
}

static inline void
_spdk_bdev_io_complete(void *ctx)
{
    struct spdk_bdev_io *bdev_io = ctx;

    ...

    /* å¦‚æœè¯·æ±‚æ‰§è¡ŒæˆåŠŸï¼Œåˆ™æ›´æ–°ä¸€äº›ç»Ÿè®¡ä¿¡æ¯ */
    if (bdev_io-&gt;status == SPDK_BDEV_IO_STATUS_SUCCESS) {
        switch (bdev_io-&gt;type) {
        case SPDK_BDEV_IO_TYPE_READ:
            bdev_io-&gt;ch-&gt;stat.bytes_read += bdev_io-&gt;u.bdev.num_blocks * bdev_io-&gt;bdev-&gt;blocklen;
            bdev_io-&gt;ch-&gt;stat.num_read_ops++;
            bdev_io-&gt;ch-&gt;stat.read_latency_ticks += (spdk_get_ticks() - bdev_io-&gt;submit_tsc);
            break;
        case SPDK_BDEV_IO_TYPE_WRITE:
            bdev_io-&gt;ch-&gt;stat.bytes_written += bdev_io-&gt;u.bdev.num_blocks * bdev_io-&gt;bdev-&gt;blocklen;
            bdev_io-&gt;ch-&gt;stat.num_write_ops++;
            bdev_io-&gt;ch-&gt;stat.write_latency_ticks += (spdk_get_ticks() - bdev_io-&gt;submit_tsc);
            break;
        default:
            break;
        }
    }

    /* è°ƒç”¨ä¸Šå±‚æ³¨å†Œå›è°ƒï¼Œè¿™é‡Œå°†å›åˆ°vhost-blkçš„blk_request_complete_cb */
    bdev_io-&gt;cb(bdev_io, bdev_io-&gt;status == SPDK_BDEV_IO_STATUS_SUCCESS, bdev_io-&gt;caller_ctx);
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/vhost/vhost_blk.c:

static void
blk_request_complete_cb(struct spdk_bdev_io *bdev_io, bool success, void *cb_arg)
{
    struct spdk_vhost_blk_task *task = cb_arg;

    spdk_bdev_free_io(bdev_io); /* é‡Šæ”¾bdev_io */
    blk_request_finish(success, task);
}

static void
blk_request_finish(bool success, struct spdk_vhost_blk_task *task)
{
    *task-&gt;status = success ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR;

    /* å¾€è™šæ‹Ÿæœºä¸­æ”¾å…¥å“åº”å¹¶ä»¥è™šæ‹Ÿä¸­æ–­æ–¹å¼é€šçŸ¥è™šæ‹ŸæœºIOå®Œæˆ */
    spdk_vhost_vq_used_ring_enqueue(&amp;task-&gt;bvdev-&gt;vdev, task-&gt;vq, task-&gt;req_idx,
            task-&gt;used_len);

    /* é‡Šæ”¾å½“å‰taskï¼Œå®é™…å°±æ˜¯å°†task-&gt;usedç½®ä¸ºfalse */
    blk_task_finish(task);
}
</code></pre></div></div>

<p>â€ƒâ€ƒè‡³æ­¤ï¼Œæ•´ä¸ªIOæµç¨‹å·²ç»åˆ†æå®Œæ¯•ï¼Œå¯è§SPDKå¯¹IOçš„å¤„ç†è¿˜æ˜¯éå¸¸ç®€æ´çš„ï¼Œè¿™ä¾¿æ˜¯é«˜æ€§èƒ½çš„åŸºçŸ³ã€‚</p>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2018/05/SPDK-ioanalyze/">ã€SPDKã€‘ä¸‰ã€IOæµç¨‹ä»£ç è§£æ</a></p>
:ET