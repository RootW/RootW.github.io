I"÷Y<p>â€ƒâ€ƒæœ¬ç¯‡åšæ–‡æˆ‘ä»¬å°†æ·±å…¥åˆ†æä¸€ä¸‹å†…æ ¸æ˜¯å¦‚ä½•ä½¿ç”¨è®¡æ—¶ç¡¬ä»¶å¯¹åº”ç”¨æä¾›æœåŠ¡çš„ã€‚</p>

<h3 id="1-å†…æ ¸è¡¨ç¤ºæ—¶é—´æ•°æ®ç»“æ„">1. å†…æ ¸è¡¨ç¤ºæ—¶é—´æ•°æ®ç»“æ„</h3>

<p>â€ƒâ€ƒå†…æ ¸ä¸­å¯¹æ—¶é—´çš„è¡¨ç¤ºæœ‰å¤šç§å½¢å¼ï¼Œå¯ä»¥ä½¿ç”¨åœ¨ä¸åŒçš„åº”ç”¨åœºæ™¯ã€‚æˆ‘ä»¬åœ¨æ—¶é—´æ¦‚è¿°ä¸­çœ‹åˆ°çš„gettimeofdayçš„ç¤ºä¾‹ä¸­ï¼Œé‡‡ç”¨çš„æ•°æ®ç»“æ„æ˜¯struct timevalï¼Œå®ƒçš„å®šä¹‰å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/uapi/linux/time.h:

struct timeval {
    __kernel_time_t         tv_sec;     /* seconds */
    __kernel_suseconds_t    tv_usec;    /* microseconds */
};
</code></pre></div></div>
<p>â€ƒâ€ƒä»ä¸Šé¢çš„å®šä¹‰ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°struct timevalè®°å½•äº†å½“å‰æ—¶é—´çš„ç§’æ•°å’Œæ¯«ç§’æ•°ï¼Œç²¾åº¦å°±æ˜¯æ¯«ç§’ã€‚é‚£ä¹ˆè¿™é‡Œçš„ç§’æ•°å’Œæ¯«ç§’æ•°æ˜¯ç›¸å¯¹å“ªä¸ªæ—¶é—´ç‚¹(epoch)è€Œè¨€çš„å‘¢ï¼ŸæŒ‰ç…§UNIXç³»ç»Ÿçš„ä¹ æƒ¯ï¼Œè®°å½•æ—¶é—´çš„ç§’æ•°å’Œæ¯«ç§’æ•°æ˜¯ç›¸å¯¹1970å¹´1æœˆ1æ—¥00:00:00 +0000(UTC)è€Œè¨€çš„ã€‚å¦å¤–ï¼Œè®°å½•ç§’æ•°çš„__kernel_time_tå’Œè®°å½•æ¯«ç§’çš„__kernel_suseconds_tåœ¨64ä½ç³»ç»Ÿä¸­éƒ½æ˜¯longå‹çš„ã€‚</p>

<p>â€ƒâ€ƒé™¤äº†struct timevalï¼Œå†…æ ¸ä¸­è¿˜å®šä¹‰äº†ç²¾åº¦æ›´é«˜çš„struct timespecï¼Œå®ƒçš„ç²¾åº¦æ˜¯çº³ç§’ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/uapi/linux/time.h:

struct timespec {
    __kernel_time_t tv_sec;     /* seconds */
    long            tv_nsec;    /* nanoseconds */
};
</code></pre></div></div>

<p>â€ƒâ€ƒæ­¤å¤–ï¼Œä¸ºäº†å…¼å®¹å„ç§ç³»ç»Ÿæ¶æ„ï¼Œå†…æ ¸ä¹Ÿå®šä¹‰äº†ktime_tç±»å‹ï¼Œåœ¨64ä½æœºå™¨ä¸­å¯¹åº”longï¼Œæ—¶é—´è¡¨ç¤ºå•ä½æ˜¯çº³ç§’ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/ktime.h:

union ktime {
    s64	tv64;
#if BITS_PER_LONG != 64 &amp;&amp; !defined(CONFIG_KTIME_SCALAR)
    struct {
#ifdef __BIG_ENDIAN
        s32	sec, nsec;
#else
        s32	nsec, sec;
#endif
    } tv;
#endif
};

typedef union ktime ktime_t;
</code></pre></div></div>

<h3 id="2-å†…æ ¸æ—¶é—´ç±»åˆ«">2. å†…æ ¸æ—¶é—´ç±»åˆ«</h3>

<p>â€ƒâ€ƒæ—¶é—´æ¦‚è¿°ä¸­ç¤ºä¾‹ç¨‹åºä½¿ç”¨çš„gettimeofdayå°†è¿”å›å®æ—¶é—´(real timeï¼Œæˆ–å«å¢™ä¸Šæ—¶é—´wall time)ï¼Œä»£è¡¨ç°å®ç”Ÿæ´»ä¸­ä½¿ç”¨çš„æ—¶é—´ã€‚é™¤äº†å¢™ä¸Šæ—¶é—´ï¼Œå†…æ ¸ä¹Ÿæä¾›äº†çº¿æ€§æ—¶é—´(monotonic timeï¼Œå®ƒä¸å¯è°ƒæ•´ï¼Œéšç³»ç»Ÿè¿è¡Œçº¿æ€§å¢åŠ ï¼Œä½†ä¸åŒ…æ‹¬ä¼‘çœ æ—¶é—´)ã€å¯åŠ¨æ—¶é—´(boot timeï¼Œå®ƒä¹Ÿä¸å¯è°ƒæ•´ï¼Œå¹¶åŒ…æ‹¬äº†ä¼‘çœ æ—¶é—´)ç­‰å¤šç§æ—¶é—´ç±»å‹ï¼Œä»¥ä½¿åº”ç”¨åœ¨ä¸åŒåœºæ™¯(è·å–ä¸åŒç±»å‹æ—¶é—´çš„ç”¨æˆ·æ€æ–¹æ³•æ˜¯clock_gettime)ï¼Œä¸‹è¡¨æ±‡æ€»äº†å„ç±»æ—¶é—´çš„è¦ç´ ç‚¹ï¼š</p>

<table>
  <thead>
    <tr>
      <th>æ—¶é—´ç±»åˆ«</th>
      <th>ç²¾åº¦</th>
      <th>å¯æ‰‹åŠ¨è°ƒæ•´</th>
      <th>å—NTPè°ƒæ•´å½±å“</th>
      <th>æ—¶é—´èµ·ç‚¹</th>
      <th>å—é—°ç§’å½±å“</th>
      <th>ç³»ç»Ÿæš‚åœæ—¶æ˜¯å¦å¯å·¥ä½œ</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>REALTIME</td>
      <td>ns</td>
      <td>YES</td>
      <td>YES</td>
      <td>Linux epoch</td>
      <td>YES</td>
      <td>NO</td>
    </tr>
    <tr>
      <td>MONOTONIC</td>
      <td>ns</td>
      <td>NO</td>
      <td>YES</td>
      <td>Linux epoch</td>
      <td>YES</td>
      <td>NO</td>
    </tr>
    <tr>
      <td>MONOTONIC_RAW</td>
      <td>ns</td>
      <td>NO</td>
      <td>NO</td>
      <td>Linux epoch</td>
      <td>YES</td>
      <td>NO</td>
    </tr>
    <tr>
      <td>REALTIME_COARSE</td>
      <td>tick</td>
      <td>YES</td>
      <td>YES</td>
      <td>Linux epoch</td>
      <td>YES</td>
      <td>NO</td>
    </tr>
    <tr>
      <td>MONOTONIC_COARSE</td>
      <td>tick</td>
      <td>NO</td>
      <td>YES</td>
      <td>Linux epoch</td>
      <td>YES</td>
      <td>NO</td>
    </tr>
    <tr>
      <td>BOOTTIME</td>
      <td>ns</td>
      <td>NO</td>
      <td>YES</td>
      <td>machine start</td>
      <td>YES</td>
      <td>NO</td>
    </tr>
    <tr>
      <td>REALTIME_ALARM</td>
      <td>ns</td>
      <td>YES</td>
      <td>YES</td>
      <td>Linux epoch</td>
      <td>YES</td>
      <td>YES</td>
    </tr>
    <tr>
      <td>BOOTTIME_ALARM</td>
      <td>ns</td>
      <td>NO</td>
      <td>YES</td>
      <td>machine start</td>
      <td>YES</td>
      <td>YES</td>
    </tr>
    <tr>
      <td>TAI</td>
      <td>ns</td>
      <td>NO</td>
      <td>NO</td>
      <td>Linux epoch</td>
      <td>NO</td>
      <td>NO</td>
    </tr>
  </tbody>
</table>

<p>â€ƒâ€ƒå…³äºé—°ç§’ï¼Œæˆ‘ä»¬éœ€è¦å…ˆç†è§£ä»€ä¹ˆæ˜¯åŸå­ç§’ï¼ŸåŸå­ç§’æå‡ºçš„èƒŒæ™¯æ˜¯äººä»¬å¯¹äºâ€ç§’â€çš„ç²¾ç¡®å®šä¹‰è¿½æ±‚ã€‚å¤šé•¿æ—¶é—´å¯ä»¥ç®—ä½œ1ç§’ï¼Ÿè¿™æ˜¯ä¸€ä¸ªå¾ˆéš¾å‡†ç¡®å›ç­”çš„é—®é¢˜ã€‚ä½†æ˜¯åæ¥ç§‘å­¦å®¶å‘ç°é“¯133åŸå­åœ¨èƒ½é‡è·ƒè¿æ—¶è¾å°„çš„ç”µç£æ³¢æŒ¯è¡é¢‘ç‡éå¸¸ç¨³å®šï¼Œå› æ­¤å°±è¢«ç”¨æ¥å®šä¹‰æ—¶é—´çš„åŸºæœ¬å•ä½ï¼šç§’ï¼Œå³åŸå­ç§’ã€‚é€šè¿‡åŸå­ç§’å»¶å±•å‡ºæ¥çš„æ—¶é—´è½´å°±æ˜¯TAI(International Atomic Time)ã€‚åŸå­æ—¶é—´è™½ç„¶ç²¾å‡†ï¼Œä½†æ˜¯å¯¹äººç±»æ¥è¯´ä¸å¤ªå‹å¥½ï¼Œå®ƒå’Œä¼ ç»Ÿçš„åœ°çƒè‡ªè½¬å’Œå…¬è½¬çš„å‘¨æœŸæ€§è‡ªç„¶ç°è±¡å­˜åœ¨æ—¶é—´å·®ã€‚åœ¨è¿™æ ·çš„èƒŒæ™¯ä¸‹ï¼ŒUTC(Coordinated Universal Time)è¢«æå‡ºã€‚å®ƒä½¿ç”¨åŸå­ç§’ä½œä¸ºè®¡æ—¶å•ä½ï¼Œä½†åˆä¼šé€‚å½“è°ƒæ•´ä»¥é€‚åº”äººä»¬çš„æ—¥å¸¸ç”Ÿæ´»ã€‚è¿™ä¸ªè°ƒæ•´çš„æ—¶é—´å·®å°±æ˜¯é—°ç§’ã€‚TAIå’ŒUTCåœ¨1972è¿›è¡Œäº†æ ¡å‡†ï¼Œä¸¤è€…ç›¸å·®10ç§’ï¼Œä»æ­¤ååˆ°2017å¹´ï¼Œåˆè°ƒæ•´äº†27æ¬¡ï¼Œå› æ­¤TAIæ¯”UTCå¿«äº†37ç§’ã€‚</p>

<h3 id="3-æ·±å…¥do_gettimeofday">3. æ·±å…¥do_gettimeofday</h3>

<p>â€ƒâ€ƒç”¨æˆ·æ€gettimeofdayæ¥å£åœ¨å†…æ ¸ä¸­æ˜¯é€šè¿‡do_gettimeofdayå®ç°çš„ï¼Œä»è°ƒç”¨å±‚æ¬¡ä¸Šçœ‹ï¼Œå®ƒå¯ä»¥åˆ†ä¸ºtimekeeperå’Œclocksourceä¸¤å±‚ã€‚</p>

<h4 id="31-timekeeper"><strong>3.1 timekeeper</strong></h4>

<p>â€ƒâ€ƒtimekeeperæ˜¯å†…æ ¸ä¸­è´Ÿè´£è®¡æ—¶åŠŸèƒ½çš„æ ¸å¿ƒå¯¹è±¡ï¼Œå®ƒé€šè¿‡ä½¿ç”¨å½“å‰ç³»ç»Ÿä¸­æœ€ä¼˜çš„clocksourceæ¥æä¾›æ—¶é—´æœåŠ¡ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/time/timekeeping.c:

/**
 * do_gettimeofday - Returns the time of day in a timeval
 * @tv:		pointer to the timeval to be set
 *
 * NOTE: Users should be converted to using getnstimeofday()
 */
void do_gettimeofday(struct timeval *tv)
{
    struct timespec now;

    getnstimeofday(&amp;now); /*è·å–çº³ç§’ç²¾åº¦çš„å½“å‰æ—¶é—´*/
    tv-&gt;tv_sec = now.tv_sec;
    tv-&gt;tv_usec = now.tv_nsec/1000;
}

/**
 * __getnstimeofday - Returns the time of day in a timespec.
 * @ts:		pointer to the timespec to be set
 *
 * Updates the time of day in the timespec.
 * Returns 0 on success, or -ve when suspended (timespec will be undefined).
 */
int __getnstimeofday(struct timespec *ts)
{
    struct timekeeper *tk = &amp;timekeeper; /*ç³»ç»Ÿå…¨å±€å¯¹è±¡timekeeper*/
    unsigned long seq;
    s64 nsecs = 0;

    do {
        seq = read_seqcount_begin(&amp;timekeeper_seq); /*ä»¥é¡ºåºé”æ¥åŒæ­¥å„ä¸ªä»»åŠ¡å¯¹timekeeperçš„è¯»å†™æ“ä½œ*/

        ts-&gt;tv_sec = tk-&gt;xtime_sec; /*è·å–æœ€è¿‘æ›´æ–°çš„å¢™ä¸Šæ—¶é—´çš„ç§’æ•°(å¢™ä¸Šæ—¶é—´ä¼šå‘¨æœŸæ€§åœ°è¢«æ›´æ–°ï¼Œå°†åœ¨å®šæ—¶åŸç†éƒ¨åˆ†è®¨è®º)*/
        nsecs = timekeeping_get_ns(tk); /*è·å–å½“å‰å¢™ä¸Šæ—¶é—´ç›¸å¯¹(tk-&gt;xtime_sec, 0)çš„çº³ç§’æ—¶é—´é—´éš”*/

    } while (read_seqcount_retry(&amp;timekeeper_seq, seq));

    ts-&gt;tv_nsec = 0;
    timespec_add_ns(ts, nsecs);/*ç´¯åŠ å‰é¢è·å–çš„çº³ç§’æ—¶é—´é—´éš”ä»¥å¾—åˆ°æ­£ç¡®çš„å½“å‰å¢™ä¸Šæ—¶é—´ï¼›æœ‰å¯èƒ½å¯¼è‡´ç§’æ•°è¿›ä½*/

    ...
    return 0;
}

static inline s64 timekeeping_get_ns(struct timekeeper *tk)
{
    cycle_t cycle_now, cycle_delta;
    struct clocksource *clock;
    s64 nsec;

    /*é€šè¿‡å½“å‰æœ€ä¼˜clocksourceè·å–å½“å‰æ—¶é—´è®¡æ•°cycleï¼›ä¸åŒçš„clocksourceå¯ä»¥æä¾›ä¸åŒçš„readå®ç°*/
    /* read clocksource: */
    clock = tk-&gt;clock;
    cycle_now = clock-&gt;read(clock);
    
    /*é€šè¿‡clocksourceä¸­çš„å½“å‰è®¡æ•°å€¼ä¸æœ€è¿‘ä¸€æ¬¡æ›´æ–°å¢™ä¸Šæ—¶é—´æ—¶è·å–çš„å€¼çš„å·®å€¼æ¥è®¡ç®—æ—¶é—´é—´éš”*/

    /* calculate the delta since the last update_wall_time: */    
    cycle_delta = (cycle_now - clock-&gt;cycle_last) &amp; clock-&gt;mask;

    /*tk-&gt;multå’Œtk-&gt;shiftæ˜¯ç”¨æ¥è¿›è¡Œå°†cycleæ•°å€¼è½¬æˆçº³ç§’çš„è½¬æ¢å‚æ•°ï¼Œå‚è§clocksourceä¸­çš„è¯´æ˜*/
    nsec = cycle_delta * tk-&gt;mult + tk-&gt;xtime_nsec; /*tk-&gt;xtime_nsecæ˜¯æœ€è¿‘æ›´æ–°çš„å¢™ä¸Šæ—¶é—´çš„ç§’çº³æ•°å·¦ç§»tk-&gt;shiftåçš„å€¼*/
    nsec &gt;&gt;= tk-&gt;shift;

    /* If arch requires, add in get_arch_timeoffset() */
    return nsec + get_arch_timeoffset();
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/timekeeper_internal.h:

/* Structure holding internal timekeeping values. */
struct timekeeper {
    /* Current clocksource used for timekeeping. */
    struct clocksource	*clock;
    /* NTP adjusted clock multiplier */
    u32			mult;
    /* The shift value of the current clocksource. */
    u32			shift;
    /* Number of clock cycles in one NTP interval. */
    cycle_t			cycle_interval;
    /* Last cycle value (also stored in clock-&gt;cycle_last) */
    cycle_t			cycle_last;
    /* Number of clock shifted nano seconds in one NTP interval. */
    u64			xtime_interval;
    /* shifted nano seconds left over when rounding cycle_interval */
    s64			xtime_remainder;
    /* Raw nano seconds accumulated per NTP interval. */
    u32			raw_interval;

    /* Current CLOCK_REALTIME time in seconds */
    u64			xtime_sec;
    /* Clock shifted nano seconds */
    u64			xtime_nsec;

    /* Difference between accumulated time and NTP time in ntp
     * shifted nano seconds. */
    s64			ntp_error;
    /* Shift conversion between clock shifted nano seconds and
     * ntp shifted nano seconds. */
    u32			ntp_error_shift;

    /*
     * wall_to_monotonic is what we need to add to xtime (or xtime corrected
     * for sub jiffie times) to get to monotonic time.  Monotonic is pegged
     * at zero at system boot time, so wall_to_monotonic will be negative,
     * however, we will ALWAYS keep the tv_nsec part positive so we can use
     * the usual normalization.
     *
     * wall_to_monotonic is moved after resume from suspend for the
     * monotonic time not to jump. We need to add total_sleep_time to
     * wall_to_monotonic to get the real boot based time offset.
     *
     * - wall_to_monotonic is no longer the boot time, getboottime must be
     * used instead.
     */
    struct timespec		wall_to_monotonic;
    /* Offset clock monotonic -&gt; clock realtime */
    ktime_t			offs_real;
    /* time spent in suspend */
    struct timespec		total_sleep_time;
    /* Offset clock monotonic -&gt; clock boottime */
    ktime_t			offs_boot;
    /* The raw monotonic time for the CLOCK_MONOTONIC_RAW posix clock. */
    struct timespec		raw_time;
    /* The current UTC to TAI offset in seconds */
    s32			tai_offset;
    /* Offset clock monotonic -&gt; clock tai */
    ktime_t			offs_tai;

};
</code></pre></div></div>

<h4 id="32-clocksource"><strong>3.2 clocksource</strong></h4>

<p>â€ƒâ€ƒå†…æ ¸é€šè¿‡clocksourceå¯¹è±¡æ¥æè¿°ç‰©ç†è®¡æ—¶è®¾å¤‡ï¼Œx86æ¶æ„ä¸‹æœ€å¸¸è§çš„è®¡æ—¶è®¾å¤‡æ˜¯tscï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹tscå¯¹åº”çš„clocksource:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/arch/x86/kernel/tsc.c:

static struct clocksource clocksource_tsc = {
    .name                   = "tsc",
    .rating                 = 300,
    .read                   = read_tsc,
    .resume                 = resume_tsc,
    .mask                   = CLOCKSOURCE_MASK(64),
    .flags                  = CLOCK_SOURCE_IS_CONTINUOUS |
                              CLOCK_SOURCE_MUST_VERIFY,
};
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/include/linux/clocksource.h:

/**
 * struct clocksource - hardware abstraction for a free running counter
 *	Provides mostly state-free accessors to the underlying hardware.
 *	This is the structure used for system time.
 *
 * @name:		ptr to clocksource name
 * @list:		list head for registration
 * @rating:		rating value for selection (higher is better)
 *			To avoid rating inflation the following
 *			list should give you a guide as to how
 *			to assign your clocksource a rating
 *			1-99: Unfit for real use
 *				Only available for bootup and testing purposes.
 *			100-199: Base level usability.
 *				Functional for real use, but not desired.
 *			200-299: Good.
 *				A correct and usable clocksource.
 *			300-399: Desired.
 *				A reasonably fast and accurate clocksource.
 *			400-499: Perfect
 *				The ideal clocksource. A must-use where
 *				available.
 * @read:		returns a cycle value, passes clocksource as argument
 * @enable:		optional function to enable the clocksource
 * @disable:		optional function to disable the clocksource
 * @mask:		bitmask for two's complement
 *			subtraction of non 64 bit counters
 * @mult:		cycle to nanosecond multiplier
 * @shift:		cycle to nanosecond divisor (power of two)
 * @max_idle_ns:	max idle time permitted by the clocksource (nsecs)
 * @maxadj:		maximum adjustment value to mult (~11%)
 * @flags:		flags describing special properties
 * @archdata:		arch-specific data
 * @suspend:		suspend function for the clocksource, if necessary
 * @resume:		resume function for the clocksource, if necessary
 * @cycle_last:		most recent cycle counter value seen by ::read()
 */
struct clocksource {
    /*
     * Hotpath data, fits in a single cache line when the
     * clocksource itself is cacheline aligned.
     */
    cycle_t (*read)(struct clocksource *cs);
    cycle_t cycle_last;
    cycle_t mask;
    u32 mult;
    u32 shift;
    u64 max_idle_ns;
    u32 maxadj;
#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
    struct arch_clocksource_data archdata;
#endif

    const char *name;
    struct list_head list;
    int rating;
    int (*enable)(struct clocksource *cs);
    void (*disable)(struct clocksource *cs);
        unsigned long flags;
    void (*suspend)(struct clocksource *cs);
    void (*resume)(struct clocksource *cs);

    /* private: */
#ifdef CONFIG_CLOCKSOURCE_WATCHDOG
    /* Watchdog related data, used by the framework */
    struct list_head wd_list;
    cycle_t cs_last;
    cycle_t wd_last;
#endif
} ____cacheline_aligned;
</code></pre></div></div>

<p>â€ƒâ€ƒä¸Šé¢ä»£ç çš„æ³¨é‡Šéƒ¨åˆ†å·²ç»æ¸…æ¥šåœ°è§£æäº†tscæ˜¯ä¸€ç§ç²¾åº¦è‰¯å¥½çš„clocksourceï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨read_tsc(æœ¬è´¨æ˜¯é€šè¿‡rdtscæŒ‡ä»¤)æ¥è·å–å½“å‰tscè®¡æ•°å€¼ã€‚cycle_lastè¡¨ç¤ºæœ€è¿‘ä¸€æ¬¡ä»clocksourceä¸­è·å–çš„cycleè®¡æ•°å€¼ï¼›maskè¡¨ç¤ºå½“å‰clocksourceä¸­è®¡æ•°å™¨çš„æœ‰æ•ˆä½æ•°ï¼›multå’Œshiftç”¨æ¥è®¡ç®—ä»cycleåˆ°çº³ç§’çš„è½¬æ¢ï¼›max_idle_nsè¡¨ç¤ºå½“å‰clocksourceå…è®¸çš„æœ€é•¿æ—¶é—´æ›´æ–°é—´éš”ï¼Œå› ä¸ºå¦‚æœCPUé•¿æœŸä¸æ›´æ–°æ—¶é—´ï¼Œå°†ä¼šå¯¼è‡´å†æ¬¡è·å–åˆ°çš„cycleè®¡æ•°å€¼è¿‡å¤§ï¼Œä½¿å¾—è½¬æ¢æˆçº³ç§’æ—¶å‘ç”Ÿæº¢å‡ºé”™è¯¯ã€‚ä»ç†è®ºè®¡ç®—ä¸Šè¯´ï¼Œå°†cycleè½¬æ¢æˆçº³ç§’çš„å…¬å¼æ˜¯â€cycle * æ¯ç§’çº³ç§’æ•° / é¢‘ç‡â€ï¼Œä½†æ˜¯ç”±äºå†…æ ¸æ— æ³•è¿›è¡Œæµ®ç‚¹è¿ç®—ï¼Œåªèƒ½é€šè¿‡ä¸€ç§å˜é€šçš„æ–¹æ³•æ¥è®¡ç®—ï¼Œå³â€cycle * multÂ Â» shiftâ€ï¼Œè¿™é‡Œçš„multå’Œshifå°±æ˜¯åŸºäºé¢‘ç‡ã€è®¡ç®—ç²¾åº¦å’Œæœ€å¤§è¡¨ç¤ºèŒƒå›´è®¡ç®—è€Œå¾—çš„ã€‚</p>

<h3 id="4-è®¡æ—¶åˆå§‹åŒ–">4. è®¡æ—¶åˆå§‹åŒ–</h3>

<p>â€ƒâ€ƒæœ€åæˆ‘ä»¬å†æ¥çœ‹çœ‹å†…æ ¸è®¡æ—¶åŠŸèƒ½çš„åˆå§‹åŒ–è¿‡ç¨‹ï¼Œäº†è§£ä¸€ä¸‹è®¡æ—¶åŠŸèƒ½æ˜¯å¦‚ä½•ä¸€æ­¥æ­¥ç”Ÿæ•ˆçš„ã€‚timekeeperçš„åˆå§‹åŒ–æ˜¯åœ¨å†…æ ¸å¯åŠ¨è¿‡ç¨‹start_kernelä¸­è°ƒç”¨timekeeping_initè¿›è¡Œï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/time/timekeeping.c:

/*
 * timekeeping_init - Initializes the clocksource and common timekeeping values
 */
void __init timekeeping_init(void)
{
    struct timekeeper *tk = &amp;timekeeper;
    struct clocksource *clock;
    unsigned long flags;
    struct timespec now, boot, tmp;

    /*x86æ¶æ„ä¸‹ï¼Œpersistent clockä¸ºç³»ç»ŸRTCæ—¶é’Ÿæºï¼Œæˆ‘ä»¬å…ˆä»ä¸­è·å–å½“å‰æ—¶é—´ï¼Œç²¾åº¦ä¸ºç§’*/
    read_persistent_clock(&amp;now);

    if (!timespec_valid_strict(&amp;now)) {
        pr_warn("WARNING: Persistent clock returned invalid value!\n"
                "         Check your CMOS/BIOS settings.\n");
        now.tv_sec = 0;
        now.tv_nsec = 0;
    } else if (now.tv_sec || now.tv_nsec)
        persistent_clock_exist = true;

    /*x86æ¶æ„ä¸‹ï¼Œæ²¡æœ‰boot clockï¼Œæ‰€ä»¥boot timeä¸º0*/
    read_boot_clock(&amp;boot);
    if (!timespec_valid_strict(&amp;boot)) {
        pr_warn("WARNING: Boot clock returned invalid value!\n"
                "         Check your CMOS/BIOS settings.\n");
        boot.tv_sec = 0;
        boot.tv_nsec = 0;
    }

    raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);
    write_seqcount_begin(&amp;timekeeper_seq);
    ntp_init();

    /*è·å–ç³»ç»Ÿé»˜è®¤æ—¶é’Ÿæºï¼Œx86æ¶æ„ä¸­å³ä¸ºjiffies*/
    clock = clocksource_default_clock();
    if (clock-&gt;enable)
    clock-&gt;enable(clock);
    /*å°†jiffyè®¾å¤‡timekeeperä¸­çš„æ—¶é’Ÿæºå¹¶è®¾å®šå†…éƒ¨ç›¸å…³å˜é‡*/
    tk_setup_internals(tk, clock);

    /*å°†å½“å‰æ—¶é—´è®¾å®šä¸ºtkçš„å¢™ä¸Šæ—¶é—´ï¼Œæ³¨å…¶ä¸­tk-&gt;xtime_secä¸ºå½“å‰ç§’æ•°ï¼Œtk-&gt;xtime_nsecä¸ºçº³ç§’å·¦ç§»shiftä½åçš„å€¼*/
    tk_set_xtime(tk, &amp;now);
    /*raw_timeè®¾ä¸º0*/
    tk-&gt;raw_time.tv_sec = 0;
    tk-&gt;raw_time.tv_nsec = 0;
    /*boot timeè®¾ä¸ºå¢™ä¸Šæ—¶é—´*/
    if (boot.tv_sec == 0 &amp;&amp; boot.tv_nsec == 0)
        boot = tk_xtime(tk);

    /*å°†monotonic timeå‡å»wall timeçš„æ—¶é—´åç§»è®°å½•ä¸‹æ¥*/
    set_normalized_timespec(&amp;tmp, -boot.tv_sec, -boot.tv_nsec);
    tk_set_wall_to_mono(tk, tmp);

    /*å°†sleep timeåˆå§‹åŒ–ä¸ºé›¶*/
    tmp.tv_sec = 0;
    tmp.tv_nsec = 0;
    tk_set_sleep_time(tk, tmp);

    /*å¤‡ä»½å½“å‰timekeeper*/
    memcpy(&amp;shadow_timekeeper, &amp;timekeeper, sizeof(timekeeper));

    write_seqcount_end(&amp;timekeeper_seq);
    raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);
}
</code></pre></div></div>

<p>â€ƒâ€ƒå†…æ ¸jiffieså˜é‡ä»£è¡¨æ—¶é—´æ»´ç­”ï¼Œæ˜¯å¯¹åŒæœŸæ€§tickäº‹ä»¶çš„è®°æ•°ï¼Œå› æ­¤å¯ä»¥å°†å®ƒè§†ä¸ºä¸€ä¸ªæœ€ä¸ºç®€å•çš„æ—¶é’Ÿæºã€‚å®ƒå’Œä¸€èˆ¬æ—¶é’Ÿæºçš„ä¸åŒä¹‹å¤„åœ¨äºå®ƒæ²¡æœ‰å®é™…çš„è®¡æ—¶è®¾å¤‡ä¸ä¹‹å¯¹åº”ï¼Œå®Œå…¨æ˜¯è®°å½•åœ¨è®¡ç®—æœºå†…å­˜ä¸­ï¼›å¦å¤–å®ƒçš„ç²¾åº¦å’Œç³»ç»Ÿtickæ•°ç›¸å…³ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/time/jiffies.c:

struct clocksource * __init __weak clocksource_default_clock(void)
{
    return &amp;clocksource_jiffies;
}

static struct clocksource clocksource_jiffies = {
    .name		= "jiffies",
    .rating		= 1, /* lowest valid rating*/
    .read		= jiffies_read,
    .mask		= 0xffffffff, /*32bits*/
    .mult		= NSEC_PER_JIFFY &lt;&lt; JIFFIES_SHIFT, /* details above */
    .shift		= JIFFIES_SHIFT,
};

static cycle_t jiffies_read(struct clocksource *cs)
{
    return (cycle_t) jiffies;
}
</code></pre></div></div>

<p>â€ƒâ€ƒå¯¹äºtscæ—¶é’Ÿæºï¼Œåœ¨å†…æ ¸å¯¹æ¨¡å—è¿›è¡Œåˆå§‹åŒ–æ—¶ï¼Œä¼šæ³¨å†Œtscæ—¶é’Ÿï¼Œå¹¶é€šçŸ¥timekeeperå°†æ—¶é’Ÿæºä»jiffiesåˆ‡æ¢åˆ°tsc:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static int __init init_tsc_clocksource(void)
{
    ...
    if (boot_cpu_has(X86_FEATURE_TSC_RELIABLE)) {
        /*æ³¨å†Œä¸€ä¸ªé¢‘ç‡ä¸ºtsc_khzçš„æ—¶é’Ÿæºï¼Œæœ€ç»ˆè°ƒç”¨__clocksource_register_scaleå®ç°*/
        clocksource_register_khz(&amp;clocksource_tsc, tsc_khz);
    return 0;
    }
    ...
}
/*
 * We use device_initcall here, to ensure we run after the hpet
 * is fully initialized, which may occur at fs_initcall time.
 */
device_initcall(init_tsc_clocksource);
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/time/clocksource.c:

/**
 * __clocksource_register_scale - Used to install new clocksources
 * @cs:		clocksource to be registered
 * @scale:	Scale factor multiplied against freq to get clocksource hz
 * @freq:	clocksource frequency (cycles per second) divided by scale
 *
 * Returns -EBUSY if registration fails, zero otherwise.
 *
 * This *SHOULD NOT* be called directly! Please use the
 * clocksource_register_hz() or clocksource_register_khz helper functions.
 */
int __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)
{

    /*é¦–å…ˆæ ¹æ®æ—¶é’Ÿæºçš„é¢‘ç‡è®¡ç®—åˆé€‚çš„multå’Œshiftï¼Œä»¥åŠæœ€å¤§æ›´æ–°å»¶æ—¶max_idle_ns*/
    /* Initialize mult/shift and max_idle_ns */
    __clocksource_updatefreq_scale(cs, scale, freq);

    /* Add clocksource to the clcoksource list */
    mutex_lock(&amp;clocksource_mutex);
    clocksource_enqueue(cs); /*åŠ å…¥åˆ°å…¨å±€clocksource_list*/
    clocksource_enqueue_watchdog(cs); /*åŠ å…¥åˆ°æ—¶é’Ÿæºç›‘æ§ä¸­ï¼Œå¦‚æœå‘ç°å½“å‰æ—¶é’Ÿæºç²¾åº¦ä¸‹é™ä¼šé‡æ–°é€‰æ‹©æ›´ä¼˜çš„æ—¶é’Ÿæº*/
    clocksource_select(); /*é€‰æ‹©æœ€ä¼˜çš„æ—¶é’Ÿæºï¼Œå†…éƒ¨ä¼šè°ƒç”¨timekeeping_notifyé€šçŸ¥timerkeeper*/
    mutex_unlock(&amp;clocksource_mutex);
    return 0;
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux/kernel/time/timekeeping.c:

/**
* timekeeping_notify - Install a new clock source
* @clock:		pointer to the clock source
*
* This function is called from clocksource.c after a new, better clock
* source has been registered. The caller holds the clocksource_mutex.
*/
void timekeeping_notify(struct clocksource *clock)
{
    struct timekeeper *tk = &amp;timekeeper;

    if (tk-&gt;clock == clock)
        return;
    /*æ³¨æ„ï¼Œè¿™é‡Œä¼šæš‚åœæ‰€æœ‰CPUçš„è¿è¡Œï¼Œå¹¶é€‰å®šä¸€ä¸ªé»˜è®¤çš„CPU(0å·æ ¸)æ‰§è¡Œchange_clocksourceã€‚
      è¿™æ˜¯å› ä¸ºæ—¶é’Ÿæºæ˜¯è®¡æ—¶çš„åŸºç¡€ï¼Œåœ¨è¿›è¡Œæ—¶é’Ÿæºåˆ‡æ¢æ—¶ç³»ç»Ÿå°†æ— æ³•æä¾›æ­£ç¡®çš„æ—¶é—´æœåŠ¡ã€‚åªæœ‰å½“åˆ‡æ¢
      å®Œæˆåç³»ç»Ÿæ‰å¯æ¢å¤è¿è¡Œã€‚*/
    stop_machine(change_clocksource, clock, NULL);
    tick_clock_notify();
}

/**
 * change_clocksource - Swaps clocksources if a new one is available
 *
 * Accumulates current time interval and initializes new clocksource
 */
static int change_clocksource(void *data)
{
    struct timekeeper *tk = &amp;timekeeper;
    struct clocksource *new, *old;
    unsigned long flags;

    new = (struct clocksource *) data;

    raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);
    write_seqcount_begin(&amp;timekeeper_seq);

    timekeeping_forward_now(tk);
    if (!new-&gt;enable || new-&gt;enable(new) == 0) {
        old = tk-&gt;clock;
        tk_setup_internals(tk, new);
        if (old-&gt;disable)
            old-&gt;disable(old);
    }
    timekeeping_update(tk, true, true);

    write_seqcount_end(&amp;timekeeper_seq);
    raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);

    return 0;
}
</code></pre></div></div>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2018/01/è®¡æ—¶/">ã€æ—¶é—´å­ç³»ç»Ÿã€‘äºŒã€è®¡æ—¶åŸç†ï¼timekeeperä¸clocksource</a></p>
:ET