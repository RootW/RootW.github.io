I"¸/<p>â€ƒâ€ƒreactorçº¿ç¨‹æ˜¯SPDKä¸­è´Ÿè´£å®é™…ä¸šåŠ¡å¤„ç†é€»è¾‘çš„å•å…ƒï¼Œå®ƒä»¬åœ¨vhsotæœåŠ¡å¯åŠ¨æ—¶åˆ›å»ºï¼Œç›´åˆ°æœåŠ¡åœæ­¢ã€‚ç›®å‰è¿˜ä¸æ”¯æŒreactorçº¿ç¨‹çš„åŠ¨æ€å¢å‡ã€‚</p>

<h3 id="reactorçº¿ç¨‹æ€»æµç¨‹">reactorçº¿ç¨‹æ€»æµç¨‹</h3>

<p>â€ƒâ€ƒæˆ‘ä»¬é¡ºç€vhostè¿›ç¨‹çš„ä»£ç æ‰§è¡Œé¡ºåºæ¥çœ‹çœ‹æ€»ä½“æµç¨‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/app/vhost/vhost.c:

int
main(int argc, char *argv[])
{
    struct spdk_app_opts opts = {};
    int rc;

    /* é¦–å…ˆè¿›è¡Œå‚æ•°è§£æï¼Œè§£æåçš„ç»“æœä¿å­˜äºoptsä¸­ */

    vhost_app_opts_init(&amp;opts);

    if ((rc = spdk_app_parse_args(argc, argv, &amp;opts, "f:S:",
        vhost_parse_arg, vhost_usage)) !=
        SPDK_APP_PARSE_ARGS_SUCCESS) {
        exit(rc);
    }

    ...

    /* æ¥ç€æ ¹æ®é…ç½®æ–‡ä»¶æŒ‡æ˜çš„ç‰©ç†æ ¸å¯åŠ¨reactorsçº¿ç¨‹(ä¸»çº¿ç¨‹æœ€ç»ˆä¹Ÿæˆä¸ºä¸€ä¸ªreactor)ã€‚
        è¿™äº›reactorsçº¿ç¨‹ä¼šæ‰§è¡Œè½®å¾ªå‡½æ•°ï¼Œç›´åˆ°å¤–éƒ¨å°†æœåŠ¡çŠ¶æ€ç½®ä¸ºé€€å‡º */

    /* Blocks until the application is exiting */
    rc = spdk_app_start(&amp;opts, vhost_started, NULL, NULL);

    /* æ‰€æœ‰reactorçº¿ç¨‹é€€å‡ºåï¼Œè¿›è¡Œèµ„æºæ¸…ç† */
    spdk_app_fini();

    return rc;
}
</code></pre></div></div>

<p>â€ƒâ€ƒä¸Šè¿°æ•´ä½“æµç¨‹ä¸­æœ€ä¸ºé‡è¦çš„ä¾¿æ˜¯spdk_app_startå‡½æ•°ï¼Œè¯¥å‡½æ•°å†…éƒ¨è°ƒç”¨äº†DPDKå…³äºç³»ç»ŸCPUã€å†…å­˜ã€PCIè®¾å¤‡ç®¡ç†ç­‰é€šç”¨æ€§æœåŠ¡ä»£ç ï¼Œè¿™é‡Œæˆ‘ä»¬å°½å¯èƒ½ä»¥ç†è§£å…¶åŠŸèƒ½ä¸ºä¸»è€Œä¸åšæ·±å…¥çš„ä»£ç åˆ†æï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/event/app.c:

int
spdk_app_start(struct spdk_app_opts *opts, spdk_event_fn start_fn,
void *arg1, void *arg2)
{
    struct spdk_conf	*config = NULL;
    int			rc;
    struct spdk_event	*app_start_event;

    ...

    /* å°†é…ç½®æ–‡ä»¶ä¸­çš„å†…å®¹å¯¼å…¥åˆ°configå¯¹è±¡ä¸­ */
    config = spdk_app_setup_conf(opts-&gt;config_file);
    ...
    spdk_app_read_config_file_global_params(opts);

    ...

    /* è°ƒç”¨DPDKç³»ç»ŸæœåŠ¡ï¼š
        (1)é€šè¿‡å†…æ ¸sysfsè·å–ç‰©ç†CPUä¿¡æ¯ï¼Œå¹¶é€šè¿‡é…ç½®æ–‡ä»¶æŒ‡å®šçš„è¿è¡Œæ ¸ï¼Œåœ¨å„ä¸ªæ ¸ä¸Šå¯åŠ¨æœåŠ¡çº¿ç¨‹ï¼›
        å„æœåŠ¡çº¿ç¨‹å¯åŠ¨åå› ä¸ºåœ¨ç­‰å¾…ä¸»çº¿ç¨‹ç»™å®ƒä»¬å‘é€éœ€è¦æ‰§è¡Œçš„ä»»åŠ¡è€Œå¤„äºç¡çœ çŠ¶æ€ï¼›
        (2)åŸºäºå¤§é¡µå†…å­˜åˆ›å»ºå†…å­˜æ± ä»¥ä¾›å…¶å®ƒæ¨¡å—ä½¿ç”¨ï¼›
        (3)åˆå§‹åŒ–PCIè®¾å¤‡æšä¸¾æœåŠ¡ï¼Œå¯ä»¥å®ç°ç±»ä¼¼å†…æ ¸çš„è®¾å¤‡å‘ç°åŠé©±åŠ¨åˆå§‹åŒ–æµç¨‹ã€‚SPDKåŸºäºæ­¤å¹¶å€Ÿ
        åŠ©å†…æ ¸uioæˆ–vfioé©±åŠ¨å®ç°å…¨ç”¨æˆ·æ€çš„PCIé©±åŠ¨ */
     /* å®ŒæˆDPDKçš„åˆå§‹åŒ–åï¼ŒSPDKä¼šå»ºç«‹ä¸€å¼ ç”±vva(vhost virtual address)åˆ°pa(physical address)
        çš„å†…å­˜æ˜ å°„è¡¨g_vtophys_mapã€‚æ¯å½“æœ‰æ–°çš„å†…å­˜æ˜ å°„åˆ°vhostä¸­æ—¶ï¼Œéƒ½éœ€è¦è°ƒç”¨spdk_mem_registeråœ¨è¯¥
        è¡¨ä¸­æ³¨å†Œæ–°çš„æ˜ å°„å…³ç³»ã€‚è®¾è®¡è¯¥è¡¨çš„åŸå› æ˜¯å½“SPDKå‘ç‰©ç†è®¾å¤‡å‘é€DMAè¯·æ±‚æ—¶ï¼Œéœ€è¦å‘è®¾å¤‡æä¾›paè€Œévva */
    if (spdk_app_setup_env(opts) &lt; 0) {
        ...
    }

    /* è¿™é‡Œä¸ºreactorsåˆ†é…ç›¸åº”çš„å†…å­˜ */
    /*
     * If mask not specified on command line or in configuration file,
     *  reactor_mask will be 0x1 which will enable core 0 to run one
     *  reactor.
     */
    if ((rc = spdk_reactors_init(opts-&gt;max_delay_us)) != 0) {
        ...
    }

    ...

    /* è®¾ç½®ä¸€äº›å…¨å±€å˜é‡ */
    memset(&amp;g_spdk_app, 0, sizeof(g_spdk_app));
    g_spdk_app.config = config;
    g_spdk_app.shm_id = opts-&gt;shm_id;
    g_spdk_app.shutdown_cb = opts-&gt;shutdown_cb;
    g_spdk_app.rc = 0;
    g_init_lcore = spdk_env_get_current_core();
    g_app_start_fn = start_fn;
    g_app_start_arg1 = arg1;
    g_app_start_arg2 = arg2;
    app_start_event = spdk_event_allocate(g_init_lcore, start_rpc, (void *)opts-&gt;rpc_addr, NULL);

    /* åˆå§‹åŒ–SPDKçš„å„ä¸ªå­ç³»ç»Ÿï¼Œå¦‚bdevã€vhostå‡ä¸ºå­ç³»ç»Ÿã€‚ä½†è¿™é‡Œéœ€æ³¨æ„ä¸€ç‚¹ï¼Œæ­¤å¤„ä»…æ˜¯äº§ç”Ÿäº†ä¸€ä¸ªåˆå§‹åŒ–äº‹ä»¶ï¼Œäº‹ä»¶çš„å¤„ç†è¦åœ¨
        reactorçº¿ç¨‹æ­£å¼è¿›å…¥è½®å¾ªå‡½æ•°åæ‰å¼€å§‹ */
    spdk_subsystem_init(app_start_event);

    /* ä»æ­¤å¤„å¼€å§‹ï¼Œå„ä¸ªçº¿ç¨‹(åŒ…æ‹¬ä¸»çº¿ç¨‹)å¼€å§‹æ‰§è¡Œ_spdk_reactor_runï¼Œçº¿ç¨‹åä¹Ÿæ­£å¼å˜æ›´ä¸ºreactor_Xï¼›
        ç›´åˆ°æ‰€æœ‰çº¿ç¨‹å‡é€€å‡º_spdk_reactor_runåï¼Œä¸»çº¿ç¨‹æ‰ä¼šè¿”å› */
    /* This blocks until spdk_app_stop is called */
    spdk_reactors_start();

    return g_spdk_app.rc;
    ...    
}
</code></pre></div></div>

<p>â€ƒâ€ƒå†çœ‹ä¸€ä¸‹spdk_reactors_startï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/event/reactor.c:

void
spdk_reactors_start(void)
{
    struct spdk_reactor *reactor;
    uint32_t i, current_core;
    int rc;

    g_reactor_state = SPDK_REACTOR_STATE_RUNNING;
    g_spdk_app_core_mask = spdk_cpuset_alloc();

    /* é’ˆå¯¹ä¸»çº¿ç¨‹ä¹‹å¤–çš„å…¶å®ƒæ ¸ä¸Šçš„çº¿ç¨‹ï¼Œé€šè¿‡å‘é€é€šçŸ¥ä½¿å®ƒä»¬å¼€å§‹æ‰§è¡Œ_spdk_reactor_run */
    current_core = spdk_env_get_current_core();
    SPDK_ENV_FOREACH_CORE(i) {
        if (i != current_core) {
            reactor = spdk_reactor_get(i);
            rc = spdk_env_thread_launch_pinned(reactor-&gt;lcore, _spdk_reactor_run, reactor);
            ...
        }
        spdk_cpuset_set_cpu(g_spdk_app_core_mask, i, true);
    }

    /* ä¸»çº¿ç¨‹ä¹Ÿä¼šæ‰§è¡Œ_spdk_reactor_run */
    /* Start the master reactor */
    reactor = spdk_reactor_get(current_core);
    _spdk_reactor_run(reactor);

    /* ä¸»çº¿ç¨‹é€€å‡ºåä¼šç­‰å¾…å…¶å®ƒæ ¸ä¸Šçš„çº¿ç¨‹å‡é€€å‡º */
    spdk_env_thread_wait_all();

    /* æ‰§è¡Œåˆ°æ­¤å¤„ï¼Œè¯´æ˜vhostæœåŠ¡è¿›ç¨‹å³å°†é€€å‡º */
    g_reactor_state = SPDK_REACTOR_STATE_SHUTDOWN;
    spdk_cpuset_free(g_spdk_app_core_mask);
    g_spdk_app_core_mask = NULL;
}
</code></pre></div></div>

<h3 id="è½®å¾ªå‡½æ•°_spdk_reactor_run">è½®å¾ªå‡½æ•°_spdk_reactor_run</h3>

<p>â€ƒâ€ƒé€šè¿‡å¯¹vhostä»£ç æµç¨‹çš„åˆ†æï¼Œæˆ‘ä»¬çœ‹åˆ°vhostä¸­æ‰€æœ‰çº¿ç¨‹æœ€ç»ˆéƒ½ä¼šè°ƒç”¨_spdk_reactor_runï¼Œè¯¥å‡½æ•°æ˜¯ä¸€ä¸ªæ­»å¾ªç¯ï¼Œç”±æ­¤å®ç°è½®å¾ªé€»è¾‘ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/event/reactor.c:

static int
_spdk_reactor_run(void *arg)
{
    struct spdk_reactor	*reactor = arg;
    struct spdk_poller	*poller;
    uint32_t		event_count;
    uint64_t		idle_started, now;
    uint64_t		spin_cycles, sleep_cycles;
    uint32_t		sleep_us;
    uint32_t		timer_poll_count;
    char			thread_name[32];

    /* é‡æ–°å‘½åçº¿ç¨‹åï¼Œreactor_[æ ¸å·] */
    snprintf(thread_name, sizeof(thread_name), "reactor_%u", reactor-&gt;lcore);

    /* åˆ›å»ºSPDKçº¿ç¨‹å¯¹è±¡ï¼š
        (1)çº¿ç¨‹é—´é€šè¿‡_spdk_reactor_send_msgå‘é€æ¶ˆæ¯ï¼Œæœ¬è´¨æ˜¯å‘æ¥æ”¶æ–¹çš„eventé˜Ÿåˆ—ä¸­æ·»åŠ äº‹ä»¶ï¼›
        (2)çº¿ç¨‹é€šè¿‡_spdk_reactor_start_pollerå’Œ_spdk_reactor_stop_pollerå¯åŠ¨å’Œåœæ­¢pollerï¼›
        (3)IO Channelç­‰çº¿ç¨‹ç›¸å…³å¯¹è±¡ä¹Ÿä¼šè®°å½•åˆ°çº¿ç¨‹å¯¹è±¡ä¸­ */
    if (spdk_allocate_thread(_spdk_reactor_send_msg,
            _spdk_reactor_start_poller,
            _spdk_reactor_stop_poller,
            reactor, thread_name) == NULL) {
        return -1;
    }
    
    /* spin_cyclesä»£è¡¨æœ€çŸ­è½®å¾ªæ—¶é—´ */
    spin_cycles = SPDK_REACTOR_SPIN_TIME_USEC * spdk_get_ticks_hz() / SPDK_SEC_TO_USEC;
    /* sleep_cyclesä»£è¡¨æœ€é•¿ç¡çœ æ—¶é—´ */
    sleep_cycles = reactor-&gt;max_delay_us * spdk_get_ticks_hz() / SPDK_SEC_TO_USEC;
    idle_started = 0;
    timer_poll_count = 0;

    /* è½®å¾ªçš„æ­»å¾ªç¯æ­£å¼å¼€å§‹ */
    while (1) {
        bool took_action = false;

        /* é¦–å…ˆï¼Œæ¯ä¸ªreactorçº¿ç¨‹é€šè¿‡DPDKçš„æ— é”é˜Ÿåˆ—å®ç°äº†ä¸€ä¸ªäº‹ä»¶é˜Ÿåˆ—ï¼›è¿™é‡Œä»äº‹ä»¶é˜Ÿåˆ—ä¸­å–å‡ºäº‹ä»¶å¹¶è°ƒç”¨äº‹ä»¶
            çš„å¤„ç†å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œvhostçš„å­ç³»ç»Ÿçš„åˆå§‹åŒ–å³æ˜¯åœ¨spdk_subsystem_initä¸­äº§ç”Ÿäº†ä¸€ä¸ªverifyäº‹ä»¶å¹¶
            æ·»åŠ åˆ°ä¸»çº¿ç¨‹reactorçš„äº‹ä»¶é˜Ÿåˆ—ä¸­ï¼Œè¯¥äº‹ä»¶å¤„ç†å‡½æ•°ä¸ºspdk_subsystem_verify */
        event_count = _spdk_event_queue_run_batch(reactor);
        if (event_count &gt; 0) {
            took_action = true;
        }

        /* æ¥ç€ï¼Œæ¯ä¸ªreactorçº¿ç¨‹ä»active_pollersé“¾è¡¨å¤´éƒ¨å–å‡ºä¸€ä¸ªpollerå¹¶è°ƒç”¨å…¶fnå‡½æ•°ã€‚pollerä»£è¡¨ä¸€æ¬¡
            å…·ä½“çš„å¤„ç†åŠ¨ä½œï¼Œä¾‹å¦‚å¤„ç†æŸä¸ªvhost_blkè®¾å¤‡çš„æ‰€æœ‰IOç¯ä¸­çš„è¯·æ±‚ï¼Œåˆæˆ–è€…å¤„ç†åç«¯NVMeæŸä¸ªqueue 
            pairä¸­çš„æ‰€æœ‰å“åº” */
        poller = TAILQ_FIRST(&amp;reactor-&gt;active_pollers);
        if (poller) {
            TAILQ_REMOVE(&amp;reactor-&gt;active_pollers, poller, tailq);
            poller-&gt;state = SPDK_POLLER_STATE_RUNNING;
            poller-&gt;fn(poller-&gt;arg);
            if (poller-&gt;state == SPDK_POLLER_STATE_UNREGISTERED) {
                free(poller);
            } else {
                poller-&gt;state = SPDK_POLLER_STATE_WAITING;
                TAILQ_INSERT_TAIL(&amp;reactor-&gt;active_pollers, poller, tailq);
            }
            took_action = true;
        }

        /* æœ€åï¼Œreactorçº¿ç¨‹è¿˜å®ç°äº†å®šæ—¶å™¨é€»è¾‘ï¼Œè¿™é‡Œåˆ¤æ–­æ˜¯å¦æœ‰å®šæ—¶å™¨åˆ°æœŸï¼›å¦‚æœç¡®æœ‰å®šæ—¶å™¨åˆ°æœŸåˆ™æ‰§è¡Œå…¶å›è°ƒå¹¶å°†
            å…¶æ”¾åˆ°å®šæ—¶å™¨é˜Ÿåˆ—å°¾éƒ¨ */
        if (timer_poll_count &gt;= SPDK_TIMER_POLL_ITERATIONS) {
            poller = TAILQ_FIRST(&amp;reactor-&gt;timer_pollers);
            if (poller) {
                now = spdk_get_ticks();

                if (now &gt;= poller-&gt;next_run_tick) {
                    TAILQ_REMOVE(&amp;reactor-&gt;timer_pollers, poller, tailq);
                    poller-&gt;state = SPDK_POLLER_STATE_RUNNING;
                    poller-&gt;fn(poller-&gt;arg);
                    if (poller-&gt;state == SPDK_POLLER_STATE_UNREGISTERED) {
                        free(poller);
                    } else {
                        poller-&gt;state = SPDK_POLLER_STATE_WAITING;
                        _spdk_poller_insert_timer(reactor, poller, now);
                    }
                    took_action = true;
                }
            }
            timer_poll_count = 0;
        } else {
            timer_poll_count++;
        }

        /* ä¸‹é¢çš„é€»è¾‘ä¸»è¦ç”¨æ¥å†³å®šè½®å¾ªçº¿ç¨‹æ˜¯å¦å¯ä»¥ç¡çœ ä¸€ä¼š */

        if (took_action) {
            /* We were busy this loop iteration. Reset the idle timer. */
            idle_started = 0;
        } else if (idle_started == 0) {
            /* We were previously busy, but this loop we took no actions. */
            idle_started = spdk_get_ticks();
        }

        /* Determine if the thread can sleep */
        if (sleep_cycles &amp;&amp; idle_started) {
            now = spdk_get_ticks();
            if (now &gt;= (idle_started + spin_cycles)) { /* ä¿è¯è½®å¾ªçº¿ç¨‹æœ€å°‘å·²æ‰§è¡Œäº†spin_cycles */
                sleep_us = reactor-&gt;max_delay_us;

                poller = TAILQ_FIRST(&amp;reactor-&gt;timer_pollers);
                if (poller) {
                    /* There are timers registered, so don't sleep beyond
                     * when the next timer should fire */
                    if (poller-&gt;next_run_tick &lt; (now + sleep_cycles)) {
                        if (poller-&gt;next_run_tick &lt;= now) {
                            sleep_us = 0;
                        } else {
                            sleep_us = ((poller-&gt;next_run_tick - now) *
                                SPDK_SEC_TO_USEC) / spdk_get_ticks_hz();
                        }
                    }
                }

                if (sleep_us &gt; 0) {
                    usleep(sleep_us);
                }

                /* After sleeping, always poll for timers */
                timer_poll_count = SPDK_TIMER_POLL_ITERATIONS;
            }
        }

        if (g_reactor_state != SPDK_REACTOR_STATE_RUNNING) {
            break;
        }
    } /* æ­»å¾ªç¯ç»“æŸ */

    ...
    spdk_free_thread();
    return 0;
}
</code></pre></div></div>

<p>â€ƒâ€ƒè‡³æ­¤ï¼Œreactorçº¿ç¨‹æ•´ä½“æ‰§è¡Œé€»è¾‘å·²åˆ†æå®Œæˆï¼Œåç»­æˆ‘ä»¬å°†ä»¥verify_eventä¸ºçº¿ç´¢å¼€å§‹åˆ†æå„ä¸ªå­ç³»ç»Ÿçš„åˆå§‹åŒ–è¿‡ç¨‹ã€‚</p>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2018/05/SPDK-reactors-init/">ã€SPDKã€‘å››ã€reactorçº¿ç¨‹</a></p>
:ET