I"ä3<p>â€ƒâ€ƒSPDKä»åŠŸèƒ½è§’åº¦å°†å„ä¸ªç‹¬ç«‹çš„éƒ¨åˆ†åˆ’åˆ†ä¸ºâ€œ<strong>å­ç³»ç»Ÿ</strong>â€œã€‚ä¾‹å¦‚å¯¹å„ç§åç«¯å­˜å‚¨çš„è®¿é—®å±äºbdevå­ç³»ç»Ÿï¼Œåˆä¾‹å¦‚å¯¹è™šæ‹Ÿæœºå‘ˆç°å„ç§è®¾å¤‡å±äºvhostå­ç³»ç»Ÿã€‚ä¸åŒåœºæ™¯ä¸‹ï¼Œå„ç§å·¥å…·å¯ä»¥é€šè¿‡ç»„åˆä¸åŒçš„å­ç³»ç»Ÿæ¥å®ç°å„ç§ä¸åŒçš„åŠŸèƒ½ã€‚ä¾‹å¦‚è™šæ‹ŸåŒ–åœºæ™¯ä¸‹ï¼Œvhostä¸»è¦é›†æˆäº†bdevã€vhostã€scsiç­‰å­ç³»ç»Ÿã€‚è¿™äº›å­ç³»ç»Ÿå­˜åœ¨ä¸€å®šä¾èµ–å…³ç³»ï¼Œä¾‹å¦‚vhostå­ç³»ç»Ÿä¾èµ–bdevï¼Œè¿™å°±éœ€è¦å°†è¢«ä¾èµ–çš„å­ç³»ç»Ÿå…ˆåˆå§‹åŒ–å®Œæˆï¼Œæ‰èƒ½æ‰§è¡Œå…¶å®ƒå­ç³»ç»Ÿçš„åˆå§‹åŒ–ã€‚</p>

<p>â€ƒâ€ƒæœ¬ç¯‡åšæ–‡æˆ‘ä»¬å…ˆæ•´ä½“ä»‹ç»ä¸€ä¸‹SPDKå­ç³»ç»Ÿçš„åˆå§‹åŒ–æµç¨‹ï¼Œç„¶åå†æ·±å…¥åˆ†æä¸€ä¸‹bdevå­ç³»ç»Ÿã€‚vhostå­ç³»ç»Ÿæˆ‘ä»¬å°†åœ¨ç‹¬ç«‹çš„åšæ–‡ä¸­å±•å¼€åˆ†æã€‚</p>

<h3 id="spdkå­ç³»ç»Ÿ">SPDKå­ç³»ç»Ÿ</h3>

<p>â€ƒâ€ƒé€šè¿‡å‰æ–‡çš„åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“ä¸»çº¿ç¨‹åœ¨æ‰§è¡Œ_spdk_reactor_runæ—¶ï¼Œé¦–å…ˆå¤„ç†çš„äº‹ä»¶ä¾¿æ˜¯verifyäº‹ä»¶ï¼Œè¯¥äº‹ä»¶å¤„ç†å‡½æ•°ä¸ºspdk_subsystem_verifyï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/event/subsystem.c:

static void
spdk_subsystem_verify(void *arg1, void *arg2)
{
    struct spdk_subsystem_depend *dep;

    /* æ£€æŸ¥å½“å‰åº”ç”¨ä¸­æ‰€æœ‰éœ€è¦çš„å­ç³»ç»ŸåŠå…¶ä¾èµ–ç³»ç»Ÿæ˜¯å¦å‡å·²æˆåŠŸæ³¨å†Œ */
    /* Verify that all dependency name and depends_on subsystems are registered */
    TAILQ_FOREACH(dep, &amp;g_subsystems_deps, tailq) {
        if (!spdk_subsystem_find(&amp;g_subsystems, dep-&gt;name)) {
            SPDK_ERRLOG("subsystem %s is missing\n", dep-&gt;name);
            spdk_app_stop(-1);
            return;
        }
        if (!spdk_subsystem_find(&amp;g_subsystems, dep-&gt;depends_on)) {
            SPDK_ERRLOG("subsystem %s dependency %s is missing\n",
                dep-&gt;name, dep-&gt;depends_on);
            spdk_app_stop(-1);
            return;
        }
    }

    /* æŒ‰ä¾èµ–å…³ç³»å¯¹æ‰€æœ‰å­ç³»ç»Ÿè¿›è¡Œæ’åº */
    subsystem_sort();

    /* ä¾æ®æ’åºä¾æ¬¡æ‰§è¡Œå„ä¸ªå­ç³»ç»Ÿçš„initå‡½æ•° */
    spdk_subsystem_init_next(0);
}
</code></pre></div></div>

<h3 id="bdevå­ç³»ç»Ÿ">bdevå­ç³»ç»Ÿ</h3>

<p>â€ƒâ€ƒbdevå’Œvhostæ˜¯è™šæ‹ŸåŒ–åœºæ™¯ä¸‹ä¸¤ä¸ªæœ€ä¸ºä¸»è¦çš„å­ç³»ç»Ÿï¼Œä¸”vhostä¾èµ–bdevï¼Œå› æ­¤æˆ‘ä»¬å…ˆæ¥åˆ†æä¸€ä¸‹bdevå­ç³»ç»Ÿã€‚</p>

<p>â€ƒâ€ƒæˆ‘ä»¬å¯ä»¥çœ‹åˆ°bdevå­ç³»ç»Ÿçš„åˆå§‹åŒ–å‡½æ•°ä¸ºspdk_bdev_subsystem_initializeï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/event/subsystems/bdev/bdev.c:

static struct spdk_subsystem g_spdk_subsystem_bdev = {
    .name = "bdev",
    .init = spdk_bdev_subsystem_initialize,
    .fini = spdk_bdev_subsystem_finish,
    .config = spdk_bdev_config_text,
    .write_config_json = _spdk_bdev_subsystem_config_json,
};
</code></pre></div></div>

<p>â€ƒâ€ƒbdevå­ç³»ç»Ÿé’ˆå¯¹ä¸åŒçš„åç«¯å­˜å‚¨è®¾å¤‡å®ç°äº†ä¸åŒçš„â€œ<strong>æ¨¡å—</strong>â€ï¼Œä¾‹å¦‚nvmeæ¨¡å—ä¸»è¦å®ç°äº†ç”¨æˆ·æ€å¯¹nvmeè®¾å¤‡çš„è®¿é—®æ“ä½œï¼Œvirtioå®ç°äº†ç”¨æˆ·æ€å¯¹virtioè®¾å¤‡çš„è®¿é—®æ“ä½œï¼Œåˆä¾‹å¦‚mallocæ¨¡å—é€šè¿‡å†…å­˜å®ç°äº†ä¸€ä¸ªæ¨¡æ‹Ÿçš„å—è®¾å¤‡ã€‚å› æ­¤bdevå­ç³»ç»Ÿåœ¨åˆå§‹åŒ–æ—¶ä¸»è¦é’ˆå¯¹é…ç½®æ–‡ä»¶ä¸­å·²ç»é…ç½®çš„åç«¯å­˜å‚¨æ¨¡å—è¿›è¡Œåˆå§‹åŒ–æ“ä½œã€‚</p>

<p>â€ƒâ€ƒå¦å¤–ï¼Œbdevå€ŸåŠ©IO Channelçš„æ¦‚å¿µä¹Ÿå®ç°äº†ç³»ç»Ÿçº§çš„management_channelå’Œæ¨¡å—çº§çš„module_channelã€‚æˆ‘ä»¬çŸ¥é“IO Channelæ˜¯ä¸€ä¸ªçº¿ç¨‹ç›¸å…³çš„æ¦‚å¿µï¼Œmanagement_channelå’Œmodule_channelä¹Ÿæ˜¯å¦‚æ­¤ï¼š</p>

<ul>
  <li>
    <p>management_channelæ˜¯çº¿ç¨‹å”¯ä¸€çš„ä¸€ä¸ªå¯¹è±¡ï¼Œä¸åŒçº¿ç¨‹å…·å¤‡ä¸åŒçš„çš„management_channelï¼ŒåŒä¸€ä¸ªçº¿ç¨‹åªæœ‰ä¸€ä¸ªã€‚ç›®å‰management_channelä¸­å®ç°äº†ä¸€ä¸ªçº¿ç¨‹å†…éƒ¨ç‹¬ç«‹çš„å†…å­˜æ± ï¼Œç”¨æ¥ç¼“å­˜bdev_ioå¯¹è±¡ï¼›</p>
  </li>
  <li>
    <p>module_channelæ˜¯çº¿ç¨‹å†…éƒ¨å±äºåŒä¸€ä¸ªæ¨¡å—çš„bdevæ‰€å…±äº«çš„ä¸€ä¸ªå¯¹è±¡ï¼Œç”¨æ¥è®°å½•åŒä¸€çº¿ç¨‹ä¸­å±äºåŒä¸€æ¨¡å—çš„æ‰€æœ‰å¯¹è±¡ã€‚ä¾‹å¦‚åŒä¸€ä¸ªçº¿ç¨‹å¦‚æœæ“ä½œä¸¤ä¸ªnvmeçš„bdevå¯¹è±¡ä¸”è¿™ä¸¤ä¸ªbdevå±äºä¸åŒçš„nvmeæ§åˆ¶å™¨ï¼Œé‚£ä¹ˆè™½ç„¶è¿™ä¸¤ä¸ªbdevå¯¹åº”ä¸åŒçš„NVMe IO Channelï¼Œä½†æ˜¯å®ƒä»¬å±äºåŒä¸€ä¸ªmodule_channelã€‚ç›®å‰module_channelåªå«æœ‰ä¸€ä¸ªæ¨¡å—çº§çš„å¼•ç”¨è®¡æ•°å’Œå†…å­˜ä¸è¶³æ—¶çš„bdev ioä¸´æ—¶é˜Ÿåˆ—(å½“æœ‰å†…å­˜ç©ºé—´æ—¶ï¼Œå®ç°IOé‡å‘)ã€‚</p>
  </li>
</ul>

<p>â€ƒâ€ƒæ¯ä¸ªæ¨¡å—éƒ½ä¼šæä¾›ä¸€ä¸ªmodule_initå‡½æ•°ï¼Œå½“bdevå­ç³»ç»Ÿåˆå§‹åŒ–æ—¶ä¼šä¾æ¬¡è°ƒç”¨è¿™äº›åˆå§‹åŒ–å‡½æ•°ã€‚ä¸‹é¢æˆ‘ä»¬ä»¥NVMeå’Œvirtioä¸¤ä¸ªæ¨¡å—ä¸ºä¾‹ï¼Œæ¥ç®€è¦çœ‹ä¸‹æ¨¡å—çš„åˆå§‹åŒ–é€»è¾‘ã€‚</p>

<h4 id="1-nvmeæ¨¡å—åˆå§‹åŒ–"><strong>1. nvmeæ¨¡å—åˆå§‹åŒ–</strong></h4>

<p>â€ƒâ€ƒnvmeæ¨¡å—æè¿°å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/bdev/nvme/bdev_nvme.c:

static struct spdk_bdev_module nvme_if = {
    .name = "nvme",
    .module_init = bdev_nvme_library_init,
    .module_fini = bdev_nvme_library_fini,
    .config_text = bdev_nvme_get_spdk_running_config,
    .config_json = bdev_nvme_config_json,
    .get_ctx_size = bdev_nvme_get_ctx_size,

    };
</code></pre></div></div>

<p>â€ƒâ€ƒè¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°nvmeæ¨¡å—çš„åˆå§‹åŒ–å‡½æ•°ä¸ºbdev_nvme_library_initï¼Œå¦å¤–bdev_nvme_get_ctx_sizeè¿”å›çš„contextå¤§å°ä¸ºnvme_bdev_ioçš„å¤§å°ã€‚bdevå­ç³»ç»Ÿä¼šä»¥æ‰€æœ‰æ¨¡å—æœ€å¤§çš„contextå¤§å°æ¥åˆ›å»ºbdev_ioå†…å­˜æ± ï¼Œä»¥æ­¤ç¡®ä¿ä¸ºæ‰€æœ‰æ¨¡å—ç”³è¯·bdev_ioæ—¶éƒ½èƒ½è·å¾—è¶³å¤Ÿçš„æ‰©å±•å†…å­˜(nvme_bdev_ioå³æ˜¯å¯¹bdev_ioçš„æ‰©å±•)ã€‚</p>

<p>â€ƒâ€ƒbdev_nvme_library_initå‡½æ•°ä»SPDKçš„é…ç½®æ–‡ä»¶ä¸­è¯»å–â€œNvmeâ€å­—æ®µå¼€å§‹çš„ç›¸å…³ä¿¡æ¯ï¼Œå¹¶é€šè¿‡è¿™äº›ä¿¡æ¯åˆ›å»ºä¸€ä¸ªNVMeæ§åˆ¶å™¨å¹¶è·å–å…¶ä¸‹çš„namespaceï¼Œæœ€åå°†namespaceè¡¨ç¤ºæˆä¸€ä¸ªbdevå¯¹è±¡ã€‚è¿™é‡Œæˆ‘ä»¬æ‰“å¼€çœ‹ä¸€ä¸‹è¯†åˆ«åˆ°å¯¹åº”NVMeæ§åˆ¶å™¨åçš„å›è°ƒå¤„ç†é€»è¾‘ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
static void
attach_cb(void *cb_ctx, const struct spdk_nvme_transport_id *trid,
            struct spdk_nvme_ctrlr *ctrlr, const struct spdk_nvme_ctrlr_opts *opts)
{
    struct nvme_ctrlr *nvme_ctrlr;
    struct nvme_probe_ctx *ctx = cb_ctx;
    char *name = NULL;
    size_t i;

    /* é¦–å…ˆæ ¹æ®DPDKä¸­PCIé©±åŠ¨æ¡†æ¶è¯†åˆ«åˆ°çš„NVMeæ§åˆ¶å™¨ä¿¡æ¯æ¥åˆ›å»ºä¸€ä¸ªnvme_ctrlrå¯¹è±¡ */
    if (ctx) {
        for (i = 0; i &lt; ctx-&gt;count; i++) {
            if (spdk_nvme_transport_id_compare(trid, &amp;ctx-&gt;trids[i]) == 0) {
                name = strdup(ctx-&gt;names[i]);
                break;
            }
        }
    } else {
        name = spdk_sprintf_alloc("HotInNvme%d", g_hot_insert_nvme_controller_index++);
    }

    nvme_ctrlr = calloc(1, sizeof(*nvme_ctrlr));
    ...
    nvme_ctrlr-&gt;adminq_timer_poller = NULL;
    nvme_ctrlr-&gt;ctrlr = ctrlr;
    nvme_ctrlr-&gt;ref = 0;
    nvme_ctrlr-&gt;trid = *trid;
    nvme_ctrlr-&gt;name = name;

    /* å°†è¯¥nvmeæ§åˆ¶å™¨å¯¹è±¡æ·»åŠ ä¸ºä¸€ä¸ªio deviceï¼›æ¯ä¸ªio deviceå¯ç”³è¯·ç‹¬ç«‹çš„IO Channelï¼›
        bdev_nvme_create_cbè´Ÿè´£åœ¨IO Channelå¯¹è±¡åˆ›å»ºæ—¶åˆå§‹åŒ–åº•å±‚é©±åŠ¨ç›¸å…³å¯¹è±¡ï¼Œè¿™é‡Œ
        å³æ˜¯è·å–ä¸€ä¸ªæ–°çš„queue pair */
    spdk_io_device_register(ctrlr, bdev_nvme_create_cb, bdev_nvme_destroy_cb,
                                                sizeof(struct nvme_io_channel));

    /* æ­¤å¤„å¼€å§‹æšä¸¾nvmeæ§åˆ¶å™¨ä¸‹çš„æ‰€æœ‰namespaceï¼Œå¹¶å°†å…¶å»ºä¸ºbdevå¯¹è±¡ã€‚æ³¨æ„ä¸€ç‚¹ï¼Œæ­¤æ—¶å¹¶ä¸ä¼šä¸º
        bdevç”³è¯·IO channelï¼Œå®ƒæ˜¯vhostå­ç³»ç»Ÿåˆå§‹æ—¶ï¼Œå®Œæˆçº¿ç¨‹ç»‘å®šåæ‰åˆ›å»ºçš„ */
    if (nvme_ctrlr_create_bdevs(nvme_ctrlr) != 0) {
        ...
    }

    nvme_ctrlr-&gt;adminq_timer_poller = spdk_poller_register(bdev_nvme_poll_adminq, ctrlr,
                                                    g_nvme_adminq_poll_timeout_us);

    TAILQ_INSERT_TAIL(&amp;g_nvme_ctrlrs, nvme_ctrlr, tailq);

    ...
}

/* æ³¨æ„ï¼šbdevåˆå§‹åŒ–æ—¶å¹¶ä¸è°ƒç”¨è¯¥å‡½æ•° */
static int
bdev_nvme_create_cb(void *io_device, void *ctx_buf)
{
    struct spdk_nvme_ctrlr *ctrlr = io_device;
    struct nvme_io_channel *ch = ctx_buf;

    /* åˆ†é…ä¸€ä¸ªnvme queue pairä½œä¸ºè¯¥IO Channelçš„å®é™…å¯¹è±¡ */
    ch-&gt;qpair = spdk_nvme_ctrlr_alloc_io_qpair(ctrlr, NULL, 0);
    ...
    /* å‘reactoræ³¨å†Œä¸€ä¸ªpollerï¼Œè½®å¾ªæ–°åˆ†é…queue pairä¸­å·²å®Œæˆçš„å“åº”ä¿¡æ¯ */
    ch-&gt;poller = spdk_poller_register(bdev_nvme_poll, ch, 0);
    return 0;
}
</code></pre></div></div>

<p>â€ƒâ€ƒç±»ä¼¼åœ°ï¼Œæˆ‘ä»¬å†çœ‹ä¸€ä¸‹virtioæ¨¡å—çš„åˆå§‹åŒ–ã€‚</p>

<h4 id="2-virtioæ¨¡å—åˆå§‹åŒ–"><strong>2. virtioæ¨¡å—åˆå§‹åŒ–</strong></h4>

<p>â€ƒâ€ƒvirtioè™½è¯´èµ·æºäºqemu-kvmè™šæ‹ŸåŒ–ï¼Œä½†æ˜¯å®ƒä¹Ÿæ˜¯ä¸€ç§å¯ç”¨ç‰©ç†ç¡¬ä»¶å®ç°çš„åè®®è§„èŒƒã€‚å› æ­¤SPDKä¹ŸæŠŠå®ƒå½“åšä¸€ç§åç«¯å­˜å‚¨ç±»å‹åŠ ä»¥å®ç°ã€‚å½“ç„¶ï¼Œå¦‚æœSPDKçš„vhostè¿›ç¨‹æ˜¯è¿è¡Œåœ¨è™šæ‹Ÿæœºä¸­(è€Œè™šæ‹Ÿæœºvirtioè®¾å¤‡ä½œä¸ºåç«¯å­˜å‚¨)ï¼Œvirtioæ¨¡å—å°±æ˜¯ä¸€ä¸ªå¿…ä¸å¯å°‘çš„é©±åŠ¨æ¨¡å—äº†ã€‚</p>

<p>â€ƒâ€ƒæˆ‘ä»¬ä»¥virtio-blkè®¾å¤‡ä¸ºä¾‹ï¼Œæ¥çœ‹ä¸€ä¸‹å…¶åˆå§‹åŒ–è¿‡ç¨‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/bdev/virtio/bdev_virtio_blk.c:

static struct spdk_bdev_module virtio_blk_if = {
    .name = "virtio_blk",
    .module_init = bdev_virtio_initialize,
    .get_ctx_size = bdev_virtio_blk_get_ctx_size,
};
</code></pre></div></div>
<p>â€ƒâ€ƒbdev_virtio_initializeé€šè¿‡é…ç½®æ–‡ä»¶è·å–ç›¸å…³é…ç½®ä¿¡æ¯ï¼Œå¹¶åŒæ ·å€ŸåŠ©DPDKçš„ç”¨æˆ·æ€PCIè®¾å¤‡ç®¡ç†æ¡†æ¶è¯†åˆ«åˆ°è¯¥è®¾å¤‡åï¼Œè°ƒç”¨virtio_pci_blk_dev_createæ¥åˆ›å»ºä¸€ä¸ªvirtio_blkå¯¹è±¡ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spdk/lib/bdev/virtio/bdev_virtio_blk.c:

static struct virtio_blk_dev *
virtio_pci_blk_dev_create(const char *name, struct virtio_pci_ctx *pci_ctx)
{
    static int pci_dev_counter = 0;
    struct virtio_blk_dev *bvdev;
    struct virtio_dev *vdev;
    char *default_name = NULL;
    uint16_t num_queues;
    int rc;

    /* åˆ†é…ä¸€ä¸ªvirtio_blk_devå¯¹è±¡ */
    bvdev = calloc(1, sizeof(*bvdev));
    ...
    vdev = &amp;bvdev-&gt;vdev;

    /* ä¸ºè¯¥virtioå¯¹è±¡ç»‘å®šç”¨æˆ·æ€æ“ä½œæ¥å£ï¼Œæ³¨ï¼Œè¯¥æ“ä½œæ¥å£å®ç°äº†virtio 1.0è§„èŒƒ */
    rc = virtio_pci_dev_init(vdev, name, pci_ctx);
    ...

    /* é‡ç½®è®¾å¤‡çŠ¶æ€ */
    rc = virtio_dev_reset(vdev, VIRTIO_BLK_DEV_SUPPORTED_FEATURES);
    ...

    /* è·å–è®¾å¤‡æ”¯æŒçš„æœ€å¤§é˜Ÿåˆ—æ•°ã€‚å¦‚æœæ”¯æŒå¤šé˜Ÿåˆ—ï¼Œä»è®¾å¤‡çš„é…ç½®å¯„å­˜å™¨ä¸­èŠå–ï¼›å¦åˆ™ä¸º1 */
    /* TODO: add a way to limit usable virtqueues */
    if (virtio_dev_has_feature(vdev, VIRTIO_BLK_F_MQ)) {
        virtio_dev_read_dev_config(vdev, offsetof(struct virtio_blk_config, num_queues),
            &amp;num_queues, sizeof(num_queues));
    } else {
        num_queues = 1;
    }

    /* åˆå§‹åŒ–é˜Ÿåˆ—å¹¶åˆ›å»ºbdevå¯¹è±¡ */
    rc = virtio_blk_dev_init(bvdev, num_queues);
    ...

    return bvdev;
}

static int
virtio_blk_dev_init(struct virtio_blk_dev *bvdev, uint16_t max_queues)
{
    struct virtio_dev *vdev = &amp;bvdev-&gt;vdev;
    struct spdk_bdev *bdev = &amp;bvdev-&gt;bdev;
    uint64_t capacity, num_blocks;
    uint32_t block_size;
    uint16_t host_max_queues;
    int rc;

    /* è·å–å½“å‰è®¾å¤‡çš„å—å¤§å°ï¼Œé»˜è®¤ä¸º512å­—èŠ‚ */
    if (virtio_dev_has_feature(vdev, VIRTIO_BLK_F_BLK_SIZE)) {
        virtio_dev_read_dev_config(vdev, offsetof(struct virtio_blk_config, blk_size),
            &amp;block_size, sizeof(block_size));
    } else {
        block_size = 512;
    }

    /* è·å–è®¾å¤‡å®¹é‡ */
    virtio_dev_read_dev_config(vdev, offsetof(struct virtio_blk_config, capacity),
        &amp;capacity, sizeof(capacity));

    /* `capacity` is a number of 512-byte sectors. */
    num_blocks = capacity * 512 / block_size;

    /* è·å–æœ€å¤§é˜Ÿåˆ—æ•° */
    if (virtio_dev_has_feature(vdev, VIRTIO_BLK_F_MQ)) {
            virtio_dev_read_dev_config(vdev, offsetof(struct virtio_blk_config, num_queues),
        &amp;host_max_queues, sizeof(host_max_queues));
    } else {
        host_max_queues = 1;
    }

    if (virtio_dev_has_feature(vdev, VIRTIO_BLK_F_RO)) {
        bvdev-&gt;readonly = true;
    }

    /* bdev is tied with the virtio device; we can reuse the name */
    bdev-&gt;name = vdev-&gt;name;

    /* æŒ‰max_queuesåˆ†é…é˜Ÿåˆ—ï¼Œå¹¶å¯åŠ¨è®¾å¤‡ */
    rc = virtio_dev_start(vdev, max_queues, 0);
    ...

    /* ä¸ºbdevå¯¹è±¡èµ‹å€¼ */
    bdev-&gt;product_name = "VirtioBlk Disk";
    bdev-&gt;write_cache = 0;
    bdev-&gt;blocklen = block_size;
    bdev-&gt;blockcnt = num_blocks;

    bdev-&gt;ctxt = bvdev;
    bdev-&gt;fn_table = &amp;virtio_fn_table;
    bdev-&gt;module = &amp;virtio_blk_if;

    /* å°†virtio_blk_devæ·»åŠ ä¸ºä¸€ä¸ªio deviceï¼›å…¶IO Channelåˆ›å»ºå›è°ƒbdev_virtio_blk_ch_create_cbä¼šç”³è¯·ä¸€ä¸ª
        virtioçš„IOç¯ä½œä¸ºè¯¥IO Channelçš„å®é™…å¯¹è±¡ */
    spdk_io_device_register(bvdev, bdev_virtio_blk_ch_create_cb,
            bdev_virtio_blk_ch_destroy_cb,
            sizeof(struct bdev_virtio_blk_io_channel));

    /* æ³¨å†Œè¯¥bdevå¯¹è±¡ï¼Œä¾¿äºåç»­æŸ¥æ‰¾ */
    rc = spdk_bdev_register(bdev);
    ...

    return 0;
}
</code></pre></div></div>

<p><br />
è½¬è½½è¯·æ³¨æ˜ï¼š<a href="https://rootw.github.io">å´æ–Œçš„åšå®¢</a> Â» <a href="https://rootw.github.io/2018/05/SPDK-subsys-bdev/">ã€SPDKã€‘äº”ã€bdevå­ç³»ç»Ÿ</a></p>
:ET